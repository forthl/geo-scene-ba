Index: src/precompute_knns.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from data import ContrastiveSegDataset\nfrom modules import *\nimport os\nfrom os.path import join\nimport hydra\nimport numpy as np\nimport torch.multiprocessing\nimport torch.multiprocessing\nimport torch.nn as nn\nfrom omegaconf import DictConfig, OmegaConf\nfrom pytorch_lightning.utilities.seed import seed_everything\nfrom tqdm import tqdm\n\n\ndef get_feats(model, loader):\n    all_feats = []\n    for pack in tqdm(loader):\n        img = pack[\"img\"]\n        feats = F.normalize(model.forward(img.cuda()).mean([2, 3]), dim=1)\n        all_feats.append(feats.to(\"cpu\", non_blocking=True))\n    return torch.cat(all_feats, dim=0).contiguous()\n\n\n@hydra.main(config_path=\"configs\", config_name=\"train_config.yml\")\ndef my_app(cfg: DictConfig) -> None:\n    print(OmegaConf.to_yaml(cfg))\n    pytorch_data_dir = cfg.pytorch_data_dir\n    data_dir = join(cfg.output_root, \"data\")\n    log_dir = join(cfg.output_root, \"logs\")\n    os.makedirs(data_dir, exist_ok=True)\n    os.makedirs(log_dir, exist_ok=True)\n    os.makedirs(join(pytorch_data_dir, \"nns\"), exist_ok=True)\n\n    seed_everything(seed=0)\n\n    print(data_dir)\n    print(cfg.output_root)\n\n    image_sets = [\"val\", \"train\"]\n    dataset_names = [\"cocostuff27\", \"cityscapes\", \"potsdam\"]\n    crop_types = [\"five\", None]\n\n    # Uncomment these lines to run on custom datasets\n    #dataset_names = [\"directory\"]\n    #crop_types = [None]\n\n    res = 224\n    n_batches = 16\n\n    if cfg.arch == \"dino\":\n        from modules import DinoFeaturizer, LambdaLayer\n        no_ap_model = torch.nn.Sequential(\n            DinoFeaturizer(20, cfg),  # dim doesent matter\n            LambdaLayer(lambda p: p[0]),\n        ).cuda()\n    else:\n        cut_model = load_model(cfg.model_type, join(cfg.output_root, \"data\")).cuda()\n        no_ap_model = nn.Sequential(*list(cut_model.children())[:-1]).cuda()\n    par_model = torch.nn.DataParallel(no_ap_model)\n\n    for crop_type in crop_types:\n        for image_set in image_sets:\n            for dataset_name in dataset_names:\n                nice_dataset_name = cfg.dir_dataset_name if dataset_name == \"directory\" else dataset_name\n\n                feature_cache_file = join(pytorch_data_dir, \"nns\", \"nns_{}_{}_{}_{}_{}.npz\".format(\n                    cfg.model_type, nice_dataset_name, image_set, crop_type, res))\n\n                if not os.path.exists(feature_cache_file):\n                    print(\"{} not found, computing\".format(feature_cache_file))\n                    dataset = ContrastiveSegDataset(\n                        pytorch_data_dir=pytorch_data_dir,\n                        dataset_name=dataset_name,\n                        crop_type=crop_type,\n                        image_set=image_set,\n                        transform=get_transform(res, False, \"center\"),\n                        target_transform=get_transform(res, True, \"center\"),\n                        cfg=cfg,\n                    )\n\n                    loader = DataLoader(dataset, 256, shuffle=False, num_workers=cfg.num_workers, pin_memory=False)\n\n                    with torch.no_grad():\n                        normed_feats = get_feats(par_model, loader)\n                        all_nns = []\n                        step = normed_feats.shape[0] // n_batches\n                        print(normed_feats.shape)\n                        for i in tqdm(range(0, normed_feats.shape[0], step)):\n                            torch.cuda.empty_cache()\n                            batch_feats = normed_feats[i:i + step, :]\n                            pairwise_sims = torch.einsum(\"nf,mf->nm\", batch_feats, normed_feats)\n                            all_nns.append(torch.topk(pairwise_sims, 30)[1])\n                            del pairwise_sims\n                        nearest_neighbors = torch.cat(all_nns, dim=0)\n\n                        np.savez_compressed(feature_cache_file, nns=nearest_neighbors.numpy())\n                        print(\"Saved NNs\", cfg.model_type, nice_dataset_name, image_set)\n\n\nif __name__ == \"__main__\":\n    prep_args()\n    my_app()\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/precompute_knns.py b/src/precompute_knns.py
--- a/src/precompute_knns.py	(revision c6be305e586f39b07663cb9bdb535828fe4047df)
+++ b/src/precompute_knns.py	(date 1717581647517)
@@ -1,3 +1,5 @@
+from torch.utils.data import DataLoader
+
 from data import ContrastiveSegDataset
 from modules import *
 import os
@@ -11,6 +13,8 @@
 from pytorch_lightning.utilities.seed import seed_everything
 from tqdm import tqdm
 
+from src.utils import load_model, prep_args, get_transform
+
 
 def get_feats(model, loader):
     all_feats = []
Index: src/eval_segmentation.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import sys\n\nprint (sys.path)\nfrom modules import *\nfrom data import *\nfrom collections import defaultdict\nfrom multiprocessing import Pool\nimport hydra\nimport seaborn as sns\nimport torch.multiprocessing\nfrom crf import dense_crf\nfrom omegaconf import DictConfig, OmegaConf\nfrom torch.utils.data import DataLoader\nfrom tqdm import tqdm\nfrom train_segmentation import LitUnsupervisedSegmenter, prep_for_plot, get_class_labels\n\ntorch.multiprocessing.set_sharing_strategy('file_system')\n\ndef plot_cm(histogram, label_cmap, cfg):\n    fig = plt.figure(figsize=(10, 10))\n    ax = fig.gca()\n    hist = histogram.detach().cpu().to(torch.float32)\n    hist /= torch.clamp_min(hist.sum(dim=0, keepdim=True), 1)\n    sns.heatmap(hist.t(), annot=False, fmt='g', ax=ax, cmap=\"Blues\", cbar=False)\n    ax.set_title('Predicted labels', fontsize=28)\n    ax.set_ylabel('True labels', fontsize=28)\n    names = get_class_labels(cfg.dataset_name)\n    if cfg.extra_clusters:\n        names = names + [\"Extra\"]\n    ax.set_xticks(np.arange(0, len(names)) + .5)\n    ax.set_yticks(np.arange(0, len(names)) + .5)\n    ax.xaxis.tick_top()\n    ax.xaxis.set_ticklabels(names, fontsize=18)\n    ax.yaxis.set_ticklabels(names, fontsize=18)\n    colors = [label_cmap[i] / 255.0 for i in range(len(names))]\n    [t.set_color(colors[i]) for i, t in enumerate(ax.xaxis.get_ticklabels())]\n    [t.set_color(colors[i]) for i, t in enumerate(ax.yaxis.get_ticklabels())]\n    plt.xticks(rotation=90)\n    plt.yticks(rotation=0)\n    ax.vlines(np.arange(0, len(names) + 1), color=[.5, .5, .5], *ax.get_xlim())\n    ax.hlines(np.arange(0, len(names) + 1), color=[.5, .5, .5], *ax.get_ylim())\n    plt.tight_layout()\n\n\ndef batch_list(iterable, n=1):\n    l = len(iterable)\n    for ndx in range(0, l, n):\n        yield iterable[ndx:min(ndx + n, l)]\n\n\ndef _apply_crf(tup):\n    return dense_crf(tup[0], tup[1])\n\n\ndef batched_crf(pool, img_tensor, prob_tensor):\n    outputs = pool.map(_apply_crf, zip(img_tensor.detach().cpu(), prob_tensor.detach().cpu()))\n    return torch.cat([torch.from_numpy(arr).unsqueeze(0) for arr in outputs], dim=0)\n\n\n@hydra.main(config_path=\"configs\", config_name=\"eval_config.yml\")\ndef my_app(cfg: DictConfig) -> None:\n    pytorch_data_dir = cfg.pytorch_data_dir\n    result_dir = \"../results/predictions/{}\".format(cfg.experiment_name)\n    os.makedirs(join(result_dir, \"img\"), exist_ok=True)\n    os.makedirs(join(result_dir, \"label\"), exist_ok=True)\n    os.makedirs(join(result_dir, \"cluster\"), exist_ok=True)\n    os.makedirs(join(result_dir, \"picie\"), exist_ok=True)\n\n    for model_path in cfg.model_paths:\n        model = LitUnsupervisedSegmenter.load_from_checkpoint(model_path)\n        print(OmegaConf.to_yaml(model.cfg))\n\n        run_picie = cfg.run_picie and model.cfg.dataset_name == \"cocostuff27\"\n        if run_picie:\n            picie_state = torch.load(\"../saved_models/picie_and_probes.pth\")\n            picie = picie_state[\"model\"].cuda()\n            picie_cluster_probe = picie_state[\"cluster_probe\"].module.cuda()\n            picie_cluster_metrics = picie_state[\"cluster_metrics\"]\n\n        loader_crop = \"center\"\n        test_dataset = ContrastiveSegDataset(\n            pytorch_data_dir=pytorch_data_dir,\n            dataset_name=model.cfg.dataset_name,\n            crop_type=None,\n            image_set=\"val\",\n            transform=get_transform(cfg.res, False, loader_crop),\n            target_transform=get_transform(cfg.res, True, loader_crop),\n            cfg=model.cfg,\n        )\n\n        test_loader = DataLoader(test_dataset, cfg.batch_size * 2,\n                                 shuffle=False, num_workers=cfg.num_workers,\n                                 pin_memory=True, collate_fn=flexible_collate)\n\n        model.eval().cuda()\n\n        if cfg.use_ddp:\n            par_model = torch.nn.DataParallel(model.net)\n            if run_picie:\n                par_picie = torch.nn.DataParallel(picie)\n        else:\n            par_model = model.net\n            if run_picie:\n                par_picie = picie\n\n        if model.cfg.dataset_name == \"cocostuff27\":\n            # all_good_images = range(10)\n            # all_good_images = range(250)\n            # all_good_images = [61, 60, 49, 44, 13, 70] #Failure cases\n            all_good_images = [19, 54, 67, 66, 65, 75, 77, 76, 124]  # Main figure\n        elif model.cfg.dataset_name == \"cityscapes\":\n            # all_good_images = range(80)\n            # all_good_images = [ 5, 20, 56]\n            all_good_images = [11, 32, 43, 52]\n        else:\n            raise ValueError(\"Unknown Dataset {}\".format(model.cfg.dataset_name))\n        batch_nums = torch.tensor([n // (cfg.batch_size * 2) for n in all_good_images])\n        batch_offsets = torch.tensor([n % (cfg.batch_size * 2) for n in all_good_images])\n\n        saved_data = defaultdict(list)\n        with Pool(cfg.num_workers + 5) as pool:\n            for i, batch in enumerate(tqdm(test_loader)):\n                with torch.no_grad():\n                    img = batch[\"img\"].cuda()\n                    label = batch[\"label\"].cuda()\n\n                    feats, code1 = par_model(img)\n                    feats, code2 = par_model(img.flip(dims=[3]))\n                    code = (code1 + code2.flip(dims=[3])) / 2\n\n                    code = F.interpolate(code, label.shape[-2:], mode='bilinear', align_corners=False)\n\n                    linear_probs = torch.log_softmax(model.linear_probe(code), dim=1)\n                    cluster_probs = model.cluster_probe(code, 2, log_probs=True)\n\n                    if cfg.run_crf:\n                        linear_preds = batched_crf(pool, img, linear_probs).argmax(1).cuda()\n                        cluster_preds = batched_crf(pool, img, cluster_probs).argmax(1).cuda()\n                    else:\n                        linear_preds = linear_probs.argmax(1)\n                        cluster_preds = cluster_probs.argmax(1)\n\n                    model.test_linear_metrics.update(linear_preds, label)\n                    model.test_cluster_metrics.update(cluster_preds, label)\n\n                    if run_picie:\n                        picie_preds = picie_cluster_metrics.map_clusters(\n                            picie_cluster_probe(par_picie(img), None)[1].argmax(1).cpu())\n\n                    if i in batch_nums:\n                        matching_offsets = batch_offsets[torch.where(batch_nums == i)]\n                        for offset in matching_offsets:\n                            saved_data[\"linear_preds\"].append(linear_preds.cpu()[offset].unsqueeze(0))\n                            saved_data[\"cluster_preds\"].append(cluster_preds.cpu()[offset].unsqueeze(0))\n                            saved_data[\"label\"].append(label.cpu()[offset].unsqueeze(0))\n                            saved_data[\"img\"].append(img.cpu()[offset].unsqueeze(0))\n                            if run_picie:\n                                saved_data[\"picie_preds\"].append(picie_preds.cpu()[offset].unsqueeze(0))\n        saved_data = {k: torch.cat(v, dim=0) for k, v in saved_data.items()}\n\n        tb_metrics = {\n            **model.test_linear_metrics.compute(),\n            **model.test_cluster_metrics.compute(),\n        }\n\n        print(\"\")\n        print(model_path)\n        print(tb_metrics)\n\n        if cfg.run_prediction:\n            n_rows = 3\n        else:\n            n_rows = 2\n\n        if run_picie:\n            n_rows += 1\n\n        if cfg.dark_mode:\n            plt.style.use('dark_background')\n\n        for good_images in batch_list(range(len(all_good_images)), 10):\n            fig, ax = plt.subplots(n_rows, len(good_images), figsize=(len(good_images) * 3, n_rows * 3))\n            for i, img_num in enumerate(good_images):\n                plot_img = (prep_for_plot(saved_data[\"img\"][img_num]) * 255).numpy().astype(np.uint8)\n                plot_label = (model.label_cmap[saved_data[\"label\"][img_num]]).astype(np.uint8)\n                Image.fromarray(plot_img).save(join(join(result_dir, \"img\", str(img_num) + \".jpg\")))\n                Image.fromarray(plot_label).save(join(join(result_dir, \"label\", str(img_num) + \".png\")))\n\n                ax[0, i].imshow(plot_img)\n                ax[1, i].imshow(plot_label)\n                if cfg.run_prediction:\n                    plot_cluster = (model.label_cmap[\n                        model.test_cluster_metrics.map_clusters(\n                            saved_data[\"cluster_preds\"][img_num])]) \\\n                        .astype(np.uint8)\n                    Image.fromarray(plot_cluster).save(join(join(result_dir, \"cluster\", str(img_num) + \".png\")))\n                    ax[2, i].imshow(plot_cluster)\n                if run_picie:\n                    picie_img = model.label_cmap[saved_data[\"picie_preds\"][img_num]].astype(np.uint8)\n                    ax[3, i].imshow(picie_img)\n                    Image.fromarray(picie_img).save(join(join(result_dir, \"picie\", str(img_num) + \".png\")))\n\n            ax[0, 0].set_ylabel(\"Image\", fontsize=26)\n            ax[1, 0].set_ylabel(\"Label\", fontsize=26)\n            if cfg.run_prediction:\n                ax[2, 0].set_ylabel(\"STEGO\\n(Ours)\", fontsize=26)\n            if run_picie:\n                ax[3, 0].set_ylabel(\"PiCIE\\n(Baseline)\", fontsize=26)\n\n            remove_axes(ax)\n            plt.tight_layout()\n            plt.show()\n            plt.clf()\n\n        plot_cm(model.test_cluster_metrics.histogram, model.label_cmap, model.cfg)\n        plt.show()\n        plt.clf()\n\n\nif __name__ == \"__main__\":\n    prep_args()\n    my_app()\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/eval_segmentation.py b/src/eval_segmentation.py
--- a/src/eval_segmentation.py	(revision c6be305e586f39b07663cb9bdb535828fe4047df)
+++ b/src/eval_segmentation.py	(date 1717584581522)
@@ -1,5 +1,9 @@
 import sys
 
+from matplotlib import pyplot as plt
+
+from src.utils import get_transform, flexible_collate, remove_axes, prep_args, prep_for_plot
+
 print (sys.path)
 from modules import *
 from data import *
@@ -12,7 +16,7 @@
 from omegaconf import DictConfig, OmegaConf
 from torch.utils.data import DataLoader
 from tqdm import tqdm
-from train_segmentation import LitUnsupervisedSegmenter, prep_for_plot, get_class_labels
+from train_segmentation import LitUnsupervisedSegmenter, get_class_labels #prep_for_plot,
 
 torch.multiprocessing.set_sharing_strategy('file_system')
 
Index: src/dino/utils.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># Copyright (c) Facebook, Inc. and its affiliates.\n# \n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n# \n#     http://www.apache.org/licenses/LICENSE-2.0\n# \n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\"\"\"\nMisc functions.\n\nMostly copy-paste from torchvision references or other public repos like DETR:\nhttps://github.com/facebookresearch/detr/blob/master/util/misc.py\n\"\"\"\nimport os\nimport sys\nimport time\nimport math\nimport random\nimport datetime\nimport subprocess\nfrom collections import defaultdict, deque\n\nimport numpy as np\nimport torch\nfrom torch import nn\nimport torch.distributed as dist\nfrom PIL import ImageFilter, ImageOps\n\n\nclass GaussianBlur(object):\n    \"\"\"\n    Apply Gaussian Blur to the PIL image.\n    \"\"\"\n    def __init__(self, p=0.5, radius_min=0.1, radius_max=2.):\n        self.prob = p\n        self.radius_min = radius_min\n        self.radius_max = radius_max\n\n    def __call__(self, img):\n        do_it = random.random() <= self.prob\n        if not do_it:\n            return img\n\n        return img.filter(\n            ImageFilter.GaussianBlur(\n                radius=random.uniform(self.radius_min, self.radius_max)\n            )\n        )\n\n\nclass Solarization(object):\n    \"\"\"\n    Apply Solarization to the PIL image.\n    \"\"\"\n    def __init__(self, p):\n        self.p = p\n\n    def __call__(self, img):\n        if random.random() < self.p:\n            return ImageOps.solarize(img)\n        else:\n            return img\n\n\ndef load_pretrained_weights(model, pretrained_weights, checkpoint_key, model_name, patch_size):\n    if os.path.isfile(pretrained_weights):\n        state_dict = torch.load(pretrained_weights, map_location=\"cpu\")\n        if checkpoint_key is not None and checkpoint_key in state_dict:\n            print(f\"Take key {checkpoint_key} in provided checkpoint dict\")\n            state_dict = state_dict[checkpoint_key]\n        # remove `module.` prefix\n        state_dict = {k.replace(\"module.\", \"\"): v for k, v in state_dict.items()}\n        # remove `backbone.` prefix induced by multicrop wrapper\n        state_dict = {k.replace(\"backbone.\", \"\"): v for k, v in state_dict.items()}\n        msg = model.load_state_dict(state_dict, strict=False)\n        print('Pretrained weights found at {} and loaded with msg: {}'.format(pretrained_weights, msg))\n    else:\n        print(\"Please use the `--pretrained_weights` argument to indicate the path of the checkpoint to evaluate.\")\n        url = None\n        if model_name == \"vit_small\" and patch_size == 16:\n            url = \"dino_deitsmall16_pretrain/dino_deitsmall16_pretrain.pth\"\n        elif model_name == \"vit_small\" and patch_size == 8:\n            url = \"dino_deitsmall8_pretrain/dino_deitsmall8_pretrain.pth\"\n        elif model_name == \"vit_base\" and patch_size == 16:\n            url = \"dino_vitbase16_pretrain/dino_vitbase16_pretrain.pth\"\n        elif model_name == \"vit_base\" and patch_size == 8:\n            url = \"dino_vitbase8_pretrain/dino_vitbase8_pretrain.pth\"\n        if url is not None:\n            print(\"Since no pretrained weights have been provided, we load the reference pretrained DINO weights.\")\n            state_dict = torch.hub.load_state_dict_from_url(url=\"https://dl.fbaipublicfiles.com/dino/\" + url)\n            model.load_state_dict(state_dict, strict=True)\n        else:\n            print(\"There is no reference weights available for this model => We use random weights.\")\n\n\ndef clip_gradients(model, clip):\n    norms = []\n    for name, p in model.named_parameters():\n        if p.grad is not None:\n            param_norm = p.grad.data.norm(2)\n            norms.append(param_norm.item())\n            clip_coef = clip / (param_norm + 1e-6)\n            if clip_coef < 1:\n                p.grad.data.mul_(clip_coef)\n    return norms\n\n\ndef cancel_gradients_last_layer(epoch, model, freeze_last_layer):\n    if epoch >= freeze_last_layer:\n        return\n    for n, p in model.named_parameters():\n        if \"last_layer\" in n:\n            p.grad = None\n\n\ndef restart_from_checkpoint(ckp_path, run_variables=None, **kwargs):\n    \"\"\"\n    Re-start from checkpoint\n    \"\"\"\n    if not os.path.isfile(ckp_path):\n        return\n    print(\"Found checkpoint at {}\".format(ckp_path))\n\n    # open checkpoint file\n    checkpoint = torch.load(ckp_path, map_location=\"cpu\")\n\n    # key is what to look for in the checkpoint file\n    # value is the object to load\n    # example: {'state_dict': model}\n    for key, value in kwargs.items():\n        if key in checkpoint and value is not None:\n            try:\n                msg = value.load_state_dict(checkpoint[key], strict=False)\n                print(\"=> loaded {} from checkpoint '{}' with msg {}\".format(key, ckp_path, msg))\n            except TypeError:\n                try:\n                    msg = value.load_state_dict(checkpoint[key])\n                    print(\"=> loaded {} from checkpoint '{}'\".format(key, ckp_path))\n                except ValueError:\n                    print(\"=> failed to load {} from checkpoint '{}'\".format(key, ckp_path))\n        else:\n            print(\"=> failed to load {} from checkpoint '{}'\".format(key, ckp_path))\n\n    # re load variable important for the run\n    if run_variables is not None:\n        for var_name in run_variables:\n            if var_name in checkpoint:\n                run_variables[var_name] = checkpoint[var_name]\n\n\ndef cosine_scheduler(base_value, final_value, epochs, niter_per_ep, warmup_epochs=0, start_warmup_value=0):\n    warmup_schedule = np.array([])\n    warmup_iters = warmup_epochs * niter_per_ep\n    if warmup_epochs > 0:\n        warmup_schedule = np.linspace(start_warmup_value, base_value, warmup_iters)\n\n    iters = np.arange(epochs * niter_per_ep - warmup_iters)\n    schedule = final_value + 0.5 * (base_value - final_value) * (1 + np.cos(np.pi * iters / len(iters)))\n\n    schedule = np.concatenate((warmup_schedule, schedule))\n    assert len(schedule) == epochs * niter_per_ep\n    return schedule\n\n\ndef bool_flag(s):\n    \"\"\"\n    Parse boolean arguments from the command line.\n    \"\"\"\n    FALSY_STRINGS = {\"off\", \"false\", \"0\"}\n    TRUTHY_STRINGS = {\"on\", \"true\", \"1\"}\n    if s.lower() in FALSY_STRINGS:\n        return False\n    elif s.lower() in TRUTHY_STRINGS:\n        return True\n    else:\n        raise argparse.ArgumentTypeError(\"invalid value for a boolean flag\")\n\n\ndef fix_random_seeds(seed=31):\n    \"\"\"\n    Fix random seeds.\n    \"\"\"\n    torch.manual_seed(seed)\n    torch.cuda.manual_seed_all(seed)\n    np.random.seed(seed)\n\n\nclass SmoothedValue(object):\n    \"\"\"Track a series of values and provide access to smoothed values over a\n    window or the global series average.\n    \"\"\"\n\n    def __init__(self, window_size=20, fmt=None):\n        if fmt is None:\n            fmt = \"{median:.6f} ({global_avg:.6f})\"\n        self.deque = deque(maxlen=window_size)\n        self.total = 0.0\n        self.count = 0\n        self.fmt = fmt\n\n    def update(self, value, n=1):\n        self.deque.append(value)\n        self.count += n\n        self.total += value * n\n\n    def synchronize_between_processes(self):\n        \"\"\"\n        Warning: does not synchronize the deque!\n        \"\"\"\n        if not is_dist_avail_and_initialized():\n            return\n        t = torch.tensor([self.count, self.total], dtype=torch.float64, device='cuda')\n        dist.barrier()\n        dist.all_reduce(t)\n        t = t.tolist()\n        self.count = int(t[0])\n        self.total = t[1]\n\n    @property\n    def median(self):\n        d = torch.tensor(list(self.deque))\n        return d.median().item()\n\n    @property\n    def avg(self):\n        d = torch.tensor(list(self.deque), dtype=torch.float32)\n        return d.mean().item()\n\n    @property\n    def global_avg(self):\n        return self.total / self.count\n\n    @property\n    def max(self):\n        return max(self.deque)\n\n    @property\n    def value(self):\n        return self.deque[-1]\n\n    def __str__(self):\n        return self.fmt.format(\n            median=self.median,\n            avg=self.avg,\n            global_avg=self.global_avg,\n            max=self.max,\n            value=self.value)\n\n\ndef reduce_dict(input_dict, average=True):\n    \"\"\"\n    Args:\n        input_dict (dict): all the values will be reduced\n        average (bool): whether to do average or sum\n    Reduce the values in the dictionary from all processes so that all processes\n    have the averaged results. Returns a dict with the same fields as\n    input_dict, after reduction.\n    \"\"\"\n    world_size = get_world_size()\n    if world_size < 2:\n        return input_dict\n    with torch.no_grad():\n        names = []\n        values = []\n        # sort the keys so that they are consistent across processes\n        for k in sorted(input_dict.keys()):\n            names.append(k)\n            values.append(input_dict[k])\n        values = torch.stack(values, dim=0)\n        dist.all_reduce(values)\n        if average:\n            values /= world_size\n        reduced_dict = {k: v for k, v in zip(names, values)}\n    return reduced_dict\n\n\nclass MetricLogger(object):\n    def __init__(self, delimiter=\"\\t\"):\n        self.meters = defaultdict(SmoothedValue)\n        self.delimiter = delimiter\n\n    def update(self, **kwargs):\n        for k, v in kwargs.items():\n            if isinstance(v, torch.Tensor):\n                v = v.item()\n            assert isinstance(v, (float, int))\n            self.meters[k].update(v)\n\n    def __getattr__(self, attr):\n        if attr in self.meters:\n            return self.meters[attr]\n        if attr in self.__dict__:\n            return self.__dict__[attr]\n        raise AttributeError(\"'{}' object has no attribute '{}'\".format(\n            type(self).__name__, attr))\n\n    def __str__(self):\n        loss_str = []\n        for name, meter in self.meters.items():\n            loss_str.append(\n                \"{}: {}\".format(name, str(meter))\n            )\n        return self.delimiter.join(loss_str)\n\n    def synchronize_between_processes(self):\n        for meter in self.meters.values():\n            meter.synchronize_between_processes()\n\n    def add_meter(self, name, meter):\n        self.meters[name] = meter\n\n    def log_every(self, iterable, print_freq, header=None):\n        i = 0\n        if not header:\n            header = ''\n        start_time = time.time()\n        end = time.time()\n        iter_time = SmoothedValue(fmt='{avg:.6f}')\n        data_time = SmoothedValue(fmt='{avg:.6f}')\n        space_fmt = ':' + str(len(str(len(iterable)))) + 'd'\n        if torch.cuda.is_available():\n            log_msg = self.delimiter.join([\n                header,\n                '[{0' + space_fmt + '}/{1}]',\n                'eta: {eta}',\n                '{meters}',\n                'time: {time}',\n                'data: {data}',\n                'max mem: {memory:.0f}'\n            ])\n        else:\n            log_msg = self.delimiter.join([\n                header,\n                '[{0' + space_fmt + '}/{1}]',\n                'eta: {eta}',\n                '{meters}',\n                'time: {time}',\n                'data: {data}'\n            ])\n        MB = 1024.0 * 1024.0\n        for obj in iterable:\n            data_time.update(time.time() - end)\n            yield obj\n            iter_time.update(time.time() - end)\n            if i % print_freq == 0 or i == len(iterable) - 1:\n                eta_seconds = iter_time.global_avg * (len(iterable) - i)\n                eta_string = str(datetime.timedelta(seconds=int(eta_seconds)))\n                if torch.cuda.is_available():\n                    print(log_msg.format(\n                        i, len(iterable), eta=eta_string,\n                        meters=str(self),\n                        time=str(iter_time), data=str(data_time),\n                        memory=torch.cuda.max_memory_allocated() / MB))\n                else:\n                    print(log_msg.format(\n                        i, len(iterable), eta=eta_string,\n                        meters=str(self),\n                        time=str(iter_time), data=str(data_time)))\n            i += 1\n            end = time.time()\n        total_time = time.time() - start_time\n        total_time_str = str(datetime.timedelta(seconds=int(total_time)))\n        print('{} Total time: {} ({:.6f} s / it)'.format(\n            header, total_time_str, total_time / len(iterable)))\n\n\ndef get_sha():\n    cwd = os.path.dirname(os.path.abspath(__file__))\n\n    def _run(command):\n        return subprocess.check_output(command, cwd=cwd).decode('ascii').strip()\n    sha = 'N/A'\n    diff = \"clean\"\n    branch = 'N/A'\n    try:\n        sha = _run(['git', 'rev-parse', 'HEAD'])\n        subprocess.check_output(['git', 'diff'], cwd=cwd)\n        diff = _run(['git', 'diff-index', 'HEAD'])\n        diff = \"has uncommited changes\" if diff else \"clean\"\n        branch = _run(['git', 'rev-parse', '--abbrev-ref', 'HEAD'])\n    except Exception:\n        pass\n    message = f\"sha: {sha}, status: {diff}, branch: {branch}\"\n    return message\n\n\ndef is_dist_avail_and_initialized():\n    if not dist.is_available():\n        return False\n    if not dist.is_initialized():\n        return False\n    return True\n\n\ndef get_world_size():\n    if not is_dist_avail_and_initialized():\n        return 1\n    return dist.get_world_size()\n\n\ndef get_rank():\n    if not is_dist_avail_and_initialized():\n        return 0\n    return dist.get_rank()\n\n\ndef is_main_process():\n    return get_rank() == 0\n\n\ndef save_on_master(*args, **kwargs):\n    if is_main_process():\n        torch.save(*args, **kwargs)\n\n\ndef setup_for_distributed(is_master):\n    \"\"\"\n    This function disables printing when not in master process\n    \"\"\"\n    import builtins as __builtin__\n    builtin_print = __builtin__.print\n\n    def print(*args, **kwargs):\n        force = kwargs.pop('force', False)\n        if is_master or force:\n            builtin_print(*args, **kwargs)\n\n    __builtin__.print = print\n\n\ndef init_distributed_mode(args):\n    # launched with torch.distributed.launch\n    if 'RANK' in os.environ and 'WORLD_SIZE' in os.environ:\n        args.rank = int(os.environ[\"RANK\"])\n        args.world_size = int(os.environ['WORLD_SIZE'])\n        args.gpu = int(os.environ['LOCAL_RANK'])\n    # launched with submitit on a slurm cluster\n    elif 'SLURM_PROCID' in os.environ:\n        args.rank = int(os.environ['SLURM_PROCID'])\n        args.gpu = args.rank % torch.cuda.device_count()\n    # launched naively with `python main_dino.py`\n    # we manually add MASTER_ADDR and MASTER_PORT to env variables\n    elif torch.cuda.is_available():\n        print('Will run the code on one GPU.')\n        args.rank, args.gpu, args.world_size = 0, 0, 1\n        os.environ['MASTER_ADDR'] = '127.0.0.1'\n        os.environ['MASTER_PORT'] = '29500'\n    else:\n        print('Does not support training without GPU.')\n        sys.exit(1)\n\n    dist.init_process_group(\n        backend=\"nccl\",\n        init_method=args.dist_url,\n        world_size=args.world_size,\n        rank=args.rank,\n    )\n\n    torch.cuda.set_device(args.gpu)\n    print('| distributed init (rank {}): {}'.format(\n        args.rank, args.dist_url), flush=True)\n    dist.barrier()\n    setup_for_distributed(args.rank == 0)\n\n\ndef accuracy(output, target, topk=(1,)):\n    \"\"\"Computes the accuracy over the k top predictions for the specified values of k\"\"\"\n    maxk = max(topk)\n    batch_size = target.size(0)\n    _, pred = output.topk(maxk, 1, True, True)\n    pred = pred.t()\n    correct = pred.eq(target.reshape(1, -1).expand_as(pred))\n    return [correct[:k].reshape(-1).float().sum(0) * 100. / batch_size for k in topk]\n\n\ndef _no_grad_trunc_normal_(tensor, mean, std, a, b):\n    # Cut & paste from PyTorch official master until it's in a few official releases - RW\n    # Method based on https://people.sc.fsu.edu/~jburkardt/presentations/truncated_normal.pdf\n    def norm_cdf(x):\n        # Computes standard normal cumulative distribution function\n        return (1. + math.erf(x / math.sqrt(2.))) / 2.\n\n    if (mean < a - 2 * std) or (mean > b + 2 * std):\n        warnings.warn(\"mean is more than 2 std from [a, b] in nn.init.trunc_normal_. \"\n                      \"The distribution of values may be incorrect.\",\n                      stacklevel=2)\n\n    with torch.no_grad():\n        # Values are generated by using a truncated uniform distribution and\n        # then using the inverse CDF for the normal distribution.\n        # Get upper and lower cdf values\n        l = norm_cdf((a - mean) / std)\n        u = norm_cdf((b - mean) / std)\n\n        # Uniformly fill tensor with values from [l, u], then translate to\n        # [2l-1, 2u-1].\n        tensor.uniform_(2 * l - 1, 2 * u - 1)\n\n        # Use inverse cdf transform for normal distribution to get truncated\n        # standard normal\n        tensor.erfinv_()\n\n        # Transform to proper mean, std\n        tensor.mul_(std * math.sqrt(2.))\n        tensor.add_(mean)\n\n        # Clamp to ensure it's in the proper range\n        tensor.clamp_(min=a, max=b)\n        return tensor\n\n\ndef trunc_normal_(tensor, mean=0., std=1., a=-2., b=2.):\n    # type: (Tensor, float, float, float, float) -> Tensor\n    return _no_grad_trunc_normal_(tensor, mean, std, a, b)\n\n\nclass LARS(torch.optim.Optimizer):\n    \"\"\"\n    Almost copy-paste from https://github.com/facebookresearch/barlowtwins/blob/main/main.py\n    \"\"\"\n    def __init__(self, params, lr=0, weight_decay=0, momentum=0.9, eta=0.001,\n                 weight_decay_filter=None, lars_adaptation_filter=None):\n        defaults = dict(lr=lr, weight_decay=weight_decay, momentum=momentum,\n                        eta=eta, weight_decay_filter=weight_decay_filter,\n                        lars_adaptation_filter=lars_adaptation_filter)\n        super().__init__(params, defaults)\n\n    @torch.no_grad()\n    def step(self):\n        for g in self.param_groups:\n            for p in g['params']:\n                dp = p.grad\n\n                if dp is None:\n                    continue\n\n                if p.ndim != 1:\n                    dp = dp.add(p, alpha=g['weight_decay'])\n\n                if p.ndim != 1:\n                    param_norm = torch.norm(p)\n                    update_norm = torch.norm(dp)\n                    one = torch.ones_like(param_norm)\n                    q = torch.where(param_norm > 0.,\n                                    torch.where(update_norm > 0,\n                                                (g['eta'] * param_norm / update_norm), one), one)\n                    dp = dp.mul(q)\n\n                param_state = self.state[p]\n                if 'mu' not in param_state:\n                    param_state['mu'] = torch.zeros_like(p)\n                mu = param_state['mu']\n                mu.mul_(g['momentum']).add_(dp)\n\n                p.add_(mu, alpha=-g['lr'])\n\n\nclass MultiCropWrapper(nn.Module):\n    \"\"\"\n    Perform forward pass separately on each resolution input.\n    The inputs corresponding to a single resolution are clubbed and single\n    forward is run on the same resolution inputs. Hence we do several\n    forward passes = number of different resolutions used. We then\n    concatenate all the output features and run the head forward on these\n    concatenated features.\n    \"\"\"\n    def __init__(self, backbone, head):\n        super(MultiCropWrapper, self).__init__()\n        # disable layers dedicated to ImageNet labels classification\n        backbone.fc, backbone.head = nn.Identity(), nn.Identity()\n        self.backbone = backbone\n        self.head = head\n\n    def forward(self, x):\n        # convert to list\n        if not isinstance(x, list):\n            x = [x]\n        idx_crops = torch.cumsum(torch.unique_consecutive(\n            torch.tensor([inp.shape[-1] for inp in x]),\n            return_counts=True,\n        )[1], 0)\n        start_idx = 0\n        for end_idx in idx_crops:\n            _out = self.backbone(torch.cat(x[start_idx: end_idx]))\n            if start_idx == 0:\n                output = _out\n            else:\n                output = torch.cat((output, _out))\n            start_idx = end_idx\n        # Run the head forward on the concatenated features.\n        return self.head(output)\n\n\ndef get_params_groups(model):\n    regularized = []\n    not_regularized = []\n    for name, param in model.named_parameters():\n        if not param.requires_grad:\n            continue\n        # we do not regularize biases nor Norm parameters\n        if name.endswith(\".bias\") or len(param.shape) == 1:\n            not_regularized.append(param)\n        else:\n            regularized.append(param)\n    return [{'params': regularized}, {'params': not_regularized, 'weight_decay': 0.}]\n\n\ndef has_batchnorms(model):\n    bn_types = (nn.BatchNorm1d, nn.BatchNorm2d, nn.BatchNorm3d, nn.SyncBatchNorm)\n    for name, module in model.named_modules():\n        if isinstance(module, bn_types):\n            return True\n    return False\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/dino/utils.py b/src/dino/utils.py
--- a/src/dino/utils.py	(revision c6be305e586f39b07663cb9bdb535828fe4047df)
+++ b/src/dino/utils.py	(date 1717747028689)
@@ -17,6 +17,7 @@
 Mostly copy-paste from torchvision references or other public repos like DETR:
 https://github.com/facebookresearch/detr/blob/master/util/misc.py
 """
+import argparse
 import os
 import sys
 import time
@@ -24,6 +25,7 @@
 import random
 import datetime
 import subprocess
+import warnings
 from collections import defaultdict, deque
 
 import numpy as np
Index: src/train_crf.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import io\n\nimport PIL.Image\nimport matplotlib.pyplot as plt\nimport torch\nfrom tensorboardX import SummaryWriter\nfrom torch.nn import Sequential, Linear, LogSoftmax\nfrom torch.utils.data import Dataset\nfrom torchvision.transforms import ToTensor\nfrom utils import *\nfrom tqdm import tqdm\nfrom torch.utils.data import DataLoader\nimport numpy as np\nfrom skimage.segmentation import mark_boundaries\nfrom sklearn.decomposition import PCA\nfrom kornia.color import rgb_to_lab\nfrom datetime import datetime\nimport hydra\nfrom omegaconf import DictConfig, OmegaConf\n\ndef norm(t):\n    return F.normalize(t, dim=1, eps=1e-10)\n\ndef prep(continuous: bool, t: torch.Tensor):\n    if continuous:\n        return norm(t)\n    else:\n        return torch.exp(t)\n\ndef entropy(p):\n    p = torch.clamp_min(p, .0000001)\n    return -(p * torch.log(p)).sum(dim=1)\n\n\n@hydra.main(config_name=\"config.yml\")\ndef my_app(cfg: DictConfig) -> None:\n    print(OmegaConf.to_yaml(cfg))\n    pytorch_data_dir = cfg.pytorch_data_dir\n    log_dir = join(cfg.output_root, \"logs\")\n    continuous = cfg.continuous\n    dim = cfg.dim\n    dataset_name = cfg.dataset_name\n    n_images = 7\n\n    np.random.seed(0)\n    torch.random.manual_seed(0)\n\n    small_imsize = imsize // 2\n    transform_with_resize = T.Compose([T.Resize((small_imsize, small_imsize)), T.ToTensor(), normalize])\n    label_transform_with_resize = T.Compose([T.Resize((small_imsize, small_imsize)), ToTargetTensor()])\n\n    dataset = ContrastiveSegDataset(\n        pytorch_data_dir, dataset_name, \"train+val\", cfg.num_neighbors,\n        transform_with_resize, label_transform_with_resize, None, None, cfg)\n\n    prefix = \"crf/{}_{}\".format(cfg.dataset_name, cfg.experiment_name)\n    writer = SummaryWriter(\n        join(log_dir, '{}_date_{}'.format(prefix, datetime.now().strftime(\"%m:%d:%Y:%H:%M\"))))\n\n    class CodeSpaceTable(torch.nn.Module):\n        def __init__(self, continuous, n_images, dim, h, w):\n            super(CodeSpaceTable, self).__init__()\n            self.continuous = continuous\n            self.code_space = torch.nn.Parameter(torch.randn(n_images, dim, h, w) * .1)\n\n        def forward(self, x):\n            if self.continuous:\n                return self.code_space\n            else:\n                return torch.nn.functional.log_softmax(self.code_space, 1)\n\n    def add_plot(writer, name, step):\n        buf = io.BytesIO()\n        plt.savefig(buf, format='jpeg')\n        buf.seek(0)\n        image = PIL.Image.open(buf)\n        image = ToTensor()(image)\n        writer.add_image(name, image, step)\n        plt.clf()\n        plt.close()\n\n    loader = DataLoader(dataset, n_images, shuffle=False, num_workers=0)\n\n    load_iter = iter(loader)\n    for i in range(1):\n        next(load_iter)\n    pack = next(load_iter)\n    pack = {k: v.cuda(non_blocking=True) for k, v in pack.items()}\n    ind = pack[\"ind\"]\n    img = pack[\"img\"]\n\n    net = CodeSpaceTable(continuous, n_images, dim, img.shape[2], img.shape[3]).cuda()\n    optim = torch.optim.Adam(list(net.parameters()), lr=1e-2)\n\n    loss_func = ContrastiveCRFLoss(cfg.crf_samples, cfg.alpha, cfg.beta, cfg.gamma, cfg.w1, cfg.w2, cfg.shift)\n\n    def to_normed_lab(img):\n        img_t = rgb_to_lab(img)\n        img_t /= torch.tensor([100, 128 * 2, 128 * 2]).unsqueeze(0).unsqueeze(-1).unsqueeze(-1).cuda()\n        return img_t\n\n    for i in tqdm(range(cfg.epochs)):\n\n        code = net.forward(img)\n        if cfg.color_space == \"rgb\":\n            img_t = img\n        elif cfg.color_space == \"lab\":\n            img_t = to_normed_lab(img)\n        else:\n            raise ValueError(\"unknown color space: {}\".format(cfg.color_space))\n\n        if continuous:\n            ent_reg_term = 0\n        else:\n            ent_global = entropy(torch.exp(code).mean(dim=0, keepdim=True)).mean()\n            ent_local = entropy(torch.exp(code)).mean()\n            ent_reg_term = - cfg.global_ent_weight * ent_global \\\n                           - cfg.local_ent_weight * ent_local\n\n            if i % 100 == 0:\n                writer.add_scalar('ent/ent1', ent_global, i)\n                writer.add_scalar('ent/ent2', ent_local, i)\n\n        crf_loss = loss_func(img_t, prep(continuous, code))\n        loss = crf_loss.mean() + ent_reg_term\n\n        loss.backward()\n        optim.step()\n        optim.zero_grad()\n\n        if i % 10 == 0:\n            writer.add_scalar(\"crf_loss\", crf_loss.mean(), i)\n            writer.add_scalar(\"loss\", loss, i)\n\n        if i % 500 == 0:\n            fig, ax = plt.subplots(2, n_images, figsize=(n_images * 3, 2 * 3))\n            with torch.no_grad():\n                for idx, img_idx in enumerate(ind[:n_images]):\n                    plot_img = unnorm(img)[idx].permute(1, 2, 0)\n                    plot_img = (plot_img - plot_img.min()) / (plot_img.max() - plot_img.min())\n                    ax[0, idx].imshow(plot_img.cpu())\n                    if not continuous:\n                        ax[1, idx].imshow(mark_boundaries(plot_img.cpu(), code.argmax(1)[idx].cpu().numpy()))\n                    else:\n                        X_code = code[idx].permute(1, 2, 0).reshape(-1, dim).cpu()\n                        projected_code = PCA(n_components=3).fit_transform(X_code) \\\n                            .reshape([code.shape[2], code.shape[3], 3])\n                        projected_code = (projected_code + 1) / 2\n                        projected_code = np.clip(projected_code, 0, 1)\n                        ax[1, idx].imshow(projected_code)\n\n                remove_axes(ax)\n                plt.tight_layout()\n                add_plot(writer, \"plot\", i)\n\n\nif __name__ == \"__main__\":\n    my_app()\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/train_crf.py b/src/train_crf.py
--- a/src/train_crf.py	(revision c6be305e586f39b07663cb9bdb535828fe4047df)
+++ b/src/train_crf.py	(date 1717746395246)
@@ -1,9 +1,11 @@
 import io
+from shlex import join
 
 import PIL.Image
 import matplotlib.pyplot as plt
 import torch
 from tensorboardX import SummaryWriter
+from torch import T
 from torch.nn import Sequential, Linear, LogSoftmax
 from torch.utils.data import Dataset
 from torchvision.transforms import ToTensor
@@ -18,7 +20,14 @@
 import hydra
 from omegaconf import DictConfig, OmegaConf
 
+from src import utils
+from src.data import ContrastiveSegDataset
+from src.modules import ContrastiveCRFLoss
+from src.utils import normalize, ToTargetTensor, unnorm, remove_axes
+
+
 def norm(t):
+    from torchgen.context import F
     return F.normalize(t, dim=1, eps=1e-10)
 
 def prep(continuous: bool, t: torch.Tensor):
@@ -45,7 +54,7 @@
     np.random.seed(0)
     torch.random.manual_seed(0)
 
-    small_imsize = imsize // 2
+    small_imsize = utils.imsize // 2
     transform_with_resize = T.Compose([T.Resize((small_imsize, small_imsize)), T.ToTensor(), normalize])
     label_transform_with_resize = T.Compose([T.Resize((small_imsize, small_imsize)), ToTargetTensor()])
 
Index: src/instance_segmentation_evaluation.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import sys\nimport os\n\nparentdir = os.path.dirname(\"../STEGO\")\nsys.path.append(parentdir)\n\nfrom multiprocessing import Pool\nfrom data import ContrastiveSegDataset\nfrom eval_segmentation import batched_crf\nfrom modules import *\nimport hydra\nimport torch.multiprocessing\nfrom PIL import Image\nfrom src.crf import dense_crf\nfrom omegaconf import DictConfig, OmegaConf\nfrom torch.utils.data import DataLoader, Dataset\nimport json_to_binary_mask as Json2BinMask\nfrom train_segmentation import LitUnsupervisedSegmenter\nfrom tqdm import tqdm\nimport random\nimport semantic_to_binary_mask as Seg2BinMask\n\n\ntorch.multiprocessing.set_sharing_strategy('file_system')\n\n\nclass UnlabeledImageFolder(Dataset):\n    def __init__(self, root, transform):\n        super(UnlabeledImageFolder, self).__init__()\n        self.root = join(root)\n        self.transform = transform\n        self.images = os.listdir(self.root)\n\n    def __getitem__(self, index):\n        image = Image.open(join(self.root, self.images[index])).convert('RGB')\n        seed = np.random.randint(2147483647)\n        random.seed(seed)\n        torch.manual_seed(seed)\n        image = self.transform(image)\n\n        return image, self.images[index]\n\n    def __len__(self):\n        return len(self.images)\n\n\n@hydra.main(config_path=\"configs\", config_name=\"eval_config.yml\")\ndef my_app(cfg: DictConfig) -> None:\n    pytorch_data_dir = cfg.pytorch_data_dir\n    result_dir = \"../results/predictions/{}\".format(cfg.experiment_name)\n    os.makedirs(join(result_dir, \"img\"), exist_ok=True)\n    os.makedirs(join(result_dir, \"label\"), exist_ok=True)\n    os.makedirs(join(result_dir, \"cluster\"), exist_ok=True)\n    os.makedirs(join(result_dir, \"picie\"), exist_ok=True)\n\n    for model_path in cfg.model_paths:\n        model = LitUnsupervisedSegmenter.load_from_checkpoint(model_path)\n        print(OmegaConf.to_yaml(model.cfg))\n\n    loader_crop = \"center\"\n    test_dataset = ContrastiveSegDataset(\n        pytorch_data_dir=pytorch_data_dir,\n        dataset_name=cfg.experiment_name,\n        crop_type=None,\n        image_set=\"val\",\n        transform=get_transform(cfg.res, False, loader_crop),\n        target_transform=get_transform(cfg.res, True, loader_crop),\n        cfg=model.cfg,\n    )\n\n    loader = DataLoader(test_dataset, cfg.batch_size,\n                        shuffle=False, num_workers=cfg.num_workers,\n                        pin_memory=True, collate_fn=flexible_collate)\n\n    model.eval().cuda()\n    if cfg.use_ddp:\n        par_model = torch.nn.DataParallel(model.net)\n    else:\n        par_model = model.net\n\n    IoU_dict = {}\n    for className in cfg.InstanceClasses:\n        IoU_dict[className] = [0, 0]  # [IoUSum, IoUInstances]\n\n    with Pool(cfg.num_workers + 5) as pool:\n        for i, batch in enumerate(tqdm(loader)):\n            with torch.no_grad():\n                img = batch[\"img\"].cuda()\n                label = batch[\"label\"].cuda()\n                polygons = batch[\"polygons\"]\n\n                feats, code1 = par_model(img)\n                feats, code2 = par_model(img.flip(dims=[3]))\n                code = (code1 + code2.flip(dims=[3])) / 2\n\n                code = F.interpolate(code, img.shape[-2:], mode='bilinear', align_corners=False)\n\n                linear_probs = torch.log_softmax(model.linear_probe(code), dim=1).cpu()\n                cluster_probs = model.cluster_probe(code, 2, log_probs=True).cpu()\n\n                linear_crf = batched_crf(pool, img, linear_probs).argmax(1).cuda()\n                cluster_crf = batched_crf(pool, img, cluster_probs).argmax(1).cuda()\n\n                model.test_cluster_metrics.update(cluster_crf, label)\n\n                tb_metrics = {\n                    **model.test_linear_metrics.compute(),\n                    **model.test_cluster_metrics.compute(),\n                }\n\n                plotted = model.label_cmap[model.test_cluster_metrics.map_clusters(cluster_crf.cpu())].astype(np.uint8)\n\n                Semantic2BinMasks = Seg2BinMask.getMasks(plotted[0], cfg.InstanceClasses)\n                InstanceMasks = Json2BinMask.getBinaryMasks(polygons, cfg.InstanceClasses)\n\n                for className in cfg.InstanceClasses:\n                    semanticMask = Semantic2BinMasks.get(className)\n                    instances = InstanceMasks[className]\n                    for ins in instances:\n                        IoU = Json2BinMask.iou(ins, semanticMask)\n                        IoU_dict[className][0] += IoU\n                        IoU_dict[className][1] += 1\n    f = open(\"../results/predictions/IoU.txt\", \"a\")\n    for className in cfg.InstanceClasses:\n        f.write(className + \"// IoU_sum: \" + str(IoU_dict[className][0]) + \"   \" + \"IoU_instance_count: \" + str(\n            IoU_dict[className][1]) + \"\\n\")\n    f.close()\n\n\ndef get_trans(res, is_label, crop_type):\n    if crop_type == \"center\":\n        cropper = T.CenterCrop(res)\n    elif crop_type == \"random\":\n        cropper = T.RandomCrop(res)\n    elif crop_type is None:\n        cropper = T.Lambda(lambda x: x)\n        res = (res, res)\n    else:\n        raise ValueError(\"Unknown Cropper {}\".format(crop_type))\n    if is_label:\n        return T.Compose([T.Resize(res, Image.NEAREST),\n                          cropper])\n    else:\n        return T.Compose([T.Resize(res, Image.NEAREST),\n                          cropper])\n\n\nif __name__ == \"__main__\":\n    prep_args()\n    my_app()\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/instance_segmentation_evaluation.py b/src/instance_segmentation_evaluation.py
--- a/src/instance_segmentation_evaluation.py	(revision c6be305e586f39b07663cb9bdb535828fe4047df)
+++ b/src/instance_segmentation_evaluation.py	(date 1717584581535)
@@ -1,6 +1,12 @@
 import sys
 import os
 
+import numpy as np
+from torch import T
+from torch.distributed.pipeline.sync.dependency import join
+
+from src.utils import get_transform, flexible_collate, prep_args
+
 parentdir = os.path.dirname("../STEGO")
 sys.path.append(parentdir)
 
Index: src/plot_pr_curves.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import io\nfrom datetime import datetime\n\nimport PIL.Image\nimport hydra\nimport pytorch_lightning as pl\nimport seaborn as sns\nfrom omegaconf import DictConfig, OmegaConf\nfrom pytorch_lightning import Trainer\nfrom pytorch_lightning.loggers import TensorBoardLogger\nfrom pytorch_lightning.utilities.seed import seed_everything\nfrom sklearn.metrics import auc, precision_recall_curve, average_precision_score\nfrom torch.utils.tensorboard.summary import hparams\nfrom torchvision.transforms import ToTensor\nfrom data import *\nfrom modules import *\nfrom train_segmentation import get_class_labels\n\n\n\n@torch.jit.script\ndef super_perm(size: int, device: torch.device):\n    perm = torch.randperm(size, device=device, dtype=torch.long)\n    perm[perm == torch.arange(size, device=device)] += 1\n    return perm % size\n\n\ndef prep_fd_coord(fd):\n    fd -= fd.mean([3, 4], keepdim=True)\n    fd /= fd.std([3, 4], keepdim=True)\n    return fd.reshape(-1)\n\n\ndef prep_fd(fd):\n    fd -= fd.min()\n    fd /= fd.max()\n    return fd.reshape(-1)\n\n\ndef prep_fd_2(fd):\n    fd -= fd.mean([3, 4], keepdim=True)\n    fd -= fd.min()\n    fd /= fd.max()\n    return fd\n\n\ndef plot_auc_raw(name, fpr, tpr):\n    fpr, tpr = fpr.detach().cpu().squeeze(), tpr.detach().cpu().squeeze()\n    roc_auc = auc(fpr, tpr)\n    plt.plot(fpr, tpr, label=name + ' AUC = %0.2f' % roc_auc)\n\n\nclass CRFModule(nn.Module):\n\n    def __init__(self):\n        super().__init__()\n        self.w1 = torch.nn.Parameter(torch.tensor(10.), requires_grad=True)\n        self.w2 = torch.nn.Parameter(torch.tensor(3.), requires_grad=True)\n        self.shift = torch.nn.Parameter(torch.tensor(-.3), requires_grad=True)\n        self.alpha = torch.nn.Parameter(torch.tensor(.5), requires_grad=True)\n        self.beta = torch.nn.Parameter(torch.tensor(.15), requires_grad=True)\n        self.gamma = torch.nn.Parameter(torch.tensor(.05), requires_grad=True)\n\n    def forward(self, coord_diff, img_diff):\n        return torch.abs(self.w1) * torch.exp(- coord_diff / (2 * torch.exp(self.alpha))\n                                              - img_diff / (2 * torch.exp(self.beta))) + \\\n               torch.abs(self.w2) * torch.exp(- coord_diff / (2 * torch.exp(self.gamma))) - self.shift\n\n\nclass LitRecalibrator(pl.LightningModule):\n    def __init__(self, n_classes, cfg):\n        super().__init__()\n        self.cfg = cfg\n        self.n_classes = n_classes\n\n        if not cfg.continuous:\n            dim = n_classes\n        else:\n            dim = cfg.dim\n\n        data_dir = join(cfg.output_root, \"data\")\n        self.moco = FeaturePyramidNet(cfg.granularity, load_model(\"mocov2\", data_dir).cuda(), dim, cfg.continuous)\n        # self.dino = DinoFeaturizer(dim, cfg)\n        # self.dino = LitUnsupervisedSegmenter.load_from_checkpoint(\"../models/vit_base_cocostuff27.ckpt\").net\n        # self.crf = CRFModule()\n        self.cm_metrics = UnsupervisedMetrics(\n            \"confusion_matrix/\", n_classes, 0, False)\n        self.automatic_optimization = False\n\n        if self.cfg.dataset_name.startswith(\"cityscapes\"):\n            self.label_cmap = create_cityscapes_colormap()\n        else:\n            self.label_cmap = create_pascal_label_colormap()\n\n    def get_crf_fd(self, img, coords1, coords2):\n        with torch.no_grad():\n            n = img.shape[0]\n            [h1, w1, h2, w2] = [self.cfg.feature_samples] * 4\n            img_samples_1 = sample(img, coords1).permute(0, 2, 3, 1).reshape(n, -1, 1, 3)\n            img_samples_2 = sample(img, coords2).permute(0, 2, 3, 1).reshape(n, 1, -1, 3)\n            coord_diff = (coords1.reshape(n, -1, 1, 2) - coords2.reshape(n, 1, -1, 2)) \\\n                .square().sum(-1).reshape(n, h1, w1, h2, w2)\n\n            img_diff = (img_samples_1 - img_samples_2).square().sum(-1).reshape(n, h1, w1, h2, w2)\n\n            return self.crf(coord_diff, img_diff)\n\n    def get_net_fd(self, feats1, feats2, label1, label2, coords1, coords2):\n        with torch.no_grad():\n            feat_samples1 = sample(feats1, coords1)\n            feat_samples2 = sample(feats2, coords2)\n\n            label_samples1 = sample(F.one_hot(label1 + 1, self.n_classes + 1)\n                                    .to(torch.float).permute(0, 3, 1, 2), coords1)\n            label_samples2 = sample(F.one_hot(label2 + 1, self.n_classes + 1)\n                                    .to(torch.float).permute(0, 3, 1, 2), coords2)\n\n            fd = tensor_correlation(norm(feat_samples1), norm(feat_samples2))\n            ld = tensor_correlation(label_samples1, label_samples2)\n\n        return ld, fd, label_samples1.argmax(1), label_samples2.argmax(1)\n\n    def training_step(self, batch, batch_idx):\n        return None\n\n    def validation_step(self, batch, batch_idx):\n        with torch.no_grad():\n            img = batch[\"img\"]\n            label = batch[\"label\"]\n\n            dino_feats, dino_code = self.dino(img)\n            moco_feats, moco_code = self.moco(img)\n\n            coord_shape = [img.shape[0], self.cfg.feature_samples, self.cfg.feature_samples, 2]\n            coords1 = torch.rand(coord_shape, device=img.device) * 2 - 1\n            coords2 = torch.rand(coord_shape, device=img.device) * 2 - 1\n\n            crf_fd = self.get_crf_fd(img, coords1, coords2)\n\n            ld, stego_fd, l1, l2 = self.get_net_fd(dino_code, dino_code, label, label, coords1, coords2)\n            ld, dino_fd, l1, l2 = self.get_net_fd(dino_feats, dino_feats, label, label, coords1, coords2)\n            ld, moco_fd, l1, l2 = self.get_net_fd(moco_feats, moco_feats, label, label, coords1, coords2)\n\n            return dict(\n                dino_fd=dino_fd,\n                stego_fd=stego_fd,\n                moco_fd=moco_fd,\n                crf_fd=crf_fd,\n                ld=ld\n            )\n\n    def validation_epoch_end(self, outputs) -> None:\n        # self.cm_metrics.compute()\n\n        all_outputs = {}\n        for k in outputs[0].keys():\n            t = torch.cat([o[k] for o in outputs], dim=0)\n            all_outputs[k] = t\n\n        def plot_pr(preds, targets, name):\n            preds = preds.cpu().reshape(-1)\n            preds -= preds.min()\n            preds /= preds.max()\n            targets = targets.to(torch.int64).cpu().reshape(-1)\n            precisions, recalls, _ = precision_recall_curve(targets, preds)\n            average_precision = average_precision_score(targets, preds)\n            plt.plot(recalls, precisions, label=\"AP={}% {}\".format(int(average_precision * 100), name))\n\n        def plot_cm():\n            histogram = self.cm_metrics.histogram\n            fig = plt.figure(figsize=(10, 10))\n            ax = fig.gca()\n            hist = histogram.detach().cpu().to(torch.float32)\n            hist /= torch.clamp_min(hist.sum(dim=0, keepdim=True), 1)\n            sns.heatmap(hist.t(), annot=False, fmt='g', ax=ax, cmap=\"Blues\", cbar=False)\n            ax.set_title('KNN Labels', fontsize=28)\n            ax.set_ylabel('Image labels', fontsize=28)\n            names = get_class_labels(self.cfg.dataset_name)\n            if self.cfg.extra_clusters:\n                names = names + [\"Extra\"]\n            ax.set_xticks(np.arange(0, len(names)) + .5)\n            ax.set_yticks(np.arange(0, len(names)) + .5)\n            ax.xaxis.tick_top()\n            ax.xaxis.set_ticklabels(names, fontsize=18)\n            ax.yaxis.set_ticklabels(names, fontsize=18)\n            colors = [self.label_cmap[i] / 255.0 for i in range(len(names))]\n            [t.set_color(colors[i]) for i, t in enumerate(ax.xaxis.get_ticklabels())]\n            [t.set_color(colors[i]) for i, t in enumerate(ax.yaxis.get_ticklabels())]\n            plt.xticks(rotation=90)\n            plt.yticks(rotation=0)\n            ax.vlines(np.arange(0, len(names) + 1), color=[.5, .5, .5], *ax.get_xlim())\n            ax.hlines(np.arange(0, len(names) + 1), color=[.5, .5, .5], *ax.get_ylim())\n            plt.tight_layout()\n\n        if self.trainer.is_global_zero:\n            # plt.style.use('dark_background')\n            print(\"Plotting\")\n            plt.figure(figsize=(5, 4), dpi=100)\n            plot_cm()\n            plt.tight_layout()\n            plt.show()\n            plt.clf()\n\n            print(\"Plotting\")\n            # plt.style.use('dark_background')\n            plt.figure(figsize=(5, 4), dpi=100)\n            ld = all_outputs[\"ld\"]\n            plot_pr(prep_fd(all_outputs[\"stego_fd\"]), ld, \"STEGO (Ours)\")\n            plot_pr(prep_fd(all_outputs[\"dino_fd\"]), ld, \"DINO\")\n            plot_pr(prep_fd(all_outputs[\"moco_fd\"]), ld, \"MoCoV2\")\n            plot_pr(prep_fd(all_outputs[\"crf_fd\"]), ld, \"CRF\")\n            plt.xlim([0, 1])\n            plt.ylim([0, 1])\n            plt.legend(fontsize=12)\n            plt.ylabel('Precision', fontsize=16)\n            plt.xlabel('Recall', fontsize=16)\n            plt.tight_layout()\n            plt.show()\n\n        return None\n\n    def configure_optimizers(self):\n        return None\n\n\n@hydra.main(config_path=\"configs\", config_name=\"train_config.yml\")\ndef my_app(cfg: DictConfig) -> None:\n    print(OmegaConf.to_yaml(cfg))\n    pytorch_data_dir = cfg.pytorch_data_dir\n    data_dir = join(cfg.output_root, \"data\")\n    log_dir = join(cfg.output_root, \"logs\")\n    checkpoint_dir = join(cfg.output_root, \"checkpoints\")\n    os.makedirs(data_dir, exist_ok=True)\n    os.makedirs(log_dir, exist_ok=True)\n\n    seed_everything(seed=0, workers=True)\n\n    train_dataset = ContrastiveSegDataset(\n        pytorch_data_dir=pytorch_data_dir,\n        dataset_name=cfg.dataset_name,\n        crop_type=cfg.crop_type,\n        image_set=\"train\",\n        transform=get_transform(cfg.res, False, cfg.loader_crop_type),\n        target_transform=get_transform(cfg.res, True, cfg.loader_crop_type),\n        cfg=cfg,\n        aug_geometric_transform=None,\n        aug_photometric_transform=None,\n        num_neighbors=cfg.num_neighbors,\n        mask=True,\n        pos_images=True,\n        pos_labels=True\n    )\n\n    val_loader_crop = \"center\"\n    val_dataset = ContrastiveSegDataset(\n        pytorch_data_dir=pytorch_data_dir,\n        dataset_name=cfg.dataset_name,\n        crop_type=None,\n        image_set=\"val\",\n        transform=get_transform(320, False, val_loader_crop),\n        target_transform=get_transform(320, True, val_loader_crop),\n        mask=True,\n        pos_images=True,\n        pos_labels=True,\n        cfg=cfg,\n    )\n\n    train_loader = DataLoader(train_dataset, cfg.batch_size, shuffle=True, num_workers=cfg.num_workers)\n    val_loader = DataLoader(val_dataset, cfg.batch_size, shuffle=True, num_workers=cfg.num_workers)\n\n    model = LitRecalibrator(train_dataset.n_classes, cfg)\n\n    prefix = \"{}_{}\".format(cfg.dataset_name, cfg.experiment_name)\n    name = '{}_date_{}'.format(prefix, datetime.now().strftime('%b%d_%H-%M-%S'))\n    tb_logger = TensorBoardLogger(\n        join(log_dir, cfg.log_dir, name),\n        default_hp_metric=False\n    )\n    steps = 1\n    trainer = Trainer(\n        log_every_n_steps=10,\n        val_check_interval=steps,\n        gpus=1,\n        max_steps=steps,\n        limit_val_batches=100,\n        accelerator=\"ddp\",\n        num_sanity_val_steps=0,\n        logger=tb_logger,\n    )\n    trainer.fit(model, train_loader, val_loader)\n    os.makedirs(join(checkpoint_dir, cfg.log_dir), exist_ok=True)\n\n\nif __name__ == \"__main__\":\n    prep_args()\n    my_app()\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/plot_pr_curves.py b/src/plot_pr_curves.py
--- a/src/plot_pr_curves.py	(revision c6be305e586f39b07663cb9bdb535828fe4047df)
+++ b/src/plot_pr_curves.py	(date 1717584581532)
@@ -5,6 +5,7 @@
 import hydra
 import pytorch_lightning as pl
 import seaborn as sns
+from matplotlib import pyplot as plt
 from omegaconf import DictConfig, OmegaConf
 from pytorch_lightning import Trainer
 from pytorch_lightning.loggers import TensorBoardLogger
@@ -14,6 +15,7 @@
 from torchvision.transforms import ToTensor
 from data import *
 from modules import *
+from src.utils import load_model, UnsupervisedMetrics, get_transform, prep_args
 from train_segmentation import get_class_labels
 
 
Index: src/modules.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import torch\n\nfrom utils import *\nimport torch.nn.functional as F\nimport dino.vision_transformer as vits\n\n\nclass LambdaLayer(nn.Module):\n    def __init__(self, lambd):\n        super(LambdaLayer, self).__init__()\n        self.lambd = lambd\n\n    def forward(self, x):\n        return self.lambd(x)\n\n\nclass DinoFeaturizer(nn.Module):\n\n    def __init__(self, dim, cfg):\n        super().__init__()\n        self.cfg = cfg\n        self.dim = dim\n        patch_size = self.cfg.dino_patch_size\n        self.patch_size = patch_size\n        self.feat_type = self.cfg.dino_feat_type\n        arch = self.cfg.model_type\n        self.model = vits.__dict__[arch](\n            patch_size=patch_size,\n            num_classes=0)\n        for p in self.model.parameters():\n            p.requires_grad = False\n        self.model.eval().cuda()\n        self.dropout = torch.nn.Dropout2d(p=.1)\n\n        if arch == \"vit_small\" and patch_size == 16:\n            url = \"dino_deitsmall16_pretrain/dino_deitsmall16_pretrain.pth\"\n        elif arch == \"vit_small\" and patch_size == 8:\n            url = \"dino_deitsmall8_300ep_pretrain/dino_deitsmall8_300ep_pretrain.pth\"\n        elif arch == \"vit_base\" and patch_size == 16:\n            url = \"dino_vitbase16_pretrain/dino_vitbase16_pretrain.pth\"\n        elif arch == \"vit_base\" and patch_size == 8:\n            url = \"dino_vitbase8_pretrain/dino_vitbase8_pretrain.pth\"\n        else:\n            raise ValueError(\"Unknown arch and patch size\")\n\n        if cfg.pretrained_weights is not None:\n            state_dict = torch.load(cfg.pretrained_weights, map_location=\"cpu\")\n            state_dict = state_dict[\"teacher\"]\n            # remove `module.` prefix\n            state_dict = {k.replace(\"module.\", \"\"): v for k, v in state_dict.items()}\n            # remove `backbone.` prefix induced by multicrop wrapper\n            state_dict = {k.replace(\"backbone.\", \"\"): v for k, v in state_dict.items()}\n\n            # state_dict = {k.replace(\"projection_head\", \"mlp\"): v for k, v in state_dict.items()}\n            # state_dict = {k.replace(\"prototypes\", \"last_layer\"): v for k, v in state_dict.items()}\n\n            msg = self.model.load_state_dict(state_dict, strict=False)\n            print('Pretrained weights found at {} and loaded with msg: {}'.format(cfg.pretrained_weights, msg))\n        else:\n            print(\"Since no pretrained weights have been provided, we load the reference pretrained DINO weights.\")\n            state_dict = torch.hub.load_state_dict_from_url(url=\"https://dl.fbaipublicfiles.com/dino/\" + url)\n            self.model.load_state_dict(state_dict, strict=True)\n\n        if arch == \"vit_small\":\n            self.n_feats = 384\n        else:\n            self.n_feats = 768\n        self.cluster1 = self.make_clusterer(self.n_feats)\n        self.proj_type = cfg.projection_type\n        if self.proj_type == \"nonlinear\":\n            self.cluster2 = self.make_nonlinear_clusterer(self.n_feats)\n\n    def make_clusterer(self, in_channels):\n        return torch.nn.Sequential(\n            torch.nn.Conv2d(in_channels, self.dim, (1, 1)))  # ,\n\n    def make_nonlinear_clusterer(self, in_channels):\n        return torch.nn.Sequential(\n            torch.nn.Conv2d(in_channels, in_channels, (1, 1)),\n            torch.nn.ReLU(),\n            torch.nn.Conv2d(in_channels, self.dim, (1, 1)))\n\n    def forward(self, img, n=1, return_class_feat=False):\n        self.model.eval()\n        with torch.no_grad():\n            assert (img.shape[2] % self.patch_size == 0)\n            assert (img.shape[3] % self.patch_size == 0)\n\n            # get selected layer activations\n            feat, attn, qkv = self.model.get_intermediate_feat(img, n=n)\n            feat, attn, qkv = feat[0], attn[0], qkv[0]\n\n            feat_h = img.shape[2] // self.patch_size\n            feat_w = img.shape[3] // self.patch_size\n\n            if self.feat_type == \"feat\":\n                image_feat = feat[:, 1:, :].reshape(feat.shape[0], feat_h, feat_w, -1).permute(0, 3, 1, 2)\n            elif self.feat_type == \"KK\":\n                image_k = qkv[1, :, :, 1:, :].reshape(feat.shape[0], 6, feat_h, feat_w, -1)\n                B, H, I, J, D = image_k.shape\n                image_feat = image_k.permute(0, 1, 4, 2, 3).reshape(B, H * D, I, J)\n            else:\n                raise ValueError(\"Unknown feat type:{}\".format(self.feat_type))\n\n            if return_class_feat:\n                return feat[:, :1, :].reshape(feat.shape[0], 1, 1, -1).permute(0, 3, 1, 2)\n\n        if self.proj_type is not None:\n            code = self.cluster1(self.dropout(image_feat))\n            if self.proj_type == \"nonlinear\":\n                code += self.cluster2(self.dropout(image_feat))\n        else:\n            code = image_feat\n\n        if self.cfg.dropout:\n            return self.dropout(image_feat), code\n        else:\n            return image_feat, code\n\n\nclass ResizeAndClassify(nn.Module):\n\n    def __init__(self, dim: int, size: int, n_classes: int):\n        super(ResizeAndClassify, self).__init__()\n        self.size = size\n        self.predictor = torch.nn.Sequential(\n            torch.nn.Conv2d(dim, n_classes, (1, 1)),\n            torch.nn.LogSoftmax(1))\n\n    def forward(self, x):\n        return F.interpolate(self.predictor.forward(x), self.size, mode=\"bilinear\", align_corners=False)\n\n\nclass ClusterLookup(nn.Module):\n\n    def __init__(self, dim: int, n_classes: int):\n        super(ClusterLookup, self).__init__()\n        self.n_classes = n_classes\n        self.dim = dim\n        self.clusters = torch.nn.Parameter(torch.randn(n_classes, dim))\n\n    def reset_parameters(self):\n        with torch.no_grad():\n            self.clusters.copy_(torch.randn(self.n_classes, self.dim))\n\n    def forward(self, x, alpha, log_probs=False):\n        normed_clusters = F.normalize(self.clusters, dim=1)\n        normed_features = F.normalize(x, dim=1)\n        inner_products = torch.einsum(\"bchw,nc->bnhw\", normed_features, normed_clusters)\n\n        if alpha is None:\n            cluster_probs = F.one_hot(torch.argmax(inner_products, dim=1), self.clusters.shape[0]) \\\n                .permute(0, 3, 1, 2).to(torch.float32)\n        else:\n            cluster_probs = nn.functional.softmax(inner_products * alpha, dim=1)\n\n        cluster_loss = -(cluster_probs * inner_products).sum(1).mean()\n        if log_probs:\n            return nn.functional.log_softmax(inner_products * alpha, dim=1)\n        else:\n            return cluster_loss, cluster_probs\n\n\nclass FeaturePyramidNet(nn.Module):\n\n    @staticmethod\n    def _helper(x):\n        # TODO remove this hard coded 56\n        return F.interpolate(x, 56, mode=\"bilinear\", align_corners=False).unsqueeze(-1)\n\n    def make_clusterer(self, in_channels):\n        return torch.nn.Sequential(\n            torch.nn.Conv2d(in_channels, self.dim, (1, 1)),\n            LambdaLayer(FeaturePyramidNet._helper))\n\n    def make_nonlinear_clusterer(self, in_channels):\n        return torch.nn.Sequential(\n            torch.nn.Conv2d(in_channels, in_channels, (1, 1)),\n            torch.nn.ReLU(),\n            torch.nn.Conv2d(in_channels, in_channels, (1, 1)),\n            torch.nn.ReLU(),\n            torch.nn.Conv2d(in_channels, self.dim, (1, 1)),\n            LambdaLayer(FeaturePyramidNet._helper))\n\n    def __init__(self, granularity, cut_model, dim, continuous):\n        super(FeaturePyramidNet, self).__init__()\n        self.layer_nums = [5, 6, 7]\n        self.spatial_resolutions = [7, 14, 28, 56]\n        self.feat_channels = [2048, 1024, 512, 3]\n        self.extra_channels = [128, 64, 32, 32]\n        self.granularity = granularity\n        self.encoder = NetWithActivations(cut_model, self.layer_nums)\n        self.dim = dim\n        self.continuous = continuous\n        self.n_feats = self.dim\n\n        self.up = nn.Upsample(scale_factor=2, mode='bilinear', align_corners=False)\n\n        assert granularity in {1, 2, 3, 4}\n        self.cluster1 = self.make_clusterer(self.feat_channels[0])\n        self.cluster1_nl = self.make_nonlinear_clusterer(self.feat_channels[0])\n\n        if granularity >= 2:\n            # self.conv1 = DoubleConv(self.feat_channels[0], self.extra_channels[0])\n            # self.conv2 = DoubleConv(self.extra_channels[0] + self.feat_channels[1], self.extra_channels[1])\n            self.conv2 = DoubleConv(self.feat_channels[0] + self.feat_channels[1], self.extra_channels[1])\n            self.cluster2 = self.make_clusterer(self.extra_channels[1])\n        if granularity >= 3:\n            self.conv3 = DoubleConv(self.extra_channels[1] + self.feat_channels[2], self.extra_channels[2])\n            self.cluster3 = self.make_clusterer(self.extra_channels[2])\n        if granularity >= 4:\n            self.conv4 = DoubleConv(self.extra_channels[2] + self.feat_channels[3], self.extra_channels[3])\n            self.cluster4 = self.make_clusterer(self.extra_channels[3])\n\n    def c(self, x, y):\n        return torch.cat([x, y], dim=1)\n\n    def forward(self, x):\n        with torch.no_grad():\n            feats = self.encoder(x)\n        low_res_feats = feats[self.layer_nums[-1]]\n\n        all_clusters = []\n\n        # all_clusters.append(self.cluster1(low_res_feats) + self.cluster1_nl(low_res_feats))\n        all_clusters.append(self.cluster1(low_res_feats))\n\n        if self.granularity >= 2:\n            # f1 = self.conv1(low_res_feats)\n            # f1_up = self.up(f1)\n            f1_up = self.up(low_res_feats)\n            f2 = self.conv2(self.c(f1_up, feats[self.layer_nums[-2]]))\n            all_clusters.append(self.cluster2(f2))\n        if self.granularity >= 3:\n            f2_up = self.up(f2)\n            f3 = self.conv3(self.c(f2_up, feats[self.layer_nums[-3]]))\n            all_clusters.append(self.cluster3(f3))\n        if self.granularity >= 4:\n            f3_up = self.up(f3)\n            final_size = self.spatial_resolutions[-1]\n            f4 = self.conv4(self.c(f3_up, F.interpolate(\n                x, (final_size, final_size), mode=\"bilinear\", align_corners=False)))\n            all_clusters.append(self.cluster4(f4))\n\n        avg_code = torch.cat(all_clusters, 4).mean(4)\n\n        if self.continuous:\n            clusters = avg_code\n        else:\n            clusters = torch.log_softmax(avg_code, 1)\n\n        return low_res_feats, clusters\n\n\nclass DoubleConv(nn.Module):\n    \"\"\"(convolution => [BN] => ReLU) * 2\"\"\"\n\n    def __init__(self, in_channels, out_channels, mid_channels=None):\n        super().__init__()\n        if not mid_channels:\n            mid_channels = out_channels\n        self.double_conv = nn.Sequential(\n            nn.Conv2d(in_channels, mid_channels, kernel_size=3, padding=1),\n            nn.BatchNorm2d(mid_channels),\n            nn.ReLU(),\n            nn.Conv2d(mid_channels, out_channels, kernel_size=3, padding=1),\n            nn.BatchNorm2d(out_channels),\n            nn.ReLU()\n        )\n\n    def forward(self, x):\n        return self.double_conv(x)\n\n\ndef norm(t):\n    return F.normalize(t, dim=1, eps=1e-10)\n\n\ndef average_norm(t):\n    return t / t.square().sum(1, keepdim=True).sqrt().mean()\n\n\ndef tensor_correlation(a, b):\n    return torch.einsum(\"nchw,ncij->nhwij\", a, b)\n\n\ndef sample(t: torch.Tensor, coords: torch.Tensor):\n    return F.grid_sample(t, coords.permute(0, 2, 1, 3), padding_mode='border', align_corners=True)\n\n\n@torch.jit.script\ndef super_perm(size: int, device: torch.device):\n    perm = torch.randperm(size, device=device, dtype=torch.long)\n    perm[perm == torch.arange(size, device=device)] += 1\n    return perm % size\n\n\ndef sample_nonzero_locations(t, target_size):\n    nonzeros = torch.nonzero(t)\n    coords = torch.zeros(target_size, dtype=nonzeros.dtype, device=nonzeros.device)\n    n = target_size[1] * target_size[2]\n    for i in range(t.shape[0]):\n        selected_nonzeros = nonzeros[nonzeros[:, 0] == i]\n        if selected_nonzeros.shape[0] == 0:\n            selected_coords = torch.randint(t.shape[1], size=(n, 2), device=nonzeros.device)\n        else:\n            selected_coords = selected_nonzeros[torch.randint(len(selected_nonzeros), size=(n,)), 1:]\n        coords[i, :, :, :] = selected_coords.reshape(target_size[1], target_size[2], 2)\n    coords = coords.to(torch.float32) / t.shape[1]\n    coords = coords * 2 - 1\n    return torch.flip(coords, dims=[-1])\n\n\nclass ContrastiveCorrelationLoss(nn.Module):\n\n    def __init__(self, cfg, ):\n        super(ContrastiveCorrelationLoss, self).__init__()\n        self.cfg = cfg\n\n    def standard_scale(self, t):\n        t1 = t - t.mean()\n        t2 = t1 / t1.std()\n        return t2\n\n    def helper(self, f1, f2, c1, c2, shift):\n        with torch.no_grad():\n            # Comes straight from backbone which is currently frozen. this saves mem.\n            fd = tensor_correlation(norm(f1), norm(f2))\n\n            if self.cfg.pointwise:\n                old_mean = fd.mean()\n                fd -= fd.mean([3, 4], keepdim=True)\n                fd = fd - fd.mean() + old_mean\n\n        cd = tensor_correlation(norm(c1), norm(c2))\n\n        if self.cfg.zero_clamp:\n            min_val = 0.0\n        else:\n            min_val = -9999.0\n\n        if self.cfg.stabalize:\n            loss = - cd.clamp(min_val, .8) * (fd - shift)\n        else:\n            loss = - cd.clamp(min_val) * (fd - shift)\n\n        return loss, cd\n\n    def forward(self,\n                orig_feats: torch.Tensor, orig_feats_pos: torch.Tensor,\n                orig_salience: torch.Tensor, orig_salience_pos: torch.Tensor,\n                orig_code: torch.Tensor, orig_code_pos: torch.Tensor,\n                ):\n\n        coord_shape = [orig_feats.shape[0], self.cfg.feature_samples, self.cfg.feature_samples, 2]\n\n        if self.cfg.use_salience:\n            coords1_nonzero = sample_nonzero_locations(orig_salience, coord_shape)\n            coords2_nonzero = sample_nonzero_locations(orig_salience_pos, coord_shape)\n            coords1_reg = torch.rand(coord_shape, device=orig_feats.device) * 2 - 1\n            coords2_reg = torch.rand(coord_shape, device=orig_feats.device) * 2 - 1\n            mask = (torch.rand(coord_shape[:-1], device=orig_feats.device) > .1).unsqueeze(-1).to(torch.float32)\n            coords1 = coords1_nonzero * mask + coords1_reg * (1 - mask)\n            coords2 = coords2_nonzero * mask + coords2_reg * (1 - mask)\n        else:\n            coords1 = torch.rand(coord_shape, device=orig_feats.device) * 2 - 1\n            coords2 = torch.rand(coord_shape, device=orig_feats.device) * 2 - 1\n\n        feats = sample(orig_feats, coords1)\n        code = sample(orig_code, coords1)\n\n        feats_pos = sample(orig_feats_pos, coords2)\n        code_pos = sample(orig_code_pos, coords2)\n\n        pos_intra_loss, pos_intra_cd = self.helper(\n            feats, feats, code, code, self.cfg.pos_intra_shift)\n        pos_inter_loss, pos_inter_cd = self.helper(\n            feats, feats_pos, code, code_pos, self.cfg.pos_inter_shift)\n\n        neg_losses = []\n        neg_cds = []\n        for i in range(self.cfg.neg_samples):\n            perm_neg = super_perm(orig_feats.shape[0], orig_feats.device)\n            feats_neg = sample(orig_feats[perm_neg], coords2)\n            code_neg = sample(orig_code[perm_neg], coords2)\n            neg_inter_loss, neg_inter_cd = self.helper(\n                feats, feats_neg, code, code_neg, self.cfg.neg_inter_shift)\n            neg_losses.append(neg_inter_loss)\n            neg_cds.append(neg_inter_cd)\n        neg_inter_loss = torch.cat(neg_losses, axis=0)\n        neg_inter_cd = torch.cat(neg_cds, axis=0)\n\n        return (pos_intra_loss.mean(),\n                pos_intra_cd,\n                pos_inter_loss.mean(),\n                pos_inter_cd,\n                neg_inter_loss,\n                neg_inter_cd)\n\n\nclass Decoder(nn.Module):\n    def __init__(self, code_channels, feat_channels):\n        super().__init__()\n        self.linear = torch.nn.Conv2d(code_channels, feat_channels, (1, 1))\n        self.nonlinear = torch.nn.Sequential(\n            torch.nn.Conv2d(code_channels, code_channels, (1, 1)),\n            torch.nn.ReLU(),\n            torch.nn.Conv2d(code_channels, code_channels, (1, 1)),\n            torch.nn.ReLU(),\n            torch.nn.Conv2d(code_channels, feat_channels, (1, 1)))\n\n    def forward(self, x):\n        return self.linear(x) + self.nonlinear(x)\n\n\nclass NetWithActivations(torch.nn.Module):\n    def __init__(self, model, layer_nums):\n        super(NetWithActivations, self).__init__()\n        self.layers = nn.ModuleList(model.children())\n        self.layer_nums = []\n        for l in layer_nums:\n            if l < 0:\n                self.layer_nums.append(len(self.layers) + l)\n            else:\n                self.layer_nums.append(l)\n        self.layer_nums = set(sorted(self.layer_nums))\n\n    def forward(self, x):\n        activations = {}\n        for ln, l in enumerate(self.layers):\n            x = l(x)\n            if ln in self.layer_nums:\n                activations[ln] = x\n        return activations\n\n\nclass ContrastiveCRFLoss(nn.Module):\n\n    def __init__(self, n_samples, alpha, beta, gamma, w1, w2, shift):\n        super(ContrastiveCRFLoss, self).__init__()\n        self.alpha = alpha\n        self.beta = beta\n        self.gamma = gamma\n        self.w1 = w1\n        self.w2 = w2\n        self.n_samples = n_samples\n        self.shift = shift\n\n    def forward(self, guidance, clusters):\n        device = clusters.device\n        assert (guidance.shape[0] == clusters.shape[0])\n        assert (guidance.shape[2:] == clusters.shape[2:])\n        h = guidance.shape[2]\n        w = guidance.shape[3]\n\n        coords = torch.cat([\n            torch.randint(0, h, size=[1, self.n_samples], device=device),\n            torch.randint(0, w, size=[1, self.n_samples], device=device)], 0)\n\n        selected_guidance = guidance[:, :, coords[0, :], coords[1, :]]\n        coord_diff = (coords.unsqueeze(-1) - coords.unsqueeze(1)).square().sum(0).unsqueeze(0)\n        guidance_diff = (selected_guidance.unsqueeze(-1) - selected_guidance.unsqueeze(2)).square().sum(1)\n\n        sim_kernel = self.w1 * torch.exp(- coord_diff / (2 * self.alpha) - guidance_diff / (2 * self.beta)) + \\\n                     self.w2 * torch.exp(- coord_diff / (2 * self.gamma)) - self.shift\n\n        selected_clusters = clusters[:, :, coords[0, :], coords[1, :]]\n        cluster_sims = torch.einsum(\"nka,nkb->nab\", selected_clusters, selected_clusters)\n        return -(cluster_sims * sim_kernel)\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/modules.py b/src/modules.py
--- a/src/modules.py	(revision c6be305e586f39b07663cb9bdb535828fe4047df)
+++ b/src/modules.py	(date 1717584581540)
@@ -1,4 +1,5 @@
 import torch
+from torch import nn
 
 from utils import *
 import torch.nn.functional as F
Index: src/demo_segmentation.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from modules import *\nimport hydra\nimport torch.multiprocessing\nfrom PIL import Image\nfrom crf import dense_crf\nfrom omegaconf import DictConfig, OmegaConf\nfrom torch.utils.data import DataLoader, Dataset\nfrom train_segmentation import LitUnsupervisedSegmenter\nfrom tqdm import tqdm\nimport random\ntorch.multiprocessing.set_sharing_strategy('file_system')\n\n\nclass UnlabeledImageFolder(Dataset):\n    def __init__(self, root, transform):\n        super(UnlabeledImageFolder, self).__init__()\n        self.root = join(root)\n        self.transform = transform\n        self.images = os.listdir(self.root)\n\n    def __getitem__(self, index):\n        image = Image.open(join(self.root, self.images[index])).convert('RGB')\n        seed = np.random.randint(2147483647)\n        random.seed(seed)\n        torch.manual_seed(seed)\n        image = self.transform(image)\n\n        return image, self.images[index]\n\n    def __len__(self):\n        return len(self.images)\n\n\n@hydra.main(config_path=\"configs\", config_name=\"demo_config.yml\")\ndef my_app(cfg: DictConfig) -> None:\n    result_dir = \"../results/predictions/{}\".format(cfg.experiment_name)\n    os.makedirs(result_dir, exist_ok=True)\n    os.makedirs(join(result_dir, \"cluster\"), exist_ok=True)\n    os.makedirs(join(result_dir, \"linear\"), exist_ok=True)\n\n    model = LitUnsupervisedSegmenter.load_from_checkpoint(cfg.model_path)\n    print(OmegaConf.to_yaml(model.cfg))\n\n    dataset = UnlabeledImageFolder(\n        root=cfg.image_dir,\n        transform=get_transform(cfg.res, False, \"center\"),\n    )\n\n    loader = DataLoader(dataset, cfg.batch_size * 2,\n                        shuffle=False, num_workers=cfg.num_workers,\n                        pin_memory=True, collate_fn=flexible_collate)\n\n    model.eval().cuda()\n    if cfg.use_ddp:\n        par_model = torch.nn.DataParallel(model.net)\n    else:\n        par_model = model.net\n\n    for i, (img, name) in enumerate(tqdm(loader)):\n        with torch.no_grad():\n            \n            img = img.cuda()\n            feats, code1 = par_model(img)\n            feats, code2 = par_model(img.flip(dims=[3]))\n            code = (code1 + code2.flip(dims=[3])) / 2\n\n            code = F.interpolate(code, img.shape[-2:], mode='bilinear', align_corners=False)\n\n            linear_probs = torch.log_softmax(model.linear_probe(code), dim=1).cpu()\n            cluster_probs = model.cluster_probe(code, 2, log_probs=True).cpu()\n\n            for j in range(img.shape[0]):\n                single_img = img[j].cpu()\n                linear_crf = dense_crf(single_img, linear_probs[j]).argmax(0)\n                cluster_crf = dense_crf(single_img, cluster_probs[j]).argmax(0)\n\n                new_name = \".\".join(name[j].split(\".\")[:-1]) + \".png\"\n                Image.fromarray(linear_crf.astype(np.uint8)).save(join(result_dir, \"linear\", new_name))\n                Image.fromarray(cluster_crf.astype(np.uint8)).save(join(result_dir, \"cluster\", new_name))\n\n\nif __name__ == \"__main__\":\n    prep_args()\n    my_app()\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/demo_segmentation.py b/src/demo_segmentation.py
--- a/src/demo_segmentation.py	(revision c6be305e586f39b07663cb9bdb535828fe4047df)
+++ b/src/demo_segmentation.py	(date 1717584581548)
@@ -1,3 +1,8 @@
+import os
+
+import numpy as np
+from torch.distributed.pipeline.sync.dependency import join
+
 from modules import *
 import hydra
 import torch.multiprocessing
@@ -5,6 +10,8 @@
 from crf import dense_crf
 from omegaconf import DictConfig, OmegaConf
 from torch.utils.data import DataLoader, Dataset
+
+from src.utils import get_transform, flexible_collate, prep_args
 from train_segmentation import LitUnsupervisedSegmenter
 from tqdm import tqdm
 import random
Index: src/crf.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#\n# Authors: Wouter Van Gansbeke & Simon Vandenhende\n# Licensed under the CC BY-NC 4.0 license (https://creativecommons.org/licenses/by-nc/4.0/)\n\nimport numpy as np\nimport pydensecrf.densecrf as dcrf\nimport pydensecrf.utils as utils\nimport torch\nimport torch.nn.functional as F\nimport torchvision.transforms.functional as VF\nfrom utils import unnorm\n\nMAX_ITER = 10\nPOS_W = 3\nPOS_XY_STD = 1\nBi_W = 4\nBi_XY_STD = 67\nBi_RGB_STD = 3\nBGR_MEAN = np.array([104.008, 116.669, 122.675])\n\n\ndef dense_crf(image_tensor: torch.FloatTensor, output_logits: torch.FloatTensor):\n    image = np.array(VF.to_pil_image(unnorm(image_tensor)))[:, :, ::-1]\n    H, W = image.shape[:2]\n    image = np.ascontiguousarray(image)\n\n    output_logits = F.interpolate(output_logits.unsqueeze(0), size=(H, W), mode=\"bilinear\",\n                                  align_corners=False).squeeze()\n    output_probs = F.softmax(output_logits, dim=0).cpu().numpy()\n\n    c = output_probs.shape[0]\n    h = output_probs.shape[1]\n    w = output_probs.shape[2]\n\n    U = utils.unary_from_softmax(output_probs)\n    U = np.ascontiguousarray(U)\n\n    d = dcrf.DenseCRF2D(w, h, c)\n    d.setUnaryEnergy(U)\n    d.addPairwiseGaussian(sxy=POS_XY_STD, compat=POS_W)\n    d.addPairwiseBilateral(sxy=Bi_XY_STD, srgb=Bi_RGB_STD, rgbim=image, compat=Bi_W)\n\n    Q = d.inference(MAX_ITER)\n    Q = np.array(Q).reshape((c, h, w))\n    return Q\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/crf.py b/src/crf.py
--- a/src/crf.py	(revision c6be305e586f39b07663cb9bdb535828fe4047df)
+++ b/src/crf.py	(date 1717584581546)
@@ -8,7 +8,9 @@
 import torch
 import torch.nn.functional as F
 import torchvision.transforms.functional as VF
-from utils import unnorm
+
+from src.utils import unnorm
+#from utils import unnorm
 
 MAX_ITER = 10
 POS_W = 3
Index: src/Instance_segmentation_depth.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import sys\nimport os\n\n\n\nfrom multiprocessing import Pool\nfrom depth_dataset import ContrastiveDepthDataset\nfrom eval_segmentation import batched_crf\nfrom modules import *\nimport hydra\nimport torch.multiprocessing\nfrom PIL import Image\nfrom src.crf import  dense_crf\nfrom omegaconf import DictConfig, OmegaConf\nfrom torch.utils.data import DataLoader, Dataset\nimport json_to_binary_mask as Json2BinMask\nfrom train_segmentation import LitUnsupervisedSegmenter\nfrom tqdm import tqdm\nimport random\nimport semantic_to_binary_mask as Seg2BinMask\n\n\ntorch.multiprocessing.set_sharing_strategy('file_system')\n\n\nclass UnlabeledImageFolder(Dataset):\n    def __init__(self, root, transform):\n        super(UnlabeledImageFolder, self).__init__()\n        self.root = join(root)\n        self.transform = transform\n        self.images = os.listdir(self.root)\n\n    def __getitem__(self, index):\n        image = Image.open(join(self.root, self.images[index])).convert('RGB')\n        seed = np.random.randint(2147483647)\n        random.seed(seed)\n        torch.manual_seed(seed)\n        image = self.transform(image)\n\n        return image, self.images[index]\n\n    def __len__(self):\n        return len(self.images)\n\n\n@hydra.main(config_path=\"configs\", config_name=\"eval_config.yml\")\ndef my_app(cfg: DictConfig) -> None:\n    pytorch_data_dir = cfg.pytorch_data_dir\n    result_dir = \"../results/predictions/{}\".format(cfg.experiment_name)\n    os.makedirs(join(result_dir, \"img\"), exist_ok=True)\n    os.makedirs(join(result_dir, \"label\"), exist_ok=True)\n    os.makedirs(join(result_dir, \"cluster\"), exist_ok=True)\n    os.makedirs(join(result_dir, \"picie\"), exist_ok=True)\n\n    for model_path in cfg.model_paths:\n        model = LitUnsupervisedSegmenter.load_from_checkpoint(model_path)\n        print(OmegaConf.to_yaml(model.cfg))\n\n    loader_crop = \"center\"\n    test_dataset = ContrastiveDepthDataset(\n        pytorch_data_dir=pytorch_data_dir,\n        dataset_name=cfg.experiment_name,\n        crop_type=None,\n        image_set=\"val\",\n        transform=get_transform(cfg.res, False, loader_crop),\n        target_transform=get_transform(cfg.res, True, loader_crop),\n        cfg=model.cfg,\n    )\n\n    loader = DataLoader(test_dataset, cfg.batch_size,\n                        shuffle=False, num_workers=cfg.num_workers,\n                        pin_memory=True, collate_fn=flexible_collate)\n\n    model.eval().cuda()\n    if cfg.use_ddp:\n        par_model = torch.nn.DataParallel(model.net)\n    else:\n        par_model = model.net\n\n    IoU_dict = {}\n    for className in cfg.InstanceClasses:\n        IoU_dict[className] = [0, 0]  # [IoUSum, IoUInstances]\n\n    with Pool(cfg.num_workers + 5) as pool:\n        for i, batch in enumerate(tqdm(loader)):\n            with torch.no_grad():\n                img = batch[\"img\"].cuda()\n                label = batch[\"label\"].cuda()\n                polygons = batch[\"polygons\"]\n                depth = batch[\"depth\"]\n\n                feats, code1 = par_model(img)\n                feats, code2 = par_model(img.flip(dims=[3]))\n                code = (code1 + code2.flip(dims=[3])) / 2\n\n                code = F.interpolate(code, img.shape[-2:], mode='bilinear', align_corners=False)\n\n                linear_probs = torch.log_softmax(model.linear_probe(code), dim=1).cpu()\n                cluster_probs = model.cluster_probe(code, 2, log_probs=True).cpu()\n\n                linear_crf = batched_crf(pool, img, linear_probs).argmax(1).cuda()\n                cluster_crf = batched_crf(pool, img, cluster_probs).argmax(1).cuda()\n\n                model.test_cluster_metrics.update(cluster_crf, label)\n\n                tb_metrics = {\n                    **model.test_linear_metrics.compute(),\n                    **model.test_cluster_metrics.compute(),\n                }\n\n                plotted = model.label_cmap[model.test_cluster_metrics.map_clusters(cluster_crf.cpu())].astype(np.uint8)\n\n                Semantic2BinMasks = Seg2BinMask.getMasks(plotted[0], cfg.InstanceClasses)\n                InstanceMasks = Json2BinMask.getBinaryMasks(polygons, cfg.InstanceClasses)\n\n                for className in cfg.InstanceClasses:\n                    semanticMask = Semantic2BinMasks.get(className)\n                    instances = InstanceMasks[className]\n                    for ins in instances:\n                        IoU = Json2BinMask.iou(ins, semanticMask)\n                        IoU_dict[className][0] += IoU\n                        IoU_dict[className][1] += 1\n    f = open(\"../results/predictions/IoU.txt\", \"a\")\n    for className in cfg.InstanceClasses:\n        f.write(className + \"// IoU_sum: \" + str(IoU_dict[className][0]) + \"   \" + \"IoU_instance_count: \" + str(\n            IoU_dict[className][1]) + \"\\n\")\n    f.close()\n\n\ndef get_trans(res, is_label, crop_type):\n    if crop_type == \"center\":\n        cropper = T.CenterCrop(res)\n    elif crop_type == \"random\":\n        cropper = T.RandomCrop(res)\n    elif crop_type is None:\n        cropper = T.Lambda(lambda x: x)\n        res = (res, res)\n    else:\n        raise ValueError(\"Unknown Cropper {}\".format(crop_type))\n    if is_label:\n        return T.Compose([T.Resize(res, Image.NEAREST),\n                          cropper])\n    else:\n        return T.Compose([T.Resize(res, Image.NEAREST),\n                          cropper])\n\n\nif __name__ == \"__main__\":\n    prep_args()\n    my_app()\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/Instance_segmentation_depth.py b/src/Instance_segmentation_depth.py
--- a/src/Instance_segmentation_depth.py	(revision c6be305e586f39b07663cb9bdb535828fe4047df)
+++ b/src/Instance_segmentation_depth.py	(date 1717584581525)
@@ -4,6 +4,11 @@
 
 
 from multiprocessing import Pool
+
+import numpy as np
+from torch import T
+from torch.distributed.pipeline.sync.dependency import join
+
 from depth_dataset import ContrastiveDepthDataset
 from eval_segmentation import batched_crf
 from modules import *
@@ -14,6 +19,7 @@
 from omegaconf import DictConfig, OmegaConf
 from torch.utils.data import DataLoader, Dataset
 import json_to_binary_mask as Json2BinMask
+from src.utils import get_transform, flexible_collate, prep_args
 from train_segmentation import LitUnsupervisedSegmenter
 from tqdm import tqdm
 import random
Index: src/utils.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import collections\nimport os\nfrom os.path import join\nimport io\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport torch.multiprocessing\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport wget\nfrom PIL import Image\nfrom scipy.optimize import linear_sum_assignment\nfrom torch._six import string_classes\nfrom torch.utils.data import DataLoader\nfrom torch.utils.data._utils.collate import np_str_obj_array_pattern, default_collate_err_msg_format\nfrom torchmetrics import Metric\nfrom torchvision import models\nfrom torchvision import transforms as T\nfrom torch.utils.tensorboard.summary import hparams\n\n\ndef prep_for_plot(img, rescale=True, resize=None):\n    if resize is not None:\n        img = F.interpolate(img.unsqueeze(0), resize, mode=\"bilinear\")\n    else:\n        img = img.unsqueeze(0)\n\n    plot_img = unnorm(img).squeeze(0).cpu().permute(1, 2, 0)\n    if rescale:\n        plot_img = (plot_img - plot_img.min()) / (plot_img.max() - plot_img.min())\n    return plot_img\n\n\ndef add_plot(writer, name, step):\n    buf = io.BytesIO()\n    plt.savefig(buf, format='jpeg', dpi=100)\n    buf.seek(0)\n    image = Image.open(buf)\n    image = T.ToTensor()(image)\n    writer.add_image(name, image, step)\n    plt.clf()\n    plt.close()\n\n\n@torch.jit.script\ndef shuffle(x):\n    return x[torch.randperm(x.shape[0])]\n\n\ndef add_hparams_fixed(writer, hparam_dict, metric_dict, global_step):\n    exp, ssi, sei = hparams(hparam_dict, metric_dict)\n    writer.file_writer.add_summary(exp)\n    writer.file_writer.add_summary(ssi)\n    writer.file_writer.add_summary(sei)\n    for k, v in metric_dict.items():\n        writer.add_scalar(k, v, global_step)\n\n\n@torch.jit.script\ndef resize(classes: torch.Tensor, size: int):\n    return F.interpolate(classes, (size, size), mode=\"bilinear\", align_corners=False)\n\n\ndef one_hot_feats(labels, n_classes):\n    return F.one_hot(labels, n_classes).permute(0, 3, 1, 2).to(torch.float32)\n\n\ndef load_model(model_type, data_dir):\n    if model_type == \"robust_resnet50\":\n        model = models.resnet50(pretrained=False)\n        model_file = join(data_dir, 'imagenet_l2_3_0.pt')\n        if not os.path.exists(model_file):\n            wget.download(\"http://6.869.csail.mit.edu/fa19/psets19/pset6/imagenet_l2_3_0.pt\",\n                          model_file)\n        model_weights = torch.load(model_file)\n        model_weights_modified = {name.split('model.')[1]: value for name, value in model_weights['model'].items() if\n                                  'model' in name}\n        model.load_state_dict(model_weights_modified)\n        model = nn.Sequential(*list(model.children())[:-1])\n    elif model_type == \"densecl\":\n        model = models.resnet50(pretrained=False)\n        model_file = join(data_dir, 'densecl_r50_coco_1600ep.pth')\n        if not os.path.exists(model_file):\n            wget.download(\"https://cloudstor.aarnet.edu.au/plus/s/3GapXiWuVAzdKwJ/download\",\n                          model_file)\n        model_weights = torch.load(model_file)\n        # model_weights_modified = {name.split('model.')[1]: value for name, value in model_weights['model'].items() if\n        #                          'model' in name}\n        model.load_state_dict(model_weights['state_dict'], strict=False)\n        model = nn.Sequential(*list(model.children())[:-1])\n    elif model_type == \"resnet50\":\n        model = models.resnet50(pretrained=True)\n        model = nn.Sequential(*list(model.children())[:-1])\n    elif model_type == \"mocov2\":\n        model = models.resnet50(pretrained=False)\n        model_file = join(data_dir, 'moco_v2_800ep_pretrain.pth.tar')\n        if not os.path.exists(model_file):\n            wget.download(\"https://dl.fbaipublicfiles.com/moco/moco_checkpoints/\"\n                          \"moco_v2_800ep/moco_v2_800ep_pretrain.pth.tar\", model_file)\n        checkpoint = torch.load(model_file)\n        # rename moco pre-trained keys\n        state_dict = checkpoint['state_dict']\n        for k in list(state_dict.keys()):\n            # retain only encoder_q up to before the embedding layer\n            if k.startswith('module.encoder_q') and not k.startswith('module.encoder_q.fc'):\n                # remove prefix\n                state_dict[k[len(\"module.encoder_q.\"):]] = state_dict[k]\n            # delete renamed or unused k\n            del state_dict[k]\n        msg = model.load_state_dict(state_dict, strict=False)\n        assert set(msg.missing_keys) == {\"fc.weight\", \"fc.bias\"}\n        model = nn.Sequential(*list(model.children())[:-1])\n    elif model_type == \"densenet121\":\n        model = models.densenet121(pretrained=True)\n        model = nn.Sequential(*list(model.children())[:-1] + [nn.AdaptiveAvgPool2d((1, 1))])\n    elif model_type == \"vgg11\":\n        model = models.vgg11(pretrained=True)\n        model = nn.Sequential(*list(model.children())[:-1] + [nn.AdaptiveAvgPool2d((1, 1))])\n    else:\n        raise ValueError(\"No model: {} found\".format(model_type))\n\n    model.eval()\n    model.cuda()\n    return model\n\n\nclass UnNormalize(object):\n    def __init__(self, mean, std):\n        self.mean = mean\n        self.std = std\n\n    def __call__(self, image):\n        image2 = torch.clone(image)\n        for t, m, s in zip(image2, self.mean, self.std):\n            t.mul_(s).add_(m)\n        return image2\n\n\nnormalize = T.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])\nunnorm = UnNormalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])\n\n\nclass ToTargetTensor(object):\n    def __call__(self, target):\n        return torch.as_tensor(np.array(target), dtype=torch.int64).unsqueeze(0)\n\n\ndef prep_args():\n    import sys\n\n    old_args = sys.argv\n    new_args = [old_args.pop(0)]\n    while len(old_args) > 0:\n        arg = old_args.pop(0)\n        if len(arg.split(\"=\")) == 2:\n            new_args.append(arg)\n        elif arg.startswith(\"--\"):\n            new_args.append(arg[2:] + \"=\" + old_args.pop(0))\n        else:\n            raise ValueError(\"Unexpected arg style {}\".format(arg))\n    sys.argv = new_args\n\n\ndef get_transform(res, is_label, crop_type):\n    if crop_type == \"center\":\n        cropper = T.CenterCrop(res)\n    elif crop_type == \"random\":\n        cropper = T.RandomCrop(res)\n    elif crop_type is None:\n        cropper = T.Lambda(lambda x: x)\n        res = (res, res)\n    else:\n        raise ValueError(\"Unknown Cropper {}\".format(crop_type))\n    if is_label:\n        return T.Compose([T.Resize(res, Image.NEAREST),\n                          cropper,\n                          ToTargetTensor()])\n    else:\n        return T.Compose([T.Resize(res, Image.NEAREST),\n                          cropper,\n                          T.ToTensor(),\n                          normalize])\n\n\ndef _remove_axes(ax):\n    ax.xaxis.set_major_formatter(plt.NullFormatter())\n    ax.yaxis.set_major_formatter(plt.NullFormatter())\n    ax.set_xticks([])\n    ax.set_yticks([])\n\n\ndef remove_axes(axes):\n    if len(axes.shape) == 2:\n        for ax1 in axes:\n            for ax in ax1:\n                _remove_axes(ax)\n    else:\n        for ax in axes:\n            _remove_axes(ax)\n\n\nclass UnsupervisedMetrics(Metric):\n    def __init__(self, prefix: str, n_classes: int, extra_clusters: int, compute_hungarian: bool,\n                 dist_sync_on_step=True):\n        # call `self.add_state`for every internal state that is needed for the metrics computations\n        # dist_reduce_fx indicates the function that should be used to reduce\n        # state from multiple processes\n        super().__init__(dist_sync_on_step=dist_sync_on_step)\n\n        self.n_classes = n_classes\n        self.extra_clusters = extra_clusters\n        self.compute_hungarian = compute_hungarian\n        self.prefix = prefix\n        self.add_state(\"stats\",\n                       default=torch.zeros(n_classes + self.extra_clusters, n_classes, dtype=torch.int64),\n                       dist_reduce_fx=\"sum\")\n\n    def update(self, preds: torch.Tensor, target: torch.Tensor):\n        with torch.no_grad():\n            actual = target.reshape(-1)\n            preds = preds.reshape(-1)\n            mask = (actual >= 0) & (actual < self.n_classes) & (preds >= 0) & (preds < self.n_classes)\n            actual = actual[mask]\n            preds = preds[mask]\n            self.stats += torch.bincount(\n                (self.n_classes + self.extra_clusters) * actual + preds,\n                minlength=self.n_classes * (self.n_classes + self.extra_clusters)) \\\n                .reshape(self.n_classes, self.n_classes + self.extra_clusters).t().to(self.stats.device)\n\n    def map_clusters(self, clusters):\n        if self.extra_clusters == 0:\n            return torch.tensor(self.assignments[1])[clusters]\n        else:\n            missing = sorted(list(set(range(self.n_classes + self.extra_clusters)) - set(self.assignments[0])))\n            cluster_to_class = self.assignments[1]\n            for missing_entry in missing:\n                if missing_entry == cluster_to_class.shape[0]:\n                    cluster_to_class = np.append(cluster_to_class, -1)\n                else:\n                    cluster_to_class = np.insert(cluster_to_class, missing_entry + 1, -1)\n            cluster_to_class = torch.tensor(cluster_to_class)\n            return cluster_to_class[clusters]\n\n    def compute(self):\n        if self.compute_hungarian:\n            self.assignments = linear_sum_assignment(self.stats.detach().cpu(), maximize=True)\n            if self.extra_clusters == 0:\n                self.histogram = self.stats[np.argsort(self.assignments[1]), :]\n            if self.extra_clusters > 0:\n                self.assignments_t = linear_sum_assignment(self.stats.detach().cpu().t(), maximize=True)\n                histogram = self.stats[self.assignments_t[1], :]\n                missing = list(set(range(self.n_classes + self.extra_clusters)) - set(self.assignments[0]))\n                new_row = self.stats[missing, :].sum(0, keepdim=True)\n                histogram = torch.cat([histogram, new_row], axis=0)\n                new_col = torch.zeros(self.n_classes + 1, 1, device=histogram.device)\n                self.histogram = torch.cat([histogram, new_col], axis=1)\n        else:\n            self.assignments = (torch.arange(self.n_classes).unsqueeze(1),\n                                torch.arange(self.n_classes).unsqueeze(1))\n            self.histogram = self.stats\n\n        tp = torch.diag(self.histogram)\n        fp = torch.sum(self.histogram, dim=0) - tp\n        fn = torch.sum(self.histogram, dim=1) - tp\n\n        iou = tp / (tp + fp + fn)\n        prc = tp / (tp + fn)\n        opc = torch.sum(tp) / torch.sum(self.histogram)\n\n        metric_dict = {self.prefix + \"mIoU\": iou[~torch.isnan(iou)].mean().item(),\n                       self.prefix + \"Accuracy\": opc.item()}\n        return {k: 100 * v for k, v in metric_dict.items()}\n\n\ndef flexible_collate(batch):\n    r\"\"\"Puts each data field into a tensor with outer dimension batch size\"\"\"\n\n    elem = batch[0]\n    elem_type = type(elem)\n    if isinstance(elem, torch.Tensor):\n        out = None\n        if torch.utils.data.get_worker_info() is not None:\n            # If we're in a background process, concatenate directly into a\n            # shared memory tensor to avoid an extra copy\n            numel = sum([x.numel() for x in batch])\n            storage = elem.storage()._new_shared(numel)\n            out = elem.new(storage)\n        try:\n            return torch.stack(batch, 0, out=out)\n        except RuntimeError:\n            return batch\n    elif elem_type.__module__ == 'numpy' and elem_type.__name__ != 'str_' \\\n            and elem_type.__name__ != 'string_':\n        if elem_type.__name__ == 'ndarray' or elem_type.__name__ == 'memmap':\n            # array of string classes and object\n            if np_str_obj_array_pattern.search(elem.dtype.str) is not None:\n                raise TypeError(default_collate_err_msg_format.format(elem.dtype))\n\n            return flexible_collate([torch.as_tensor(b) for b in batch])\n        elif elem.shape == ():  # scalars\n            return torch.as_tensor(batch)\n    elif isinstance(elem, float):\n        return torch.tensor(batch, dtype=torch.float64)\n    elif isinstance(elem, int):\n        return torch.tensor(batch)\n    elif isinstance(elem, string_classes):\n        return batch\n    elif isinstance(elem, collections.abc.Mapping):\n        return {key: flexible_collate([d[key] for d in batch]) for key in elem}\n    elif isinstance(elem, tuple) and hasattr(elem, '_fields'):  # namedtuple\n        return elem_type(*(flexible_collate(samples) for samples in zip(*batch)))\n    elif isinstance(elem, collections.abc.Sequence):\n        # check to make sure that the elements in batch have consistent size\n        it = iter(batch)\n        elem_size = len(next(it))\n        if not all(len(elem) == elem_size for elem in it):\n            raise RuntimeError('each element in list of batch should be of equal size')\n        transposed = zip(*batch)\n        return [flexible_collate(samples) for samples in transposed]\n\n    raise TypeError(default_collate_err_msg_format.format(elem_type))\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/utils.py b/src/utils.py
--- a/src/utils.py	(revision c6be305e586f39b07663cb9bdb535828fe4047df)
+++ b/src/utils.py	(date 1717747028694)
@@ -2,7 +2,6 @@
 import os
 from os.path import join
 import io
-
 import matplotlib.pyplot as plt
 import numpy as np
 import torch.multiprocessing
@@ -11,7 +10,7 @@
 import wget
 from PIL import Image
 from scipy.optimize import linear_sum_assignment
-from torch._six import string_classes
+#from torch._six import string_classes
 from torch.utils.data import DataLoader
 from torch.utils.data._utils.collate import np_str_obj_array_pattern, default_collate_err_msg_format
 from torchmetrics import Metric
@@ -304,7 +303,7 @@
         return torch.tensor(batch, dtype=torch.float64)
     elif isinstance(elem, int):
         return torch.tensor(batch)
-    elif isinstance(elem, string_classes):
+    elif isinstance(elem, torch._six.string_classes):
         return batch
     elif isinstance(elem, collections.abc.Mapping):
         return {key: flexible_collate([d[key] for d in batch]) for key in elem}
Index: src/train_segmentation.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from utils import *\nfrom modules import *\nfrom data import *\nfrom torch.utils.data import DataLoader\nimport torch.nn.functional as F\nfrom datetime import datetime\nimport hydra\nfrom omegaconf import DictConfig, OmegaConf\nimport pytorch_lightning as pl\nfrom pytorch_lightning import Trainer\nfrom pytorch_lightning.loggers import TensorBoardLogger\nfrom pytorch_lightning.utilities.seed import seed_everything\nimport torch.multiprocessing\nimport seaborn as sns\nfrom pytorch_lightning.callbacks import ModelCheckpoint\nimport sys\n\ntorch.multiprocessing.set_sharing_strategy('file_system')\n\ndef get_class_labels(dataset_name):\n    if dataset_name.startswith(\"cityscapes\"):\n        return [\n            'road', 'sidewalk', 'parking', 'rail track', 'building',\n            'wall', 'fence', 'guard rail', 'bridge', 'tunnel',\n            'pole', 'polegroup', 'traffic light', 'traffic sign', 'vegetation',\n            'terrain', 'sky', 'person', 'rider', 'car',\n            'truck', 'bus', 'caravan', 'trailer', 'train',\n            'motorcycle', 'bicycle']\n    elif dataset_name == \"cocostuff27\":\n        return [\n            \"electronic\", \"appliance\", \"food\", \"furniture\", \"indoor\",\n            \"kitchen\", \"accessory\", \"animal\", \"outdoor\", \"person\",\n            \"sports\", \"vehicle\", \"ceiling\", \"floor\", \"food\",\n            \"furniture\", \"rawmaterial\", \"textile\", \"wall\", \"window\",\n            \"building\", \"ground\", \"plant\", \"sky\", \"solid\",\n            \"structural\", \"water\"]\n    elif dataset_name == \"voc\":\n        return [\n            'background',\n            'aeroplane', 'bicycle', 'bird', 'boat', 'bottle',\n            'bus', 'car', 'cat', 'chair', 'cow',\n            'diningtable', 'dog', 'horse', 'motorbike', 'person',\n            'pottedplant', 'sheep', 'sofa', 'train', 'tvmonitor']\n    elif dataset_name == \"potsdam\":\n        return [\n            'roads and cars',\n            'buildings and clutter',\n            'trees and vegetation']\n    else:\n        raise ValueError(\"Unknown Dataset {}\".format(dataset_name))\n\n\nclass LitUnsupervisedSegmenter(pl.LightningModule):\n    def __init__(self, n_classes, cfg):\n        super().__init__()\n        self.cfg = cfg\n        self.n_classes = n_classes\n\n        if not cfg.continuous:\n            dim = n_classes\n        else:\n            dim = cfg.dim\n\n        data_dir = join(cfg.output_root, \"data\")\n        if cfg.arch == \"feature-pyramid\":\n            cut_model = load_model(cfg.model_type, data_dir).cuda()\n            self.net = FeaturePyramidNet(cfg.granularity, cut_model, dim, cfg.continuous)\n        elif cfg.arch == \"dino\":\n            self.net = DinoFeaturizer(dim, cfg)\n        else:\n            raise ValueError(\"Unknown arch {}\".format(cfg.arch))\n\n        self.train_cluster_probe = ClusterLookup(dim, n_classes)\n\n        self.cluster_probe = ClusterLookup(dim, n_classes + cfg.extra_clusters)\n        self.linear_probe = nn.Conv2d(dim, n_classes, (1, 1))\n\n        self.decoder = nn.Conv2d(dim, self.net.n_feats, (1, 1))\n\n        self.cluster_metrics = UnsupervisedMetrics(\n            \"test/cluster/\", n_classes, cfg.extra_clusters, True)\n        self.linear_metrics = UnsupervisedMetrics(\n            \"test/linear/\", n_classes, 0, False)\n\n        self.test_cluster_metrics = UnsupervisedMetrics(\n            \"final/cluster/\", n_classes, cfg.extra_clusters, True)\n        self.test_linear_metrics = UnsupervisedMetrics(\n            \"final/linear/\", n_classes, 0, False)\n\n        self.linear_probe_loss_fn = torch.nn.CrossEntropyLoss()\n        self.crf_loss_fn = ContrastiveCRFLoss(\n            cfg.crf_samples, cfg.alpha, cfg.beta, cfg.gamma, cfg.w1, cfg.w2, cfg.shift)\n\n        self.contrastive_corr_loss_fn = ContrastiveCorrelationLoss(cfg)\n        for p in self.contrastive_corr_loss_fn.parameters():\n            p.requires_grad = False\n\n        self.automatic_optimization = False\n\n        if self.cfg.dataset_name.startswith(\"cityscapes\"):\n            self.label_cmap = create_cityscapes_colormap()\n        else:\n            self.label_cmap = create_pascal_label_colormap()\n\n        self.val_steps = 0\n        self.save_hyperparameters()\n\n    def forward(self, x):\n        # in lightning, forward defines the prediction/inference actions\n        return self.net(x)[1]\n\n    def training_step(self, batch, batch_idx):\n        # training_step defined the train loop.\n        # It is independent of forward\n        net_optim, linear_probe_optim, cluster_probe_optim = self.optimizers()\n\n        net_optim.zero_grad()\n        linear_probe_optim.zero_grad()\n        cluster_probe_optim.zero_grad()\n\n        with torch.no_grad():\n            ind = batch[\"ind\"]\n            img = batch[\"img\"]\n            img_aug = batch[\"img_aug\"]\n            coord_aug = batch[\"coord_aug\"]\n            img_pos = batch[\"img_pos\"]\n            label = batch[\"label\"]\n            label_pos = batch[\"label_pos\"]\n\n        feats, code = self.net(img)\n        if self.cfg.correspondence_weight > 0:\n            feats_pos, code_pos = self.net(img_pos)\n        log_args = dict(sync_dist=False, rank_zero_only=True)\n\n        if self.cfg.use_true_labels:\n            signal = one_hot_feats(label + 1, self.n_classes + 1)\n            signal_pos = one_hot_feats(label_pos + 1, self.n_classes + 1)\n        else:\n            signal = feats\n            signal_pos = feats_pos\n\n        loss = 0\n\n        should_log_hist = (self.cfg.hist_freq is not None) and \\\n                          (self.global_step % self.cfg.hist_freq == 0) and \\\n                          (self.global_step > 0)\n        if self.cfg.use_salience:\n            salience = batch[\"mask\"].to(torch.float32).squeeze(1)\n            salience_pos = batch[\"mask_pos\"].to(torch.float32).squeeze(1)\n        else:\n            salience = None\n            salience_pos = None\n\n        if self.cfg.correspondence_weight > 0:\n            (\n                pos_intra_loss, pos_intra_cd,\n                pos_inter_loss, pos_inter_cd,\n                neg_inter_loss, neg_inter_cd,\n            ) = self.contrastive_corr_loss_fn(\n                signal, signal_pos,\n                salience, salience_pos,\n                code, code_pos,\n            )\n\n            if should_log_hist:\n                self.logger.experiment.add_histogram(\"intra_cd\", pos_intra_cd, self.global_step)\n                self.logger.experiment.add_histogram(\"inter_cd\", pos_inter_cd, self.global_step)\n                self.logger.experiment.add_histogram(\"neg_cd\", neg_inter_cd, self.global_step)\n            neg_inter_loss = neg_inter_loss.mean()\n            pos_intra_loss = pos_intra_loss.mean()\n            pos_inter_loss = pos_inter_loss.mean()\n            self.log('loss/pos_intra', pos_intra_loss, **log_args)\n            self.log('loss/pos_inter', pos_inter_loss, **log_args)\n            self.log('loss/neg_inter', neg_inter_loss, **log_args)\n            self.log('cd/pos_intra', pos_intra_cd.mean(), **log_args)\n            self.log('cd/pos_inter', pos_inter_cd.mean(), **log_args)\n            self.log('cd/neg_inter', neg_inter_cd.mean(), **log_args)\n\n            loss += (self.cfg.pos_inter_weight * pos_inter_loss +\n                     self.cfg.pos_intra_weight * pos_intra_loss +\n                     self.cfg.neg_inter_weight * neg_inter_loss) * self.cfg.correspondence_weight\n\n        if self.cfg.rec_weight > 0:\n            rec_feats = self.decoder(code)\n            rec_loss = -(norm(rec_feats) * norm(feats)).sum(1).mean()\n            self.log('loss/rec', rec_loss, **log_args)\n            loss += self.cfg.rec_weight * rec_loss\n\n        if self.cfg.aug_alignment_weight > 0:\n            orig_feats_aug, orig_code_aug = self.net(img_aug)\n            downsampled_coord_aug = resize(\n                coord_aug.permute(0, 3, 1, 2),\n                orig_code_aug.shape[2]).permute(0, 2, 3, 1)\n            aug_alignment = -torch.einsum(\n                \"bkhw,bkhw->bhw\",\n                norm(sample(code, downsampled_coord_aug)),\n                norm(orig_code_aug)\n            ).mean()\n            self.log('loss/aug_alignment', aug_alignment, **log_args)\n            loss += self.cfg.aug_alignment_weight * aug_alignment\n\n        if self.cfg.crf_weight > 0:\n            crf = self.crf_loss_fn(\n                resize(img, 56),\n                norm(resize(code, 56))\n            ).mean()\n            self.log('loss/crf', crf, **log_args)\n            loss += self.cfg.crf_weight * crf\n\n        flat_label = label.reshape(-1)\n        mask = (flat_label >= 0) & (flat_label < self.n_classes)\n\n        detached_code = torch.clone(code.detach())\n\n        linear_logits = self.linear_probe(detached_code)\n        linear_logits = F.interpolate(linear_logits, label.shape[-2:], mode='bilinear', align_corners=False)\n        linear_logits = linear_logits.permute(0, 2, 3, 1).reshape(-1, self.n_classes)\n        linear_loss = self.linear_probe_loss_fn(linear_logits[mask], flat_label[mask]).mean()\n        loss += linear_loss\n        self.log('loss/linear', linear_loss, **log_args)\n\n        cluster_loss, cluster_probs = self.cluster_probe(detached_code, None)\n        loss += cluster_loss\n        self.log('loss/cluster', cluster_loss, **log_args)\n        self.log('loss/total', loss, **log_args)\n\n        self.manual_backward(loss)\n        net_optim.step()\n        cluster_probe_optim.step()\n        linear_probe_optim.step()\n\n        if self.cfg.reset_probe_steps is not None and self.global_step == self.cfg.reset_probe_steps:\n            print(\"RESETTING PROBES\")\n            self.linear_probe.reset_parameters()\n            self.cluster_probe.reset_parameters()\n            self.trainer.optimizers[1] = torch.optim.Adam(list(self.linear_probe.parameters()), lr=5e-3)\n            self.trainer.optimizers[2] = torch.optim.Adam(list(self.cluster_probe.parameters()), lr=5e-3)\n\n        if self.global_step % 2000 == 0 and self.global_step > 0:\n            print(\"RESETTING TFEVENT FILE\")\n            # Make a new tfevent file\n            self.logger.experiment.close()\n            self.logger.experiment._get_file_writer()\n\n        return loss\n\n    def on_train_start(self):\n        tb_metrics = {\n            **self.linear_metrics.compute(),\n            **self.cluster_metrics.compute()\n        }\n        self.logger.log_hyperparams(self.cfg, tb_metrics)\n\n    def validation_step(self, batch, batch_idx):\n        img = batch[\"img\"]\n        label = batch[\"label\"]\n        self.net.eval()\n\n        with torch.no_grad():\n            feats, code = self.net(img)\n            code = F.interpolate(code, label.shape[-2:], mode='bilinear', align_corners=False)\n\n            linear_preds = self.linear_probe(code)\n            linear_preds = linear_preds.argmax(1)\n            self.linear_metrics.update(linear_preds, label)\n\n            cluster_loss, cluster_preds = self.cluster_probe(code, None)\n            cluster_preds = cluster_preds.argmax(1)\n            self.cluster_metrics.update(cluster_preds, label)\n\n            return {\n                'img': img[:self.cfg.n_images].detach().cpu(),\n                'linear_preds': linear_preds[:self.cfg.n_images].detach().cpu(),\n                \"cluster_preds\": cluster_preds[:self.cfg.n_images].detach().cpu(),\n                \"label\": label[:self.cfg.n_images].detach().cpu()}\n\n    def validation_epoch_end(self, outputs) -> None:\n        super().validation_epoch_end(outputs)\n        with torch.no_grad():\n            tb_metrics = {\n                **self.linear_metrics.compute(),\n                **self.cluster_metrics.compute(),\n            }\n\n            if self.trainer.is_global_zero and not self.cfg.submitting_to_aml:\n                #output_num = 0\n                output_num = random.randint(0, len(outputs) -1)\n                output = {k: v.detach().cpu() for k, v in outputs[output_num].items()}\n\n                fig, ax = plt.subplots(4, self.cfg.n_images, figsize=(self.cfg.n_images * 3, 4 * 3))\n                for i in range(self.cfg.n_images):\n                    ax[0, i].imshow(prep_for_plot(output[\"img\"][i]))\n                    ax[1, i].imshow(self.label_cmap[output[\"label\"][i]])\n                    ax[2, i].imshow(self.label_cmap[output[\"linear_preds\"][i]])\n                    ax[3, i].imshow(self.label_cmap[self.cluster_metrics.map_clusters(output[\"cluster_preds\"][i])])\n                ax[0, 0].set_ylabel(\"Image\", fontsize=16)\n                ax[1, 0].set_ylabel(\"Label\", fontsize=16)\n                ax[2, 0].set_ylabel(\"Linear Probe\", fontsize=16)\n                ax[3, 0].set_ylabel(\"Cluster Probe\", fontsize=16)\n                remove_axes(ax)\n                plt.tight_layout()\n                add_plot(self.logger.experiment, \"plot_labels\", self.global_step)\n\n                if self.cfg.has_labels:\n                    fig = plt.figure(figsize=(13, 10))\n                    ax = fig.gca()\n                    hist = self.cluster_metrics.histogram.detach().cpu().to(torch.float32)\n                    hist /= torch.clamp_min(hist.sum(dim=0, keepdim=True), 1)\n                    sns.heatmap(hist.t(), annot=False, fmt='g', ax=ax, cmap=\"Blues\")\n                    ax.set_xlabel('Predicted labels')\n                    ax.set_ylabel('True labels')\n                    names = get_class_labels(self.cfg.dataset_name)\n                    if self.cfg.extra_clusters:\n                        names = names + [\"Extra\"]\n                    ax.set_xticks(np.arange(0, len(names)) + .5)\n                    ax.set_yticks(np.arange(0, len(names)) + .5)\n                    ax.xaxis.tick_top()\n                    ax.xaxis.set_ticklabels(names, fontsize=14)\n                    ax.yaxis.set_ticklabels(names, fontsize=14)\n                    colors = [self.label_cmap[i] / 255.0 for i in range(len(names))]\n                    [t.set_color(colors[i]) for i, t in enumerate(ax.xaxis.get_ticklabels())]\n                    [t.set_color(colors[i]) for i, t in enumerate(ax.yaxis.get_ticklabels())]\n                    # ax.yaxis.get_ticklabels()[-1].set_color(self.label_cmap[0] / 255.0)\n                    # ax.xaxis.get_ticklabels()[-1].set_color(self.label_cmap[0] / 255.0)\n                    plt.xticks(rotation=90)\n                    plt.yticks(rotation=0)\n                    ax.vlines(np.arange(0, len(names) + 1), color=[.5, .5, .5], *ax.get_xlim())\n                    ax.hlines(np.arange(0, len(names) + 1), color=[.5, .5, .5], *ax.get_ylim())\n                    plt.tight_layout()\n                    add_plot(self.logger.experiment, \"conf_matrix\", self.global_step)\n\n                    all_bars = torch.cat([\n                        self.cluster_metrics.histogram.sum(0).cpu(),\n                        self.cluster_metrics.histogram.sum(1).cpu()\n                    ], axis=0)\n                    ymin = max(all_bars.min() * .8, 1)\n                    ymax = all_bars.max() * 1.2\n\n                    fig, ax = plt.subplots(1, 2, figsize=(2 * 5, 1 * 4))\n                    ax[0].bar(range(self.n_classes + self.cfg.extra_clusters),\n                              self.cluster_metrics.histogram.sum(0).cpu(),\n                              tick_label=names,\n                              color=colors)\n                    ax[0].set_ylim(ymin, ymax)\n                    ax[0].set_title(\"Label Frequency\")\n                    ax[0].set_yscale('log')\n                    ax[0].tick_params(axis='x', labelrotation=90)\n\n                    ax[1].bar(range(self.n_classes + self.cfg.extra_clusters),\n                              self.cluster_metrics.histogram.sum(1).cpu(),\n                              tick_label=names,\n                              color=colors)\n                    ax[1].set_ylim(ymin, ymax)\n                    ax[1].set_title(\"Cluster Frequency\")\n                    ax[1].set_yscale('log')\n                    ax[1].tick_params(axis='x', labelrotation=90)\n\n                    plt.tight_layout()\n                    add_plot(self.logger.experiment, \"label frequency\", self.global_step)\n\n            if self.global_step > 2:\n                self.log_dict(tb_metrics)\n\n                if self.trainer.is_global_zero and self.cfg.azureml_logging:\n                    from azureml.core.run import Run\n                    run_logger = Run.get_context()\n                    for metric, value in tb_metrics.items():\n                        run_logger.log(metric, value)\n\n            self.linear_metrics.reset()\n            self.cluster_metrics.reset()\n\n    def configure_optimizers(self):\n        main_params = list(self.net.parameters())\n\n        if self.cfg.rec_weight > 0:\n            main_params.extend(self.decoder.parameters())\n\n        net_optim = torch.optim.Adam(main_params, lr=self.cfg.lr)\n        linear_probe_optim = torch.optim.Adam(list(self.linear_probe.parameters()), lr=5e-3)\n        cluster_probe_optim = torch.optim.Adam(list(self.cluster_probe.parameters()), lr=5e-3)\n\n        return net_optim, linear_probe_optim, cluster_probe_optim\n\n\n@hydra.main(config_path=\"configs\", config_name=\"train_config.yml\")\ndef my_app(cfg: DictConfig) -> None:\n    OmegaConf.set_struct(cfg, False)\n    print(OmegaConf.to_yaml(cfg))\n    pytorch_data_dir = cfg.pytorch_data_dir\n    data_dir = join(cfg.output_root, \"data\")\n    log_dir = join(cfg.output_root, \"logs\")\n    checkpoint_dir = join(cfg.output_root, \"checkpoints\")\n\n    prefix = \"{}/{}_{}\".format(cfg.log_dir, cfg.dataset_name, cfg.experiment_name)\n    name = '{}_date_{}'.format(prefix, datetime.now().strftime('%b%d_%H-%M-%S'))\n    cfg.full_name = prefix\n\n    os.makedirs(data_dir, exist_ok=True)\n    os.makedirs(log_dir, exist_ok=True)\n    os.makedirs(checkpoint_dir, exist_ok=True)\n\n    seed_everything(seed=0)\n\n    print(data_dir)\n    print(cfg.output_root)\n\n    geometric_transforms = T.Compose([\n        T.RandomHorizontalFlip(),\n        T.RandomResizedCrop(size=cfg.res, scale=(0.8, 1.0))\n    ])\n    photometric_transforms = T.Compose([\n        T.ColorJitter(brightness=.3, contrast=.3, saturation=.3, hue=.1),\n        T.RandomGrayscale(.2),\n        T.RandomApply([T.GaussianBlur((5, 5))])\n    ])\n\n    sys.stdout.flush()\n\n    train_dataset = ContrastiveSegDataset(\n        pytorch_data_dir=pytorch_data_dir,\n        dataset_name=cfg.dataset_name,\n        crop_type=cfg.crop_type,\n        image_set=\"train\",\n        transform=get_transform(cfg.res, False, cfg.loader_crop_type),\n        target_transform=get_transform(cfg.res, True, cfg.loader_crop_type),\n        cfg=cfg,\n        aug_geometric_transform=geometric_transforms,\n        aug_photometric_transform=photometric_transforms,\n        num_neighbors=cfg.num_neighbors,\n        mask=True,\n        pos_images=True,\n        pos_labels=True\n    )\n\n    if cfg.dataset_name == \"voc\":\n        val_loader_crop = None\n    else:\n        val_loader_crop = \"center\"\n\n    val_dataset = ContrastiveSegDataset(\n        pytorch_data_dir=pytorch_data_dir,\n        dataset_name=cfg.dataset_name,\n        crop_type=None,\n        image_set=\"val\",\n        transform=get_transform(320, False, val_loader_crop),\n        target_transform=get_transform(320, True, val_loader_crop),\n        mask=True,\n        cfg=cfg,\n    )\n\n    #val_dataset = MaterializedDataset(val_dataset)\n    train_loader = DataLoader(train_dataset, cfg.batch_size, shuffle=True, num_workers=cfg.num_workers, pin_memory=True)\n\n    if cfg.submitting_to_aml:\n        val_batch_size = 16\n    else:\n        val_batch_size = cfg.batch_size\n\n    val_loader = DataLoader(val_dataset, val_batch_size, shuffle=False, num_workers=cfg.num_workers, pin_memory=True)\n\n    model = LitUnsupervisedSegmenter(train_dataset.n_classes, cfg)\n\n    tb_logger = TensorBoardLogger(\n        join(log_dir, name),\n        default_hp_metric=False\n    )\n\n    if cfg.submitting_to_aml:\n        gpu_args = dict(gpus=1, val_check_interval=250)\n\n        if gpu_args[\"val_check_interval\"] > len(train_loader):\n            gpu_args.pop(\"val_check_interval\")\n\n    else:\n        gpu_args = dict(gpus=-1, accelerator='ddp', val_check_interval=cfg.val_freq)\n        # gpu_args = dict(gpus=1, accelerator='ddp', val_check_interval=cfg.val_freq)\n\n        if gpu_args[\"val_check_interval\"] > len(train_loader) // 4:\n            gpu_args.pop(\"val_check_interval\")\n\n    trainer = Trainer(\n        log_every_n_steps=cfg.scalar_log_freq,\n        logger=tb_logger,\n        max_steps=cfg.max_steps,\n        callbacks=[\n            ModelCheckpoint(\n                dirpath=join(checkpoint_dir, name),\n                every_n_train_steps=400,\n                save_top_k=2,\n                monitor=\"test/cluster/mIoU\",\n                mode=\"max\",\n            )\n        ],\n        **gpu_args\n    )\n    trainer.fit(model, train_loader, val_loader)\n\n\nif __name__ == \"__main__\":\n    prep_args()\n    my_app()\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/train_segmentation.py b/src/train_segmentation.py
--- a/src/train_segmentation.py	(revision c6be305e586f39b07663cb9bdb535828fe4047df)
+++ b/src/train_segmentation.py	(date 1717746676819)
@@ -1,3 +1,4 @@
+from matplotlib import pyplot as plt
 from utils import *
 from modules import *
 from data import *
@@ -15,6 +16,9 @@
 from pytorch_lightning.callbacks import ModelCheckpoint
 import sys
 
+from src.utils import load_model, UnsupervisedMetrics, one_hot_feats, resize, prep_for_plot, remove_axes, add_plot, \
+    get_transform, prep_args
+
 torch.multiprocessing.set_sharing_strategy('file_system')
 
 def get_class_labels(dataset_name):
Index: src/crop_datasets.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from modules import *\nimport os\nfrom data import ContrastiveSegDataset\nimport hydra\nimport torch\nfrom omegaconf import DictConfig, OmegaConf\nfrom pytorch_lightning.utilities.seed import seed_everything\nfrom torch.utils.data import DataLoader\nfrom torchvision.transforms.functional import five_crop, _get_image_size, crop\nfrom tqdm import tqdm\nfrom torch.utils.data import Dataset\n\n\ndef _random_crops(img, size, seed, n):\n    \"\"\"Crop the given image into four corners and the central crop.\n    If the image is torch Tensor, it is expected\n    to have [..., H, W] shape, where ... means an arbitrary number of leading dimensions\n\n    .. Note::\n        This transform returns a tuple of images and there may be a\n        mismatch in the number of inputs and targets your ``Dataset`` returns.\n\n    Args:\n        img (PIL Image or Tensor): Image to be cropped.\n        size (sequence or int): Desired output size of the crop. If size is an\n            int instead of sequence like (h, w), a square crop (size, size) is\n            made. If provided a sequence of length 1, it will be interpreted as (size[0], size[0]).\n\n    Returns:\n       tuple: tuple (tl, tr, bl, br, center)\n                Corresponding top left, top right, bottom left, bottom right and center crop.\n    \"\"\"\n    if isinstance(size, int):\n        size = (int(size), int(size))\n    elif isinstance(size, (tuple, list)) and len(size) == 1:\n        size = (size[0], size[0])\n\n    if len(size) != 2:\n        raise ValueError(\"Please provide only two dimensions (h, w) for size.\")\n\n    image_width, image_height = _get_image_size(img)\n    crop_height, crop_width = size\n    if crop_width > image_width or crop_height > image_height:\n        msg = \"Requested crop size {} is bigger than input size {}\"\n        raise ValueError(msg.format(size, (image_height, image_width)))\n\n    images = []\n    for i in range(n):\n        seed1 = hash((seed, i, 0))\n        seed2 = hash((seed, i, 1))\n        crop_height, crop_width = int(crop_height), int(crop_width)\n\n        top = seed1 % (image_height - crop_height)\n        left = seed2 % (image_width - crop_width)\n        images.append(crop(img, top, left, crop_height, crop_width))\n\n    return images\n\n\nclass RandomCropComputer(Dataset):\n\n    def _get_size(self, img):\n        if len(img.shape) == 3:\n            return [int(img.shape[1] * self.crop_ratio), int(img.shape[2] * self.crop_ratio)]\n        elif len(img.shape) == 2:\n            return [int(img.shape[0] * self.crop_ratio), int(img.shape[1] * self.crop_ratio)]\n        else:\n            raise ValueError(\"Bad image shape {}\".format(img.shape))\n\n    def random_crops(self, i, img):\n        return _random_crops(img, self._get_size(img), i, 5)\n\n    def five_crops(self, i, img):\n        return five_crop(img, self._get_size(img))\n\n    def __init__(self, cfg, dataset_name, img_set, crop_type, crop_ratio):\n        self.pytorch_data_dir = cfg.pytorch_data_dir\n        self.crop_ratio = crop_ratio\n        self.save_dir = join(\n            cfg.pytorch_data_dir, \"cropped\", \"{}_{}_crop_{}\".format(dataset_name, crop_type, crop_ratio))\n        self.img_set = img_set\n        self.dataset_name = dataset_name\n        self.cfg = cfg\n\n        self.img_dir = join(self.save_dir, \"img\", img_set)\n        self.label_dir = join(self.save_dir, \"label\", img_set)\n        os.makedirs(self.img_dir, exist_ok=True)\n        os.makedirs(self.label_dir, exist_ok=True)\n\n        if crop_type == \"random\":\n            cropper = lambda i, x: self.random_crops(i, x)\n        elif crop_type == \"five\":\n            cropper = lambda i, x: self.five_crops(i, x)\n        else:\n            raise ValueError('Unknown crop type {}'.format(crop_type))\n\n        self.dataset = ContrastiveSegDataset(\n            cfg.pytorch_data_dir,\n            dataset_name,\n            None,\n            img_set,\n            T.ToTensor(),\n            ToTargetTensor(),\n            cfg=cfg,\n            num_neighbors=cfg.num_neighbors,\n            pos_labels=False,\n            pos_images=False,\n            mask=False,\n            aug_geometric_transform=None,\n            aug_photometric_transform=None,\n            extra_transform=cropper\n        )\n\n    def __getitem__(self, item):\n        batch = self.dataset[item]\n        imgs = batch['img']\n        labels = batch['label']\n        for crop_num, (img, label) in enumerate(zip(imgs, labels)):\n            img_num = item * 5 + crop_num\n            img_arr = img.mul(255).add_(0.5).clamp_(0, 255).permute(1, 2, 0).to('cpu', torch.uint8).numpy()\n            label_arr = (label + 1).unsqueeze(0).permute(1, 2, 0).to('cpu', torch.uint8).numpy().squeeze(-1)\n            Image.fromarray(img_arr).save(join(self.img_dir, \"{}.jpg\".format(img_num)), 'JPEG')\n            Image.fromarray(label_arr).save(join(self.label_dir, \"{}.png\".format(img_num)), 'PNG')\n        return True\n\n    def __len__(self):\n        return len(self.dataset)\n\n\n@hydra.main(config_path=\"configs\", config_name=\"train_config.yml\")\ndef my_app(cfg: DictConfig) -> None:\n    print(OmegaConf.to_yaml(cfg))\n    seed_everything(seed=0, workers=True)\n\n    # dataset_names = [\"cityscapes\", \"cocostuff27\"]\n    # img_sets = [\"train\", \"val\"]\n    # crop_types = [\"five\",\"random\"]\n    # crop_ratios = [.5, .7]\n\n    dataset_names = [\"cityscapes\"]\n    img_sets = [\"train\", \"val\"]\n    crop_types = [\"five\"]\n    crop_ratios = [.5]\n\n    for crop_ratio in crop_ratios:\n        for crop_type in crop_types:\n            for dataset_name in dataset_names:\n                for img_set in img_sets:\n                    dataset = RandomCropComputer(cfg, dataset_name, img_set, crop_type, crop_ratio)\n                    loader = DataLoader(dataset, 1, shuffle=False, num_workers=cfg.num_workers, collate_fn=lambda l: l)\n                    for _ in tqdm(loader):\n                        pass\n\n\nif __name__ == \"__main__\":\n    prep_args()\n    my_app()\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/crop_datasets.py b/src/crop_datasets.py
--- a/src/crop_datasets.py	(revision c6be305e586f39b07663cb9bdb535828fe4047df)
+++ b/src/crop_datasets.py	(date 1717584581506)
@@ -1,3 +1,8 @@
+import torchvision
+from torch import T
+from torch.distributed.pipeline.sync.dependency import join
+from torchvision.tv_tensors import Image
+
 from modules import *
 import os
 from data import ContrastiveSegDataset
@@ -6,10 +11,12 @@
 from omegaconf import DictConfig, OmegaConf
 from pytorch_lightning.utilities.seed import seed_everything
 from torch.utils.data import DataLoader
-from torchvision.transforms.functional import five_crop, _get_image_size, crop
+from torchvision.transforms.functional import five_crop, crop #_get_image_size
 from tqdm import tqdm
 from torch.utils.data import Dataset
 
+from src.utils import prep_args, ToTargetTensor
+
 
 def _random_crops(img, size, seed, n):
     """Crop the given image into four corners and the central crop.
@@ -38,7 +45,7 @@
     if len(size) != 2:
         raise ValueError("Please provide only two dimensions (h, w) for size.")
 
-    image_width, image_height = _get_image_size(img)
+    image_width, image_height = torchvision.transforms.functional._get_image_size(img)
     crop_height, crop_width = size
     if crop_width > image_width or crop_height > image_height:
         msg = "Requested crop size {} is bigger than input size {}"
Index: src/plot_potsdam.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from collections import defaultdict\nimport hydra\nimport torch.multiprocessing\nfrom omegaconf import DictConfig, OmegaConf\nfrom torch.utils.data import DataLoader\nfrom data import *\nfrom modules import *\nfrom train_segmentation import LitUnsupervisedSegmenter\n\n\n@hydra.main(config_path=\"configs\", config_name=\"train_config.yml\")\ndef my_app(cfg: DictConfig) -> None:\n    # print(OmegaConf.to_yaml(cfg))\n    pytorch_data_dir = cfg.pytorch_data_dir\n\n    result_dir = \"../results/predictions/potsdam\"\n    os.makedirs(result_dir, exist_ok=True)\n    os.makedirs(join(result_dir, \"img\"), exist_ok=True)\n    os.makedirs(join(result_dir, \"label\"), exist_ok=True)\n    os.makedirs(join(result_dir, \"cluster\"), exist_ok=True)\n\n    full_dataset = ContrastiveSegDataset(\n        pytorch_data_dir=pytorch_data_dir,\n        dataset_name=\"potsdamraw\",\n        crop_type=None,\n        image_set=\"all\",\n        transform=get_transform(320, False, \"center\"),\n        target_transform=get_transform(320, True, \"center\"),\n        cfg=cfg,\n    )\n\n    test_loader = DataLoader(full_dataset, 64,\n                             shuffle=False, num_workers=cfg.num_workers,\n                             pin_memory=True, collate_fn=flexible_collate)\n\n    model = LitUnsupervisedSegmenter.load_from_checkpoint(\"../saved_models/potsdam_test.ckpt\")\n    print(OmegaConf.to_yaml(model.cfg))\n    model.eval().cuda()\n    par_model = torch.nn.DataParallel(model.net)\n\n    outputs = defaultdict(list)\n    for i, batch in enumerate(tqdm(test_loader)):\n        with torch.no_grad():\n            if i > 100:\n                break\n\n            img = batch[\"img\"].cuda()\n            label = batch[\"label\"].cuda()\n            feats, code1 = par_model(img)\n            feats, code2 = par_model(img.flip(dims=[3]))\n            code = (code1 + code2.flip(dims=[3])) / 2\n\n            code = F.interpolate(code, label.shape[-2:], mode='bilinear', align_corners=False)\n            cluster_prob = model.cluster_probe(code, 2, log_probs=True)\n            cluster_pred = cluster_prob.argmax(1)\n\n            model.test_cluster_metrics.update(cluster_pred, label)\n\n            outputs['img'].append(img.cpu())\n            outputs['label'].append(label.cpu())\n            outputs['cluster_pred'].append(cluster_pred.cpu())\n            outputs['cluster_prob'].append(cluster_prob.cpu())\n    model.test_cluster_metrics.compute()\n\n    img_num = 6\n    outputs = {k: torch.cat(v, dim=0)[15 * 15 * img_num:15 * 15 * (img_num + 1)] for k, v in outputs.items()}\n\n    full_image = outputs['img'].reshape(15, 15, 3, 320, 320) \\\n        .permute(2, 0, 3, 1, 4) \\\n        .reshape(3, 320 * 15, 320 * 15)\n\n    full_cluster_prob = outputs['cluster_prob'].reshape(15, 15, 3, 320, 320) \\\n        .permute(2, 0, 3, 1, 4) \\\n        .reshape(3, 320 * 15, 320 * 15)\n\n    # crf_probs = dense_crf(full_image.cpu().detach(),\n    #                       full_cluster_prob.cpu().detach())\n    crf_probs = full_cluster_prob.numpy()\n    print(crf_probs.shape)\n\n    reshaped_label = outputs['label'].reshape(15, 15, 320, 320).permute(0, 2, 1, 3).reshape(320 * 15, 320 * 15)\n    reshaped_img = unnorm(full_image).permute(1, 2, 0)\n    reshaped_preds = model.test_cluster_metrics.map_clusters(np.expand_dims(crf_probs.argmax(0), 0))\n\n    fig, ax = plt.subplots(1, 3, figsize=(4 * 3, 4))\n    ax[0].imshow(reshaped_img)\n    ax[1].imshow(reshaped_preds)\n    ax[2].imshow(reshaped_label)\n\n    Image.fromarray(reshaped_img.cuda()).save(join(join(result_dir, \"img\", str(img_num) + \".png\")))\n    Image.fromarray(reshaped_preds).save(join(join(result_dir, \"cluster\", str(img_num) + \".png\")))\n\n    remove_axes(ax)\n    plt.show()\n\nif __name__ == \"__main__\":\n    prep_args()\n    my_app()\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/plot_potsdam.py b/src/plot_potsdam.py
--- a/src/plot_potsdam.py	(revision c6be305e586f39b07663cb9bdb535828fe4047df)
+++ b/src/plot_potsdam.py	(date 1717584581543)
@@ -1,10 +1,13 @@
 from collections import defaultdict
 import hydra
 import torch.multiprocessing
+from matplotlib import pyplot as plt
 from omegaconf import DictConfig, OmegaConf
 from torch.utils.data import DataLoader
 from data import *
 from modules import *
+from src import utils
+from src.utils import get_transform, flexible_collate, prep_args
 from train_segmentation import LitUnsupervisedSegmenter
 
 
@@ -79,7 +82,7 @@
     print(crf_probs.shape)
 
     reshaped_label = outputs['label'].reshape(15, 15, 320, 320).permute(0, 2, 1, 3).reshape(320 * 15, 320 * 15)
-    reshaped_img = unnorm(full_image).permute(1, 2, 0)
+    reshaped_img = utils.unnorm(full_image).permute(1, 2, 0)
     reshaped_preds = model.test_cluster_metrics.map_clusters(np.expand_dims(crf_probs.argmax(0), 0))
 
     fig, ax = plt.subplots(1, 3, figsize=(4 * 3, 4))
@@ -90,8 +93,8 @@
     Image.fromarray(reshaped_img.cuda()).save(join(join(result_dir, "img", str(img_num) + ".png")))
     Image.fromarray(reshaped_preds).save(join(join(result_dir, "cluster", str(img_num) + ".png")))
 
-    remove_axes(ax)
-    plt.show()
+    utils.remove_axes(ax)
+    utils.plt.show()
 
 if __name__ == "__main__":
     prep_args()
Index: src/download_datasets.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from utils import *\nimport hydra\nfrom omegaconf import DictConfig\nimport os\nimport wget\n\n\n@hydra.main(config_path=\"configs\", config_name=\"eval_config.yml\")\ndef my_app(cfg: DictConfig) -> None:\n    pytorch_data_dir = \"~/Downloads\"\n    dataset_names = [\n        #\"potsdam\",\n        \"cityscapes\"\n        #\"cocostuff\",\n        #\"potsdamraw\"\n        ]\n    url_base = \"https://marhamilresearch4.blob.core.windows.net/stego-public/pytorch_data/\"\n\n    os.makedirs(pytorch_data_dir, exist_ok=True)\n    for dataset_name in dataset_names:\n        if (not os.path.exists(join(pytorch_data_dir, dataset_name))) or \\\n                (not os.path.exists(join(pytorch_data_dir, dataset_name + \".zip\"))):\n            print(\"\\n Downloading {}\".format(dataset_name))\n            wget.download(url_base + dataset_name + \".zip\", join(pytorch_data_dir, dataset_name + \".zip\"))\n        else:\n            print(\"\\n Found {}, skipping download\".format(dataset_name))\n\n\nif __name__ == \"__main__\":\n    prep_args()\n    my_app()\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/download_datasets.py b/src/download_datasets.py
--- a/src/download_datasets.py	(revision c6be305e586f39b07663cb9bdb535828fe4047df)
+++ b/src/download_datasets.py	(date 1717584581551)
@@ -1,9 +1,12 @@
+from torch.distributed.pipeline.sync.dependency import join
 from utils import *
 import hydra
 from omegaconf import DictConfig
 import os
 import wget
 
+from src.utils import prep_args
+
 
 @hydra.main(config_path="configs", config_name="eval_config.yml")
 def my_app(cfg: DictConfig) -> None:
Index: src/plot_dino_correspondence.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import os\nfrom os.path import join\nfrom utils import get_transform, load_model, prep_for_plot, remove_axes, prep_args\nfrom modules import FeaturePyramidNet, DinoFeaturizer, sample\nfrom data import ContrastiveSegDataset\nimport hydra\nimport matplotlib.animation as animation\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport torch\nimport torch.nn.functional as F\nfrom omegaconf import DictConfig, OmegaConf\nfrom pytorch_lightning.utilities.seed import seed_everything\nfrom torch.utils.data import DataLoader\nfrom tqdm import tqdm\nfrom matplotlib.colors import ListedColormap\n\n\ndef plot_heatmap(ax, image, heatmap, cmap=\"bwr\", color=False, plot_img=True, symmetric=True):\n    vmax = np.abs(heatmap).max()\n    if not color:\n        bw = np.dot(np.array(image)[..., :3], [0.2989, 0.5870, 0.1140])\n        image = np.ones_like(image) * np.expand_dims(bw, -1)\n\n    if symmetric:\n        kwargs = dict(vmax=vmax, vmin=-vmax)\n    else:\n        kwargs = {}\n\n    if plot_img:\n        return [\n            ax.imshow(image),\n            ax.imshow(heatmap, alpha=.5, cmap=cmap, **kwargs),\n        ]\n    else:\n        return [ax.imshow(heatmap, alpha=.5, cmap=cmap, **kwargs)]\n\n\ndef get_heatmaps(net, img, img_pos, query_points):\n    feats1, _ = net(img.cuda())\n    feats2, _ = net(img_pos.cuda())\n\n    sfeats1 = sample(feats1, query_points)\n\n    attn_intra = torch.einsum(\"nchw,ncij->nhwij\", F.normalize(sfeats1, dim=1), F.normalize(feats1, dim=1))\n    attn_intra -= attn_intra.mean([3, 4], keepdims=True)\n    attn_intra = attn_intra.clamp(0).squeeze(0)\n\n    attn_inter = torch.einsum(\"nchw,ncij->nhwij\", F.normalize(sfeats1, dim=1), F.normalize(feats2, dim=1))\n    attn_inter -= attn_inter.mean([3, 4], keepdims=True)\n    attn_inter = attn_inter.clamp(0).squeeze(0)\n\n    heatmap_intra = F.interpolate(\n        attn_intra, img.shape[2:], mode=\"bilinear\", align_corners=True).squeeze(0).detach().cpu()\n    heatmap_inter = F.interpolate(\n        attn_inter, img_pos.shape[2:], mode=\"bilinear\", align_corners=True).squeeze(0).detach().cpu()\n\n    return heatmap_intra, heatmap_inter\n\n\n@hydra.main(config_path=\"configs\", config_name=\"plot_config.yml\")\ndef my_app(cfg: DictConfig) -> None:\n    print(OmegaConf.to_yaml(cfg))\n    pytorch_data_dir = cfg.pytorch_data_dir\n    data_dir = join(cfg.output_root, \"data\")\n    log_dir = join(cfg.output_root, \"logs\")\n    result_dir = join(cfg.output_root, \"results\", \"correspondence\")\n    os.makedirs(data_dir, exist_ok=True)\n    os.makedirs(log_dir, exist_ok=True)\n    seed_everything(seed=0, workers=True)\n    high_res = 512\n\n    transform = get_transform(high_res, False, \"center\")\n    use_loader = True\n\n    if use_loader:\n        dataset = ContrastiveSegDataset(\n            pytorch_data_dir=pytorch_data_dir,\n            dataset_name=cfg.dataset_name,\n            crop_type=None,\n            image_set=\"train\",\n            transform=transform,\n            target_transform=get_transform(high_res, True, \"center\"),\n            cfg=cfg,\n            aug_geometric_transform=None,\n            aug_photometric_transform=None,\n            num_neighbors=2,\n            mask=True,\n            pos_images=True,\n            pos_labels=True,\n        )\n        loader = DataLoader(dataset, 16, shuffle=True, num_workers=cfg.num_workers)\n\n    data_dir = join(cfg.output_root, \"data\")\n    if cfg.arch == \"feature-pyramid\":\n        cut_model = load_model(cfg.model_type, data_dir).cuda()\n        net = FeaturePyramidNet(cfg.granularity, cut_model, cfg.dim, cfg.continuous)\n    elif cfg.arch == \"dino\":\n        net = DinoFeaturizer(cfg.dim, cfg)\n    else:\n        raise ValueError(\"Unknown arch {}\".format(cfg.arch))\n    net = net.cuda()\n\n    for batch_val in loader:\n        batch = batch_val\n        break\n\n    colors = [(1, 0, 0), (0, 1, 0), (0, 0, 1), (1, 1, 0)]\n    cmaps = [\n        ListedColormap([(1, 0, 0, i / 255) for i in range(255)]),\n        ListedColormap([(0, 1, 0, i / 255) for i in range(255)]),\n        ListedColormap([(0, 0, 1, i / 255) for i in range(255)]),\n        ListedColormap([(1, 1, 0, i / 255) for i in range(255)])\n    ]\n\n    with torch.no_grad():\n        if cfg.plot_correspondence:\n            img_num = 6\n            query_points = torch.tensor(\n                [\n                    [-.1, 0.0],\n                    [.5, .8],\n                    [-.7, -.7],\n                ]\n            ).reshape(1, 3, 1, 2).cuda()\n\n            img = batch[\"img\"][img_num:img_num + 1]\n            img_pos = batch[\"img_pos\"][img_num:img_num + 1]\n\n            plt.style.use('dark_background')\n            fig, axes = plt.subplots(1, 3, figsize=(3 * 5, 1 * 5), dpi=100)\n            remove_axes(axes)\n            axes[0].set_title(\"Image and Query Points\", fontsize=20)\n            axes[1].set_title(\"Self Correspondence\", fontsize=20)\n            axes[2].set_title(\"KNN Correspondence\", fontsize=20)\n            fig.tight_layout()\n\n            heatmap_intra, heatmap_inter = get_heatmaps(net, img, img_pos, query_points)\n            for point_num in range(query_points.shape[1]):\n                point = ((query_points[0, point_num, 0] + 1) / 2 * high_res).cpu()\n                img_point_h = point[0]\n                img_point_w = point[1]\n\n                plot_img = point_num == 0\n                if plot_img:\n                    axes[0].imshow(prep_for_plot(img[0]))\n                axes[0].scatter(img_point_h, img_point_w,\n                                c=colors[point_num], marker=\"x\", s=500, linewidths=5)\n\n                plot_heatmap(axes[1], prep_for_plot(img[0]) * .8, heatmap_intra[point_num],\n                             plot_img=plot_img, cmap=cmaps[point_num], symmetric=False)\n                plot_heatmap(axes[2], prep_for_plot(img_pos[0]) * .8, heatmap_inter[point_num],\n                             plot_img=plot_img, cmap=cmaps[point_num], symmetric=False)\n            plt.show()\n\n        if cfg.plot_movie:\n            img_num = 6\n            key_points = [\n                [-.7, -.7],\n                [-.1, 0.0],\n                [.5, .8],\n            ]\n            all_points = []\n            for i in range(len(key_points)):\n                all_points.extend([key_points[i]] * 60)\n\n                if i < len(key_points) - 1:\n                    all_points.extend(\n                        np.stack([\n                            np.linspace(key_points[i][0], key_points[i + 1][0], 50),\n                            np.linspace(key_points[i][1], key_points[i + 1][1], 50),\n                        ], axis=1).tolist())\n            query_points = torch.tensor(all_points).reshape(1, len(all_points), 1, 2).cuda()\n\n\n            plt.style.use('dark_background')\n            fig, axes = plt.subplots(1, 3, figsize=(3 * 5, 1 * 5), dpi=100)\n            remove_axes(axes)\n            axes[0].set_title(\"Image and Query Points\", fontsize=20)\n            axes[1].set_title(\"Self Correspondence\", fontsize=20)\n            axes[2].set_title(\"KNN Correspondence\", fontsize=20)\n\n            fig.tight_layout()\n\n            heatmap_intra, heatmap_inter = get_heatmaps(net, img, img_pos, query_points)\n\n            frames = []  # for storing the generated images\n            for point_num in range(query_points.shape[1]):\n                point = ((query_points[0, point_num, 0] + 1) / 2 * high_res).cpu()\n                img_point_h = point[0]\n                img_point_w = point[1]\n\n                frame = []\n\n                frame.append(axes[0].imshow(prep_for_plot(img[0])))\n\n                frame.extend([\n                    axes[0].scatter(img_point_h, img_point_w,\n                                    c=colors[0], marker=\"x\", s=400, linewidths=4),\n                    *plot_heatmap(axes[1], prep_for_plot(img[0]) * .8, heatmap_intra[point_num],\n                                  cmap=cmaps[0], symmetric=False),\n                    *plot_heatmap(axes[2], prep_for_plot(img_pos[0]) * .8, heatmap_inter[point_num],\n                                  cmap=cmaps[0], symmetric=False)\n                ])\n\n                frames.append(frame)\n\n            os.makedirs(result_dir, exist_ok=True)\n\n            with tqdm(total=len(frames)) as pbar:\n                animation.ArtistAnimation(fig, frames, blit=True).save(\n                    join(result_dir, 'attention_interp.mp4'),\n                    progress_callback=lambda i, n: pbar.update(),\n                    writer=animation.FFMpegWriter(fps=30))\n\n\nif __name__ == \"__main__\":\n    prep_args()\n    my_app()\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/plot_dino_correspondence.py b/src/plot_dino_correspondence.py
--- a/src/plot_dino_correspondence.py	(revision c6be305e586f39b07663cb9bdb535828fe4047df)
+++ b/src/plot_dino_correspondence.py	(date 1717584581529)
@@ -1,6 +1,6 @@
 import os
 from os.path import join
-from utils import get_transform, load_model, prep_for_plot, remove_axes, prep_args
+#from utils import get_transform, load_model, prep_for_plot, remove_axes, prep_args
 from modules import FeaturePyramidNet, DinoFeaturizer, sample
 from data import ContrastiveSegDataset
 import hydra
@@ -15,6 +15,9 @@
 from tqdm import tqdm
 from matplotlib.colors import ListedColormap
 
+from src import utils
+from src.utils import prep_for_plot, prep_args
+
 
 def plot_heatmap(ax, image, heatmap, cmap="bwr", color=False, plot_img=True, symmetric=True):
     vmax = np.abs(heatmap).max()
@@ -70,7 +73,7 @@
     seed_everything(seed=0, workers=True)
     high_res = 512
 
-    transform = get_transform(high_res, False, "center")
+    transform = utils.get_transform(high_res, False, "center")
     use_loader = True
 
     if use_loader:
@@ -80,7 +83,7 @@
             crop_type=None,
             image_set="train",
             transform=transform,
-            target_transform=get_transform(high_res, True, "center"),
+            target_transform=utils.get_transform(high_res, True, "center"),
             cfg=cfg,
             aug_geometric_transform=None,
             aug_photometric_transform=None,
@@ -93,7 +96,7 @@
 
     data_dir = join(cfg.output_root, "data")
     if cfg.arch == "feature-pyramid":
-        cut_model = load_model(cfg.model_type, data_dir).cuda()
+        cut_model = utils.load_model(cfg.model_type, data_dir).cuda()
         net = FeaturePyramidNet(cfg.granularity, cut_model, cfg.dim, cfg.continuous)
     elif cfg.arch == "dino":
         net = DinoFeaturizer(cfg.dim, cfg)
@@ -129,7 +132,7 @@
 
             plt.style.use('dark_background')
             fig, axes = plt.subplots(1, 3, figsize=(3 * 5, 1 * 5), dpi=100)
-            remove_axes(axes)
+            utils.remove_axes(axes)
             axes[0].set_title("Image and Query Points", fontsize=20)
             axes[1].set_title("Self Correspondence", fontsize=20)
             axes[2].set_title("KNN Correspondence", fontsize=20)
@@ -143,7 +146,7 @@
 
                 plot_img = point_num == 0
                 if plot_img:
-                    axes[0].imshow(prep_for_plot(img[0]))
+                    axes[0].imshow(utils.prep_for_plot(img[0]))
                 axes[0].scatter(img_point_h, img_point_w,
                                 c=colors[point_num], marker="x", s=500, linewidths=5)
 
@@ -175,7 +178,7 @@
 
             plt.style.use('dark_background')
             fig, axes = plt.subplots(1, 3, figsize=(3 * 5, 1 * 5), dpi=100)
-            remove_axes(axes)
+            utils.remove_axes(axes)
             axes[0].set_title("Image and Query Points", fontsize=20)
             axes[1].set_title("Self Correspondence", fontsize=20)
             axes[2].set_title("KNN Correspondence", fontsize=20)
Index: src/STEGO_Colab_Demo.ipynb
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>{\n \"cells\": [\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {\n    \"id\": \"JmPYsg-B49tM\"\n   },\n   \"source\": [\n    \"# Prepare Google Colab Environment\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 1,\n   \"metadata\": {\n    \"colab\": {\n     \"base_uri\": \"https://localhost:8080/\"\n    },\n    \"id\": \"GbkVr03HbnG4\",\n    \"outputId\": \"17fb7b43-ba13-4a58-d1b3-b2c538648651\"\n   },\n   \"outputs\": [\n    {\n     \"name\": \"stdout\",\n     \"output_type\": \"stream\",\n     \"text\": [\n      \"fatal: destination path 'STEGO' already exists and is not an empty directory.\\n\"\n     ]\n    }\n   ],\n   \"source\": [\n    \"!git clone https://github.com/mhamilton723/STEGO.git\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 2,\n   \"metadata\": {\n    \"colab\": {\n     \"base_uri\": \"https://localhost:8080/\",\n     \"height\": 1000\n    },\n    \"id\": \"Q4z1D5fOda3F\",\n    \"outputId\": \"d3f974df-63a6-4717-ed6a-4d37a1abac05\"\n   },\n   \"outputs\": [\n    {\n     \"name\": \"stdout\",\n     \"output_type\": \"stream\",\n     \"text\": [\n      \"Requirement already satisfied: wget in /home/endrit/anaconda3/lib/python3.10/site-packages (3.2)\\n\",\n      \"Requirement already satisfied: torchmetrics in /home/endrit/anaconda3/lib/python3.10/site-packages (0.11.4)\\n\",\n      \"Requirement already satisfied: packaging in /home/endrit/anaconda3/lib/python3.10/site-packages (from torchmetrics) (22.0)\\n\",\n      \"Requirement already satisfied: numpy>=1.17.2 in /home/endrit/anaconda3/lib/python3.10/site-packages (from torchmetrics) (1.23.5)\\n\",\n      \"Requirement already satisfied: torch>=1.8.1 in /home/endrit/anaconda3/lib/python3.10/site-packages (from torchmetrics) (1.12.1)\\n\",\n      \"Requirement already satisfied: typing_extensions in /home/endrit/anaconda3/lib/python3.10/site-packages (from torch>=1.8.1->torchmetrics) (4.4.0)\\n\",\n      \"Requirement already satisfied: hydra-core in /home/endrit/anaconda3/lib/python3.10/site-packages (1.3.2)\\n\",\n      \"Requirement already satisfied: antlr4-python3-runtime==4.9.* in /home/endrit/anaconda3/lib/python3.10/site-packages (from hydra-core) (4.9.3)\\n\",\n      \"Requirement already satisfied: packaging in /home/endrit/anaconda3/lib/python3.10/site-packages (from hydra-core) (22.0)\\n\",\n      \"Requirement already satisfied: omegaconf<2.4,>=2.2 in /home/endrit/anaconda3/lib/python3.10/site-packages (from hydra-core) (2.3.0)\\n\",\n      \"Requirement already satisfied: PyYAML>=5.1.0 in /home/endrit/anaconda3/lib/python3.10/site-packages (from omegaconf<2.4,>=2.2->hydra-core) (6.0)\\n\",\n      \"Collecting git+https://github.com/lucasb-eyer/pydensecrf.git\\n\",\n      \"  Cloning https://github.com/lucasb-eyer/pydensecrf.git to /tmp/pip-req-build-_1nblw2f\\n\",\n      \"  Running command git clone --filter=blob:none --quiet https://github.com/lucasb-eyer/pydensecrf.git /tmp/pip-req-build-_1nblw2f\\n\",\n      \"  Resolved https://github.com/lucasb-eyer/pydensecrf.git to commit 0d53acbcf5123d4c88040fe68fbb9805fc5b2fb9\\n\",\n      \"  Installing build dependencies ... \\u001b[?25ldone\\n\",\n      \"\\u001b[?25h  Getting requirements to build wheel ... \\u001b[?25ldone\\n\",\n      \"\\u001b[?25h  Preparing metadata (pyproject.toml) ... \\u001b[?25ldone\\n\",\n      \"\\u001b[?25hRequirement already satisfied: omegaconf in /home/endrit/anaconda3/lib/python3.10/site-packages (2.3.0)\\n\",\n      \"Requirement already satisfied: antlr4-python3-runtime==4.9.* in /home/endrit/anaconda3/lib/python3.10/site-packages (from omegaconf) (4.9.3)\\n\",\n      \"Requirement already satisfied: PyYAML>=5.1.0 in /home/endrit/anaconda3/lib/python3.10/site-packages (from omegaconf) (6.0)\\n\",\n      \"Requirement already satisfied: pytorch-lightning in /home/endrit/anaconda3/lib/python3.10/site-packages (2.0.2)\\n\",\n      \"Requirement already satisfied: fsspec[http]>2021.06.0 in /home/endrit/anaconda3/lib/python3.10/site-packages (from pytorch-lightning) (2022.11.0)\\n\",\n      \"Requirement already satisfied: lightning-utilities>=0.7.0 in /home/endrit/anaconda3/lib/python3.10/site-packages (from pytorch-lightning) (0.8.0)\\n\",\n      \"Requirement already satisfied: numpy>=1.17.2 in /home/endrit/anaconda3/lib/python3.10/site-packages (from pytorch-lightning) (1.23.5)\\n\",\n      \"Requirement already satisfied: torchmetrics>=0.7.0 in /home/endrit/anaconda3/lib/python3.10/site-packages (from pytorch-lightning) (0.11.4)\\n\",\n      \"Requirement already satisfied: PyYAML>=5.4 in /home/endrit/anaconda3/lib/python3.10/site-packages (from pytorch-lightning) (6.0)\\n\",\n      \"Requirement already satisfied: torch>=1.11.0 in /home/endrit/anaconda3/lib/python3.10/site-packages (from pytorch-lightning) (1.12.1)\\n\",\n      \"Requirement already satisfied: typing-extensions>=4.0.0 in /home/endrit/anaconda3/lib/python3.10/site-packages (from pytorch-lightning) (4.4.0)\\n\",\n      \"Requirement already satisfied: tqdm>=4.57.0 in /home/endrit/anaconda3/lib/python3.10/site-packages (from pytorch-lightning) (4.64.1)\\n\",\n      \"Requirement already satisfied: packaging>=17.1 in /home/endrit/anaconda3/lib/python3.10/site-packages (from pytorch-lightning) (22.0)\\n\",\n      \"Requirement already satisfied: requests in /home/endrit/anaconda3/lib/python3.10/site-packages (from fsspec[http]>2021.06.0->pytorch-lightning) (2.28.1)\\n\",\n      \"Requirement already satisfied: aiohttp!=4.0.0a0,!=4.0.0a1 in /home/endrit/anaconda3/lib/python3.10/site-packages (from fsspec[http]>2021.06.0->pytorch-lightning) (3.8.4)\\n\",\n      \"Requirement already satisfied: frozenlist>=1.1.1 in /home/endrit/anaconda3/lib/python3.10/site-packages (from aiohttp!=4.0.0a0,!=4.0.0a1->fsspec[http]>2021.06.0->pytorch-lightning) (1.3.3)\\n\",\n      \"Requirement already satisfied: charset-normalizer<4.0,>=2.0 in /home/endrit/anaconda3/lib/python3.10/site-packages (from aiohttp!=4.0.0a0,!=4.0.0a1->fsspec[http]>2021.06.0->pytorch-lightning) (2.0.4)\\n\",\n      \"Requirement already satisfied: yarl<2.0,>=1.0 in /home/endrit/anaconda3/lib/python3.10/site-packages (from aiohttp!=4.0.0a0,!=4.0.0a1->fsspec[http]>2021.06.0->pytorch-lightning) (1.9.2)\\n\",\n      \"Requirement already satisfied: attrs>=17.3.0 in /home/endrit/anaconda3/lib/python3.10/site-packages (from aiohttp!=4.0.0a0,!=4.0.0a1->fsspec[http]>2021.06.0->pytorch-lightning) (22.1.0)\\n\",\n      \"Requirement already satisfied: multidict<7.0,>=4.5 in /home/endrit/anaconda3/lib/python3.10/site-packages (from aiohttp!=4.0.0a0,!=4.0.0a1->fsspec[http]>2021.06.0->pytorch-lightning) (6.0.4)\\n\",\n      \"Requirement already satisfied: aiosignal>=1.1.2 in /home/endrit/anaconda3/lib/python3.10/site-packages (from aiohttp!=4.0.0a0,!=4.0.0a1->fsspec[http]>2021.06.0->pytorch-lightning) (1.3.1)\\n\",\n      \"Requirement already satisfied: async-timeout<5.0,>=4.0.0a3 in /home/endrit/anaconda3/lib/python3.10/site-packages (from aiohttp!=4.0.0a0,!=4.0.0a1->fsspec[http]>2021.06.0->pytorch-lightning) (4.0.2)\\n\",\n      \"Requirement already satisfied: certifi>=2017.4.17 in /home/endrit/anaconda3/lib/python3.10/site-packages (from requests->fsspec[http]>2021.06.0->pytorch-lightning) (2023.5.7)\\n\",\n      \"Requirement already satisfied: idna<4,>=2.5 in /home/endrit/anaconda3/lib/python3.10/site-packages (from requests->fsspec[http]>2021.06.0->pytorch-lightning) (3.4)\\n\",\n      \"Requirement already satisfied: urllib3<1.27,>=1.21.1 in /home/endrit/anaconda3/lib/python3.10/site-packages (from requests->fsspec[http]>2021.06.0->pytorch-lightning) (1.26.14)\\n\"\n     ]\n    }\n   ],\n   \"source\": [\n    \"!pip install wget\\n\",\n    \"!pip install torchmetrics\\n\",\n    \"!pip install hydra-core\\n\",\n    \"!pip install git+https://github.com/lucasb-eyer/pydensecrf.git\\n\",\n    \"!pip install omegaconf\\n\",\n    \"!pip install pytorch-lightning\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {\n    \"id\": \"N-CjEZdF5DSH\"\n   },\n   \"source\": [\n    \"# Download Pretrained Model\\n\",\n    \"\\n\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 3,\n   \"metadata\": {\n    \"id\": \"hJ_XE2xHcImN\"\n   },\n   \"outputs\": [],\n   \"source\": [\n    \"import os\\n\",\n    \"from os.path import join\\n\",\n    \"os.chdir(\\\"STEGO/src\\\")\\n\",\n    \"saved_models_dir = join(\\\"..\\\", \\\"saved_models\\\")\\n\",\n    \"os.makedirs(saved_models_dir, exist_ok=True)\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 4,\n   \"metadata\": {\n    \"id\": \"knywSO7IcNc2\"\n   },\n   \"outputs\": [],\n   \"source\": [\n    \"import wget\\n\",\n    \"saved_model_url_root = \\\"https://marhamilresearch4.blob.core.windows.net/stego-public/saved_models/\\\"\\n\",\n    \"saved_model_name = \\\"cocostuff27_vit_base_5.ckpt\\\"\\n\",\n    \"if not os.path.exists(join(saved_models_dir, saved_model_name)):\\n\",\n    \"  wget.download(saved_model_url_root + saved_model_name, join(saved_models_dir, saved_model_name))\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {\n    \"id\": \"rtwTZEkA7twI\"\n   },\n   \"source\": [\n    \"# Load pretrained STEGO\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 6,\n   \"metadata\": {\n    \"colab\": {\n     \"base_uri\": \"https://localhost:8080/\",\n     \"height\": 104,\n     \"referenced_widgets\": [\n      \"5fa05203c234442a8c863a51f83bac9d\",\n      \"7cf007c8f7a94bc292f8243391cea7ca\",\n      \"5fa6b3215e01491d9534feadee79f706\",\n      \"41d2dacf744d4ecaa1f51174a6703334\",\n      \"d5faaf8d200a4bbf9c1e9677af8fe257\",\n      \"aeb7614c4d7e41eeab603a70fc80ed6a\",\n      \"41986d51df5b41d79187acaebafe3008\",\n      \"e2ad8a86c24c419581c204fd2ae2ba18\",\n      \"811c526bd6154969b7028307dcafd550\",\n      \"2d1d907c0d04492097e35a9ceddea9a2\",\n      \"6de033864a1b4397a93147091aedda65\"\n     ]\n    },\n    \"id\": \"RyBXeiGjdN8I\",\n    \"outputId\": \"33ae5c14-857a-48d5-cd4b-803daf82c326\"\n   },\n   \"outputs\": [\n    {\n     \"name\": \"stdout\",\n     \"output_type\": \"stream\",\n     \"text\": [\n      \"Collecting torchvision\\n\",\n      \"  Downloading torchvision-0.15.2-cp310-cp310-manylinux1_x86_64.whl (6.0 MB)\\n\",\n      \"\\u001b[2K     \\u001b[38;2;114;156;31m\\u001b[0m \\u001b[32m6.0/6.0 MB\\u001b[0m \\u001b[31m4.9 MB/s\\u001b[0m eta \\u001b[36m0:00:00\\u001b[0mm eta \\u001b[36m0:00:01\\u001b[0m[36m0:00:01\\u001b[0m\\n\",\n      \"\\u001b[?25hRequirement already satisfied: requests in /home/endrit/anaconda3/lib/python3.10/site-packages (from torchvision) (2.28.1)\\n\",\n      \"Requirement already satisfied: pillow!=8.3.*,>=5.3.0 in /home/endrit/anaconda3/lib/python3.10/site-packages (from torchvision) (9.4.0)\\n\",\n      \"Collecting torch==2.0.1\\n\",\n      \"  Downloading torch-2.0.1-cp310-cp310-manylinux1_x86_64.whl (619.9 MB)\\n\",\n      \"\\u001b[2K     \\u001b[38;2;114;156;31m\\u001b[0m \\u001b[32m619.9/619.9 MB\\u001b[0m \\u001b[31m1.6 MB/s\\u001b[0m eta \\u001b[36m0:00:00\\u001b[0mm eta \\u001b[36m0:00:01\\u001b[0m[36m0:00:06\\u001b[0m\\n\",\n      \"\\u001b[?25hRequirement already satisfied: numpy in /home/endrit/anaconda3/lib/python3.10/site-packages (from torchvision) (1.23.5)\\n\",\n      \"Requirement already satisfied: sympy in /home/endrit/anaconda3/lib/python3.10/site-packages (from torch==2.0.1->torchvision) (1.11.1)\\n\",\n      \"Collecting nvidia-nccl-cu11==2.14.3\\n\",\n      \"  Downloading nvidia_nccl_cu11-2.14.3-py3-none-manylinux1_x86_64.whl (177.1 MB)\\n\",\n      \"\\u001b[2K     \\u001b[38;2;114;156;31m\\u001b[0m \\u001b[32m177.1/177.1 MB\\u001b[0m \\u001b[31m3.5 MB/s\\u001b[0m eta \\u001b[36m0:00:00\\u001b[0mm eta \\u001b[36m0:00:01\\u001b[0m[36m0:00:01\\u001b[0m\\n\",\n      \"\\u001b[?25hRequirement already satisfied: jinja2 in /home/endrit/anaconda3/lib/python3.10/site-packages (from torch==2.0.1->torchvision) (3.1.2)\\n\",\n      \"Requirement already satisfied: filelock in /home/endrit/anaconda3/lib/python3.10/site-packages (from torch==2.0.1->torchvision) (3.9.0)\\n\",\n      \"Collecting nvidia-cuda-runtime-cu11==11.7.99\\n\",\n      \"  Downloading nvidia_cuda_runtime_cu11-11.7.99-py3-none-manylinux1_x86_64.whl (849 kB)\\n\",\n      \"\\u001b[2K     \\u001b[38;2;114;156;31m\\u001b[0m \\u001b[32m849.3/849.3 kB\\u001b[0m \\u001b[31m6.5 MB/s\\u001b[0m eta \\u001b[36m0:00:00\\u001b[0m[31m8.8 MB/s\\u001b[0m eta \\u001b[36m0:00:01\\u001b[0m\\n\",\n      \"\\u001b[?25hCollecting nvidia-cufft-cu11==10.9.0.58\\n\",\n      \"  Downloading nvidia_cufft_cu11-10.9.0.58-py3-none-manylinux1_x86_64.whl (168.4 MB)\\n\",\n      \"\\u001b[2K     \\u001b[38;2;114;156;31m\\u001b[0m \\u001b[32m168.4/168.4 MB\\u001b[0m \\u001b[31m3.6 MB/s\\u001b[0m eta \\u001b[36m0:00:00\\u001b[0mm eta \\u001b[36m0:00:01\\u001b[0m[36m0:00:01\\u001b[0m\\n\",\n      \"\\u001b[?25hCollecting nvidia-cusolver-cu11==11.4.0.1\\n\",\n      \"  Downloading nvidia_cusolver_cu11-11.4.0.1-2-py3-none-manylinux1_x86_64.whl (102.6 MB)\\n\",\n      \"\\u001b[2K     \\u001b[38;2;114;156;31m\\u001b[0m \\u001b[32m102.6/102.6 MB\\u001b[0m \\u001b[31m3.9 MB/s\\u001b[0m eta \\u001b[36m0:00:00\\u001b[0mm eta \\u001b[36m0:00:01\\u001b[0m[36m0:00:01\\u001b[0m\\n\",\n      \"\\u001b[?25hRequirement already satisfied: networkx in /home/endrit/anaconda3/lib/python3.10/site-packages (from torch==2.0.1->torchvision) (2.8.4)\\n\",\n      \"Collecting nvidia-cusparse-cu11==11.7.4.91\\n\",\n      \"  Downloading nvidia_cusparse_cu11-11.7.4.91-py3-none-manylinux1_x86_64.whl (173.2 MB)\\n\",\n      \"\\u001b[2K     \\u001b[38;2;114;156;31m\\u001b[0m \\u001b[32m173.2/173.2 MB\\u001b[0m \\u001b[31m3.1 MB/s\\u001b[0m eta \\u001b[36m0:00:00\\u001b[0mm eta \\u001b[36m0:00:01\\u001b[0m[36m0:00:01\\u001b[0m\\n\",\n      \"\\u001b[?25hCollecting nvidia-curand-cu11==10.2.10.91\\n\",\n      \"  Downloading nvidia_curand_cu11-10.2.10.91-py3-none-manylinux1_x86_64.whl (54.6 MB)\\n\",\n      \"\\u001b[2K     \\u001b[38;2;114;156;31m\\u001b[0m \\u001b[32m54.6/54.6 MB\\u001b[0m \\u001b[31m4.4 MB/s\\u001b[0m eta \\u001b[36m0:00:00\\u001b[0mm eta \\u001b[36m0:00:01\\u001b[0m[36m0:00:01\\u001b[0m\\n\",\n      \"\\u001b[?25hCollecting nvidia-nvtx-cu11==11.7.91\\n\",\n      \"  Downloading nvidia_nvtx_cu11-11.7.91-py3-none-manylinux1_x86_64.whl (98 kB)\\n\",\n      \"\\u001b[2K     \\u001b[38;2;114;156;31m\\u001b[0m \\u001b[32m98.6/98.6 kB\\u001b[0m \\u001b[31m5.0 MB/s\\u001b[0m eta \\u001b[36m0:00:00\\u001b[0m\\n\",\n      \"\\u001b[?25hRequirement already satisfied: typing-extensions in /home/endrit/anaconda3/lib/python3.10/site-packages (from torch==2.0.1->torchvision) (4.4.0)\\n\",\n      \"Collecting nvidia-cublas-cu11==11.10.3.66\\n\",\n      \"  Downloading nvidia_cublas_cu11-11.10.3.66-py3-none-manylinux1_x86_64.whl (317.1 MB)\\n\",\n      \"\\u001b[2K     \\u001b[38;2;114;156;31m\\u001b[0m \\u001b[32m317.1/317.1 MB\\u001b[0m \\u001b[31m1.4 MB/s\\u001b[0m eta \\u001b[36m0:00:00\\u001b[0mm eta \\u001b[36m0:00:01\\u001b[0m[36m0:00:05\\u001b[0m\\n\",\n      \"\\u001b[?25hCollecting nvidia-cuda-cupti-cu11==11.7.101\\n\",\n      \"  Downloading nvidia_cuda_cupti_cu11-11.7.101-py3-none-manylinux1_x86_64.whl (11.8 MB)\\n\",\n      \"\\u001b[2K     \\u001b[38;2;114;156;31m\\u001b[0m \\u001b[32m11.8/11.8 MB\\u001b[0m \\u001b[31m1.7 MB/s\\u001b[0m eta \\u001b[36m0:00:00\\u001b[0mm eta \\u001b[36m0:00:01\\u001b[0m0:01\\u001b[0m:01\\u001b[0m\\n\",\n      \"\\u001b[?25hCollecting nvidia-cuda-nvrtc-cu11==11.7.99\\n\",\n      \"  Downloading nvidia_cuda_nvrtc_cu11-11.7.99-2-py3-none-manylinux1_x86_64.whl (21.0 MB)\\n\",\n      \"\\u001b[2K     \\u001b[38;2;114;156;31m\\u001b[0m \\u001b[32m21.0/21.0 MB\\u001b[0m \\u001b[31m1.8 MB/s\\u001b[0m eta \\u001b[36m0:00:00\\u001b[0mm eta \\u001b[36m0:00:01\\u001b[0m[36m0:00:01\\u001b[0m\\n\",\n      \"\\u001b[?25hCollecting triton==2.0.0\\n\",\n      \"  Downloading triton-2.0.0-1-cp310-cp310-manylinux2014_x86_64.manylinux_2_17_x86_64.whl (63.3 MB)\\n\",\n      \"\\u001b[2K     \\u001b[38;2;114;156;31m\\u001b[0m \\u001b[32m63.3/63.3 MB\\u001b[0m \\u001b[31m4.7 MB/s\\u001b[0m eta \\u001b[36m0:00:00\\u001b[0mm eta \\u001b[36m0:00:01\\u001b[0m[36m0:00:01\\u001b[0m\\n\",\n      \"\\u001b[?25hCollecting nvidia-cudnn-cu11==8.5.0.96\\n\",\n      \"  Downloading nvidia_cudnn_cu11-8.5.0.96-2-py3-none-manylinux1_x86_64.whl (557.1 MB)\\n\",\n      \"\\u001b[2K     \\u001b[38;2;114;156;31m\\u001b[0m \\u001b[32m557.1/557.1 MB\\u001b[0m \\u001b[31m1.9 MB/s\\u001b[0m eta \\u001b[36m0:00:00\\u001b[0mm eta \\u001b[36m0:00:01\\u001b[0m[36m0:00:03\\u001b[0m\\n\",\n      \"\\u001b[?25hRequirement already satisfied: wheel in /home/endrit/anaconda3/lib/python3.10/site-packages (from nvidia-cublas-cu11==11.10.3.66->torch==2.0.1->torchvision) (0.38.4)\\n\",\n      \"Requirement already satisfied: setuptools in /home/endrit/anaconda3/lib/python3.10/site-packages (from nvidia-cublas-cu11==11.10.3.66->torch==2.0.1->torchvision) (65.6.3)\\n\",\n      \"Collecting cmake\\n\",\n      \"  Downloading cmake-3.26.3-py2.py3-none-manylinux2014_x86_64.manylinux_2_17_x86_64.whl (24.0 MB)\\n\",\n      \"\\u001b[2K     \\u001b[38;2;114;156;31m\\u001b[0m \\u001b[32m24.0/24.0 MB\\u001b[0m \\u001b[31m4.6 MB/s\\u001b[0m eta \\u001b[36m0:00:00\\u001b[0mm eta \\u001b[36m0:00:01\\u001b[0m[36m0:00:01\\u001b[0m\\n\",\n      \"\\u001b[?25hCollecting lit\\n\",\n      \"  Downloading lit-16.0.5.tar.gz (138 kB)\\n\",\n      \"\\u001b[2K     \\u001b[38;2;114;156;31m\\u001b[0m \\u001b[32m138.0/138.0 kB\\u001b[0m \\u001b[31m2.4 MB/s\\u001b[0m eta \\u001b[36m0:00:00\\u001b[0m[31m5.8 MB/s\\u001b[0m eta \\u001b[36m0:00:01\\u001b[0m\\n\",\n      \"\\u001b[?25h  Preparing metadata (setup.py) ... \\u001b[?25ldone\\n\",\n      \"\\u001b[?25hRequirement already satisfied: certifi>=2017.4.17 in /home/endrit/anaconda3/lib/python3.10/site-packages (from requests->torchvision) (2023.5.7)\\n\",\n      \"Requirement already satisfied: urllib3<1.27,>=1.21.1 in /home/endrit/anaconda3/lib/python3.10/site-packages (from requests->torchvision) (1.26.14)\\n\",\n      \"Requirement already satisfied: idna<4,>=2.5 in /home/endrit/anaconda3/lib/python3.10/site-packages (from requests->torchvision) (3.4)\\n\",\n      \"Requirement already satisfied: charset-normalizer<3,>=2 in /home/endrit/anaconda3/lib/python3.10/site-packages (from requests->torchvision) (2.0.4)\\n\",\n      \"Requirement already satisfied: MarkupSafe>=2.0 in /home/endrit/anaconda3/lib/python3.10/site-packages (from jinja2->torch==2.0.1->torchvision) (2.1.1)\\n\",\n      \"Requirement already satisfied: mpmath>=0.19 in /home/endrit/anaconda3/lib/python3.10/site-packages/mpmath-1.2.1-py3.10.egg (from sympy->torch==2.0.1->torchvision) (1.2.1)\\n\",\n      \"Building wheels for collected packages: lit\\n\",\n      \"  Building wheel for lit (setup.py) ... \\u001b[?25ldone\\n\",\n      \"\\u001b[?25h  Created wheel for lit: filename=lit-16.0.5-py3-none-any.whl size=88174 sha256=0b4ccc2d83d9043a5b23e1ca8facc4c4a5de200861cac9f8edfdc256e75925ad\\n\",\n      \"  Stored in directory: /home/endrit/.cache/pip/wheels/eb/02/84/d82f0b1a6098209edf7e3607be6cc592ebbc015a8a3127c68d\\n\",\n      \"Successfully built lit\\n\",\n      \"Installing collected packages: lit, cmake, nvidia-nvtx-cu11, nvidia-nccl-cu11, nvidia-cusparse-cu11, nvidia-curand-cu11, nvidia-cufft-cu11, nvidia-cuda-runtime-cu11, nvidia-cuda-nvrtc-cu11, nvidia-cuda-cupti-cu11, nvidia-cublas-cu11, nvidia-cusolver-cu11, nvidia-cudnn-cu11, triton, torch, torchvision\\n\",\n      \"  Attempting uninstall: torch\\n\",\n      \"    Found existing installation: torch 1.12.1\\n\",\n      \"    Uninstalling torch-1.12.1:\\n\",\n      \"      Successfully uninstalled torch-1.12.1\\n\",\n      \"Successfully installed cmake-3.26.3 lit-16.0.5 nvidia-cublas-cu11-11.10.3.66 nvidia-cuda-cupti-cu11-11.7.101 nvidia-cuda-nvrtc-cu11-11.7.99 nvidia-cuda-runtime-cu11-11.7.99 nvidia-cudnn-cu11-8.5.0.96 nvidia-cufft-cu11-10.9.0.58 nvidia-curand-cu11-10.2.10.91 nvidia-cusolver-cu11-11.4.0.1 nvidia-cusparse-cu11-11.7.4.91 nvidia-nccl-cu11-2.14.3 nvidia-nvtx-cu11-11.7.91 torch-2.0.1 torchvision-0.15.2 triton-2.0.0\\n\"\n     ]\n    },\n    {\n     \"name\": \"stderr\",\n     \"output_type\": \"stream\",\n     \"text\": [\n      \"/home/endrit/anaconda3/lib/python3.10/site-packages/torchvision/io/image.py:13: UserWarning: Failed to load image Python extension: 'libc10_cuda.so: cannot open shared object file: No such file or directory'If you don't plan on using image functionality from `torchvision.io`, you can ignore this warning. Otherwise, there might be something wrong with your environment. Did you have `libjpeg` or `libpng` installed before building `torchvision` from source?\\n\",\n      \"  warn(\\n\"\n     ]\n    },\n    {\n     \"ename\": \"ImportError\",\n     \"evalue\": \"cannot import name '_get_cpp_backtrace' from 'torch._C' (/home/endrit/anaconda3/lib/python3.10/site-packages/torch/_C.cpython-310-x86_64-linux-gnu.so)\",\n     \"output_type\": \"error\",\n     \"traceback\": [\n      \"\\u001b[0;31m---------------------------------------------------------------------------\\u001b[0m\",\n      \"\\u001b[0;31mImportError\\u001b[0m                               Traceback (most recent call last)\",\n      \"Cell \\u001b[0;32mIn[6], line 2\\u001b[0m\\n\\u001b[1;32m      1\\u001b[0m get_ipython()\\u001b[38;5;241m.\\u001b[39msystem(\\u001b[38;5;124m'\\u001b[39m\\u001b[38;5;124mpip install torchvision\\u001b[39m\\u001b[38;5;124m'\\u001b[39m)\\n\\u001b[0;32m----> 2\\u001b[0m \\u001b[38;5;28;01mfrom\\u001b[39;00m \\u001b[38;5;21;01mtrain_segmentation\\u001b[39;00m \\u001b[38;5;28;01mimport\\u001b[39;00m LitUnsupervisedSegmenter\\n\\u001b[1;32m      4\\u001b[0m model \\u001b[38;5;241m=\\u001b[39m LitUnsupervisedSegmenter\\u001b[38;5;241m.\\u001b[39mload_from_checkpoint(join(saved_models_dir, saved_model_name))\\u001b[38;5;241m.\\u001b[39mcuda()\\n\",\n      \"File \\u001b[0;32m~/STEGO/src/train_segmentation.py:1\\u001b[0m\\n\\u001b[0;32m----> 1\\u001b[0m \\u001b[38;5;28;01mfrom\\u001b[39;00m \\u001b[38;5;21;01mutils\\u001b[39;00m \\u001b[38;5;28;01mimport\\u001b[39;00m \\u001b[38;5;241m*\\u001b[39m\\n\\u001b[1;32m      2\\u001b[0m \\u001b[38;5;28;01mfrom\\u001b[39;00m \\u001b[38;5;21;01mmodules\\u001b[39;00m \\u001b[38;5;28;01mimport\\u001b[39;00m \\u001b[38;5;241m*\\u001b[39m\\n\\u001b[1;32m      3\\u001b[0m \\u001b[38;5;28;01mfrom\\u001b[39;00m \\u001b[38;5;21;01mdata\\u001b[39;00m \\u001b[38;5;28;01mimport\\u001b[39;00m \\u001b[38;5;241m*\\u001b[39m\\n\",\n      \"File \\u001b[0;32m~/STEGO/src/utils.py:18\\u001b[0m\\n\\u001b[1;32m     16\\u001b[0m \\u001b[38;5;28;01mfrom\\u001b[39;00m \\u001b[38;5;21;01mtorch\\u001b[39;00m\\u001b[38;5;21;01m.\\u001b[39;00m\\u001b[38;5;21;01mutils\\u001b[39;00m\\u001b[38;5;21;01m.\\u001b[39;00m\\u001b[38;5;21;01mdata\\u001b[39;00m\\u001b[38;5;21;01m.\\u001b[39;00m\\u001b[38;5;21;01m_utils\\u001b[39;00m\\u001b[38;5;21;01m.\\u001b[39;00m\\u001b[38;5;21;01mcollate\\u001b[39;00m \\u001b[38;5;28;01mimport\\u001b[39;00m np_str_obj_array_pattern, default_collate_err_msg_format\\n\\u001b[1;32m     17\\u001b[0m \\u001b[38;5;28;01mfrom\\u001b[39;00m \\u001b[38;5;21;01mtorchmetrics\\u001b[39;00m \\u001b[38;5;28;01mimport\\u001b[39;00m Metric\\n\\u001b[0;32m---> 18\\u001b[0m \\u001b[38;5;28;01mfrom\\u001b[39;00m \\u001b[38;5;21;01mtorchvision\\u001b[39;00m \\u001b[38;5;28;01mimport\\u001b[39;00m models\\n\\u001b[1;32m     19\\u001b[0m \\u001b[38;5;28;01mfrom\\u001b[39;00m \\u001b[38;5;21;01mtorchvision\\u001b[39;00m \\u001b[38;5;28;01mimport\\u001b[39;00m transforms \\u001b[38;5;28;01mas\\u001b[39;00m T\\n\\u001b[1;32m     20\\u001b[0m \\u001b[38;5;28;01mfrom\\u001b[39;00m \\u001b[38;5;21;01mtorch\\u001b[39;00m\\u001b[38;5;21;01m.\\u001b[39;00m\\u001b[38;5;21;01mutils\\u001b[39;00m\\u001b[38;5;21;01m.\\u001b[39;00m\\u001b[38;5;21;01mtensorboard\\u001b[39;00m\\u001b[38;5;21;01m.\\u001b[39;00m\\u001b[38;5;21;01msummary\\u001b[39;00m \\u001b[38;5;28;01mimport\\u001b[39;00m hparams\\n\",\n      \"File \\u001b[0;32m~/anaconda3/lib/python3.10/site-packages/torchvision/__init__.py:6\\u001b[0m\\n\\u001b[1;32m      3\\u001b[0m \\u001b[38;5;28;01mfrom\\u001b[39;00m \\u001b[38;5;21;01mmodulefinder\\u001b[39;00m \\u001b[38;5;28;01mimport\\u001b[39;00m Module\\n\\u001b[1;32m      5\\u001b[0m \\u001b[38;5;28;01mimport\\u001b[39;00m \\u001b[38;5;21;01mtorch\\u001b[39;00m\\n\\u001b[0;32m----> 6\\u001b[0m \\u001b[38;5;28;01mfrom\\u001b[39;00m \\u001b[38;5;21;01mtorchvision\\u001b[39;00m \\u001b[38;5;28;01mimport\\u001b[39;00m datasets, io, models, ops, transforms, utils\\n\\u001b[1;32m      8\\u001b[0m \\u001b[38;5;28;01mfrom\\u001b[39;00m \\u001b[38;5;21;01m.\\u001b[39;00m\\u001b[38;5;21;01mextension\\u001b[39;00m \\u001b[38;5;28;01mimport\\u001b[39;00m _HAS_OPS\\n\\u001b[1;32m     10\\u001b[0m \\u001b[38;5;28;01mtry\\u001b[39;00m:\\n\",\n      \"File \\u001b[0;32m~/anaconda3/lib/python3.10/site-packages/torchvision/models/__init__.py:2\\u001b[0m\\n\\u001b[1;32m      1\\u001b[0m \\u001b[38;5;28;01mfrom\\u001b[39;00m \\u001b[38;5;21;01m.\\u001b[39;00m\\u001b[38;5;21;01malexnet\\u001b[39;00m \\u001b[38;5;28;01mimport\\u001b[39;00m \\u001b[38;5;241m*\\u001b[39m\\n\\u001b[0;32m----> 2\\u001b[0m \\u001b[38;5;28;01mfrom\\u001b[39;00m \\u001b[38;5;21;01m.\\u001b[39;00m\\u001b[38;5;21;01mconvnext\\u001b[39;00m \\u001b[38;5;28;01mimport\\u001b[39;00m \\u001b[38;5;241m*\\u001b[39m\\n\\u001b[1;32m      3\\u001b[0m \\u001b[38;5;28;01mfrom\\u001b[39;00m \\u001b[38;5;21;01m.\\u001b[39;00m\\u001b[38;5;21;01mdensenet\\u001b[39;00m \\u001b[38;5;28;01mimport\\u001b[39;00m \\u001b[38;5;241m*\\u001b[39m\\n\\u001b[1;32m      4\\u001b[0m \\u001b[38;5;28;01mfrom\\u001b[39;00m \\u001b[38;5;21;01m.\\u001b[39;00m\\u001b[38;5;21;01mefficientnet\\u001b[39;00m \\u001b[38;5;28;01mimport\\u001b[39;00m \\u001b[38;5;241m*\\u001b[39m\\n\",\n      \"File \\u001b[0;32m~/anaconda3/lib/python3.10/site-packages/torchvision/models/convnext.py:8\\u001b[0m\\n\\u001b[1;32m      5\\u001b[0m \\u001b[38;5;28;01mfrom\\u001b[39;00m \\u001b[38;5;21;01mtorch\\u001b[39;00m \\u001b[38;5;28;01mimport\\u001b[39;00m nn, Tensor\\n\\u001b[1;32m      6\\u001b[0m \\u001b[38;5;28;01mfrom\\u001b[39;00m \\u001b[38;5;21;01mtorch\\u001b[39;00m\\u001b[38;5;21;01m.\\u001b[39;00m\\u001b[38;5;21;01mnn\\u001b[39;00m \\u001b[38;5;28;01mimport\\u001b[39;00m functional \\u001b[38;5;28;01mas\\u001b[39;00m F\\n\\u001b[0;32m----> 8\\u001b[0m \\u001b[38;5;28;01mfrom\\u001b[39;00m \\u001b[38;5;21;01m.\\u001b[39;00m\\u001b[38;5;21;01m.\\u001b[39;00m\\u001b[38;5;21;01mops\\u001b[39;00m\\u001b[38;5;21;01m.\\u001b[39;00m\\u001b[38;5;21;01mmisc\\u001b[39;00m \\u001b[38;5;28;01mimport\\u001b[39;00m Conv2dNormActivation, Permute\\n\\u001b[1;32m      9\\u001b[0m \\u001b[38;5;28;01mfrom\\u001b[39;00m \\u001b[38;5;21;01m.\\u001b[39;00m\\u001b[38;5;21;01m.\\u001b[39;00m\\u001b[38;5;21;01mops\\u001b[39;00m\\u001b[38;5;21;01m.\\u001b[39;00m\\u001b[38;5;21;01mstochastic_depth\\u001b[39;00m \\u001b[38;5;28;01mimport\\u001b[39;00m StochasticDepth\\n\\u001b[1;32m     10\\u001b[0m \\u001b[38;5;28;01mfrom\\u001b[39;00m \\u001b[38;5;21;01m.\\u001b[39;00m\\u001b[38;5;21;01m.\\u001b[39;00m\\u001b[38;5;21;01mtransforms\\u001b[39;00m\\u001b[38;5;21;01m.\\u001b[39;00m\\u001b[38;5;21;01m_presets\\u001b[39;00m \\u001b[38;5;28;01mimport\\u001b[39;00m ImageClassification\\n\",\n      \"File \\u001b[0;32m~/anaconda3/lib/python3.10/site-packages/torchvision/ops/__init__.py:1\\u001b[0m\\n\\u001b[0;32m----> 1\\u001b[0m \\u001b[38;5;28;01mfrom\\u001b[39;00m \\u001b[38;5;21;01m.\\u001b[39;00m\\u001b[38;5;21;01m_register_onnx_ops\\u001b[39;00m \\u001b[38;5;28;01mimport\\u001b[39;00m _register_custom_op\\n\\u001b[1;32m      2\\u001b[0m \\u001b[38;5;28;01mfrom\\u001b[39;00m \\u001b[38;5;21;01m.\\u001b[39;00m\\u001b[38;5;21;01mboxes\\u001b[39;00m \\u001b[38;5;28;01mimport\\u001b[39;00m (\\n\\u001b[1;32m      3\\u001b[0m     batched_nms,\\n\\u001b[1;32m      4\\u001b[0m     box_area,\\n\\u001b[0;32m   (...)\\u001b[0m\\n\\u001b[1;32m     13\\u001b[0m     remove_small_boxes,\\n\\u001b[1;32m     14\\u001b[0m )\\n\\u001b[1;32m     15\\u001b[0m \\u001b[38;5;28;01mfrom\\u001b[39;00m \\u001b[38;5;21;01m.\\u001b[39;00m\\u001b[38;5;21;01mciou_loss\\u001b[39;00m \\u001b[38;5;28;01mimport\\u001b[39;00m complete_box_iou_loss\\n\",\n      \"File \\u001b[0;32m~/anaconda3/lib/python3.10/site-packages/torchvision/ops/_register_onnx_ops.py:5\\u001b[0m\\n\\u001b[1;32m      2\\u001b[0m \\u001b[38;5;28;01mimport\\u001b[39;00m \\u001b[38;5;21;01mwarnings\\u001b[39;00m\\n\\u001b[1;32m      4\\u001b[0m \\u001b[38;5;28;01mimport\\u001b[39;00m \\u001b[38;5;21;01mtorch\\u001b[39;00m\\n\\u001b[0;32m----> 5\\u001b[0m \\u001b[38;5;28;01mfrom\\u001b[39;00m \\u001b[38;5;21;01mtorch\\u001b[39;00m\\u001b[38;5;21;01m.\\u001b[39;00m\\u001b[38;5;21;01monnx\\u001b[39;00m \\u001b[38;5;28;01mimport\\u001b[39;00m symbolic_opset11 \\u001b[38;5;28;01mas\\u001b[39;00m opset11\\n\\u001b[1;32m      6\\u001b[0m \\u001b[38;5;28;01mfrom\\u001b[39;00m \\u001b[38;5;21;01mtorch\\u001b[39;00m\\u001b[38;5;21;01m.\\u001b[39;00m\\u001b[38;5;21;01monnx\\u001b[39;00m\\u001b[38;5;21;01m.\\u001b[39;00m\\u001b[38;5;21;01msymbolic_helper\\u001b[39;00m \\u001b[38;5;28;01mimport\\u001b[39;00m parse_args\\n\\u001b[1;32m      8\\u001b[0m _ONNX_OPSET_VERSION_11 \\u001b[38;5;241m=\\u001b[39m \\u001b[38;5;241m11\\u001b[39m\\n\",\n      \"File \\u001b[0;32m~/anaconda3/lib/python3.10/site-packages/torch/onnx/symbolic_opset11.py:12\\u001b[0m\\n\\u001b[1;32m     10\\u001b[0m \\u001b[38;5;28;01mfrom\\u001b[39;00m \\u001b[38;5;21;01mtorch\\u001b[39;00m \\u001b[38;5;28;01mimport\\u001b[39;00m _C\\n\\u001b[1;32m     11\\u001b[0m \\u001b[38;5;28;01mfrom\\u001b[39;00m \\u001b[38;5;21;01mtorch\\u001b[39;00m\\u001b[38;5;21;01m.\\u001b[39;00m\\u001b[38;5;21;01m_C\\u001b[39;00m \\u001b[38;5;28;01mimport\\u001b[39;00m _onnx \\u001b[38;5;28;01mas\\u001b[39;00m _C_onnx\\n\\u001b[0;32m---> 12\\u001b[0m \\u001b[38;5;28;01mfrom\\u001b[39;00m \\u001b[38;5;21;01mtorch\\u001b[39;00m\\u001b[38;5;21;01m.\\u001b[39;00m\\u001b[38;5;21;01monnx\\u001b[39;00m \\u001b[38;5;28;01mimport\\u001b[39;00m (\\n\\u001b[1;32m     13\\u001b[0m     _type_utils,\\n\\u001b[1;32m     14\\u001b[0m     errors,\\n\\u001b[1;32m     15\\u001b[0m     symbolic_helper,\\n\\u001b[1;32m     16\\u001b[0m     symbolic_opset10 \\u001b[38;5;28;01mas\\u001b[39;00m opset10,\\n\\u001b[1;32m     17\\u001b[0m     symbolic_opset9 \\u001b[38;5;28;01mas\\u001b[39;00m opset9,\\n\\u001b[1;32m     18\\u001b[0m     utils,\\n\\u001b[1;32m     19\\u001b[0m )\\n\\u001b[1;32m     20\\u001b[0m \\u001b[38;5;28;01mfrom\\u001b[39;00m \\u001b[38;5;21;01mtorch\\u001b[39;00m\\u001b[38;5;21;01m.\\u001b[39;00m\\u001b[38;5;21;01monnx\\u001b[39;00m\\u001b[38;5;21;01m.\\u001b[39;00m\\u001b[38;5;21;01m_globals\\u001b[39;00m \\u001b[38;5;28;01mimport\\u001b[39;00m GLOBALS\\n\\u001b[1;32m     21\\u001b[0m \\u001b[38;5;28;01mfrom\\u001b[39;00m \\u001b[38;5;21;01mtorch\\u001b[39;00m\\u001b[38;5;21;01m.\\u001b[39;00m\\u001b[38;5;21;01monnx\\u001b[39;00m\\u001b[38;5;21;01m.\\u001b[39;00m\\u001b[38;5;21;01m_internal\\u001b[39;00m \\u001b[38;5;28;01mimport\\u001b[39;00m _beartype, jit_utils, registration\\n\",\n      \"File \\u001b[0;32m~/anaconda3/lib/python3.10/site-packages/torch/onnx/_type_utils.py:10\\u001b[0m\\n\\u001b[1;32m      8\\u001b[0m \\u001b[38;5;28;01mimport\\u001b[39;00m \\u001b[38;5;21;01mtorch\\u001b[39;00m\\n\\u001b[1;32m      9\\u001b[0m \\u001b[38;5;28;01mfrom\\u001b[39;00m \\u001b[38;5;21;01mtorch\\u001b[39;00m\\u001b[38;5;21;01m.\\u001b[39;00m\\u001b[38;5;21;01m_C\\u001b[39;00m \\u001b[38;5;28;01mimport\\u001b[39;00m _onnx \\u001b[38;5;28;01mas\\u001b[39;00m _C_onnx\\n\\u001b[0;32m---> 10\\u001b[0m \\u001b[38;5;28;01mfrom\\u001b[39;00m \\u001b[38;5;21;01mtorch\\u001b[39;00m\\u001b[38;5;21;01m.\\u001b[39;00m\\u001b[38;5;21;01monnx\\u001b[39;00m \\u001b[38;5;28;01mimport\\u001b[39;00m errors\\n\\u001b[1;32m     11\\u001b[0m \\u001b[38;5;28;01mfrom\\u001b[39;00m \\u001b[38;5;21;01mtorch\\u001b[39;00m\\u001b[38;5;21;01m.\\u001b[39;00m\\u001b[38;5;21;01monnx\\u001b[39;00m\\u001b[38;5;21;01m.\\u001b[39;00m\\u001b[38;5;21;01m_internal\\u001b[39;00m \\u001b[38;5;28;01mimport\\u001b[39;00m _beartype\\n\\u001b[1;32m     14\\u001b[0m \\u001b[38;5;28;01mif\\u001b[39;00m typing\\u001b[38;5;241m.\\u001b[39mTYPE_CHECKING:\\n\\u001b[1;32m     15\\u001b[0m     \\u001b[38;5;66;03m# Hack to help mypy to recognize torch._C.Value\\u001b[39;00m\\n\",\n      \"File \\u001b[0;32m~/anaconda3/lib/python3.10/site-packages/torch/onnx/errors.py:9\\u001b[0m\\n\\u001b[1;32m      7\\u001b[0m \\u001b[38;5;28;01mfrom\\u001b[39;00m \\u001b[38;5;21;01mtorch\\u001b[39;00m \\u001b[38;5;28;01mimport\\u001b[39;00m _C\\n\\u001b[1;32m      8\\u001b[0m \\u001b[38;5;28;01mfrom\\u001b[39;00m \\u001b[38;5;21;01mtorch\\u001b[39;00m\\u001b[38;5;21;01m.\\u001b[39;00m\\u001b[38;5;21;01monnx\\u001b[39;00m \\u001b[38;5;28;01mimport\\u001b[39;00m _constants\\n\\u001b[0;32m----> 9\\u001b[0m \\u001b[38;5;28;01mfrom\\u001b[39;00m \\u001b[38;5;21;01mtorch\\u001b[39;00m\\u001b[38;5;21;01m.\\u001b[39;00m\\u001b[38;5;21;01monnx\\u001b[39;00m\\u001b[38;5;21;01m.\\u001b[39;00m\\u001b[38;5;21;01m_internal\\u001b[39;00m \\u001b[38;5;28;01mimport\\u001b[39;00m diagnostics\\n\\u001b[1;32m     11\\u001b[0m __all__ \\u001b[38;5;241m=\\u001b[39m [\\n\\u001b[1;32m     12\\u001b[0m     \\u001b[38;5;124m\\\"\\u001b[39m\\u001b[38;5;124mOnnxExporterError\\u001b[39m\\u001b[38;5;124m\\\"\\u001b[39m,\\n\\u001b[1;32m     13\\u001b[0m     \\u001b[38;5;124m\\\"\\u001b[39m\\u001b[38;5;124mOnnxExporterWarning\\u001b[39m\\u001b[38;5;124m\\\"\\u001b[39m,\\n\\u001b[0;32m   (...)\\u001b[0m\\n\\u001b[1;32m     17\\u001b[0m     \\u001b[38;5;124m\\\"\\u001b[39m\\u001b[38;5;124mSymbolicValueError\\u001b[39m\\u001b[38;5;124m\\\"\\u001b[39m,\\n\\u001b[1;32m     18\\u001b[0m ]\\n\\u001b[1;32m     21\\u001b[0m \\u001b[38;5;28;01mclass\\u001b[39;00m \\u001b[38;5;21;01mOnnxExporterWarning\\u001b[39;00m(\\u001b[38;5;167;01mUserWarning\\u001b[39;00m):\\n\",\n      \"File \\u001b[0;32m~/anaconda3/lib/python3.10/site-packages/torch/onnx/_internal/diagnostics/__init__.py:1\\u001b[0m\\n\\u001b[0;32m----> 1\\u001b[0m \\u001b[38;5;28;01mfrom\\u001b[39;00m \\u001b[38;5;21;01m.\\u001b[39;00m\\u001b[38;5;21;01m_diagnostic\\u001b[39;00m \\u001b[38;5;28;01mimport\\u001b[39;00m (\\n\\u001b[1;32m      2\\u001b[0m     create_export_diagnostic_context,\\n\\u001b[1;32m      3\\u001b[0m     diagnose,\\n\\u001b[1;32m      4\\u001b[0m     engine,\\n\\u001b[1;32m      5\\u001b[0m     export_context,\\n\\u001b[1;32m      6\\u001b[0m     ExportDiagnostic,\\n\\u001b[1;32m      7\\u001b[0m )\\n\\u001b[1;32m      8\\u001b[0m \\u001b[38;5;28;01mfrom\\u001b[39;00m \\u001b[38;5;21;01m.\\u001b[39;00m\\u001b[38;5;21;01m_rules\\u001b[39;00m \\u001b[38;5;28;01mimport\\u001b[39;00m rules\\n\\u001b[1;32m      9\\u001b[0m \\u001b[38;5;28;01mfrom\\u001b[39;00m \\u001b[38;5;21;01m.\\u001b[39;00m\\u001b[38;5;21;01minfra\\u001b[39;00m \\u001b[38;5;28;01mimport\\u001b[39;00m levels\\n\",\n      \"File \\u001b[0;32m~/anaconda3/lib/python3.10/site-packages/torch/onnx/_internal/diagnostics/_diagnostic.py:11\\u001b[0m\\n\\u001b[1;32m      8\\u001b[0m \\u001b[38;5;28;01mimport\\u001b[39;00m \\u001b[38;5;21;01mtorch\\u001b[39;00m\\n\\u001b[1;32m     10\\u001b[0m \\u001b[38;5;28;01mfrom\\u001b[39;00m \\u001b[38;5;21;01mtorch\\u001b[39;00m\\u001b[38;5;21;01m.\\u001b[39;00m\\u001b[38;5;21;01monnx\\u001b[39;00m\\u001b[38;5;21;01m.\\u001b[39;00m\\u001b[38;5;21;01m_internal\\u001b[39;00m\\u001b[38;5;21;01m.\\u001b[39;00m\\u001b[38;5;21;01mdiagnostics\\u001b[39;00m \\u001b[38;5;28;01mimport\\u001b[39;00m infra\\n\\u001b[0;32m---> 11\\u001b[0m \\u001b[38;5;28;01mfrom\\u001b[39;00m \\u001b[38;5;21;01mtorch\\u001b[39;00m\\u001b[38;5;21;01m.\\u001b[39;00m\\u001b[38;5;21;01mutils\\u001b[39;00m \\u001b[38;5;28;01mimport\\u001b[39;00m cpp_backtrace\\n\\u001b[1;32m     14\\u001b[0m \\u001b[38;5;28;01mdef\\u001b[39;00m \\u001b[38;5;21m_cpp_call_stack\\u001b[39m(frames_to_skip: \\u001b[38;5;28mint\\u001b[39m \\u001b[38;5;241m=\\u001b[39m \\u001b[38;5;241m0\\u001b[39m, frames_to_log: \\u001b[38;5;28mint\\u001b[39m \\u001b[38;5;241m=\\u001b[39m \\u001b[38;5;241m32\\u001b[39m) \\u001b[38;5;241m-\\u001b[39m\\u001b[38;5;241m>\\u001b[39m infra\\u001b[38;5;241m.\\u001b[39mStack:\\n\\u001b[1;32m     15\\u001b[0m     \\u001b[38;5;124;03m\\\"\\\"\\\"Returns the current C++ call stack.\\u001b[39;00m\\n\\u001b[1;32m     16\\u001b[0m \\n\\u001b[1;32m     17\\u001b[0m \\u001b[38;5;124;03m    This function utilizes `torch.utils.cpp_backtrace` to get the current C++ call stack.\\u001b[39;00m\\n\\u001b[0;32m   (...)\\u001b[0m\\n\\u001b[1;32m     21\\u001b[0m \\n\\u001b[1;32m     22\\u001b[0m \\u001b[38;5;124;03m    \\\"\\\"\\\"\\u001b[39;00m\\n\",\n      \"File \\u001b[0;32m~/anaconda3/lib/python3.10/site-packages/torch/utils/cpp_backtrace.py:1\\u001b[0m\\n\\u001b[0;32m----> 1\\u001b[0m \\u001b[38;5;28;01mfrom\\u001b[39;00m \\u001b[38;5;21;01mtorch\\u001b[39;00m\\u001b[38;5;21;01m.\\u001b[39;00m\\u001b[38;5;21;01m_C\\u001b[39;00m \\u001b[38;5;28;01mimport\\u001b[39;00m _get_cpp_backtrace\\n\\u001b[1;32m      3\\u001b[0m \\u001b[38;5;28;01mdef\\u001b[39;00m \\u001b[38;5;21mget_cpp_backtrace\\u001b[39m(frames_to_skip\\u001b[38;5;241m=\\u001b[39m\\u001b[38;5;241m0\\u001b[39m, maximum_number_of_frames\\u001b[38;5;241m=\\u001b[39m\\u001b[38;5;241m64\\u001b[39m) \\u001b[38;5;241m-\\u001b[39m\\u001b[38;5;241m>\\u001b[39m \\u001b[38;5;28mstr\\u001b[39m:\\n\\u001b[1;32m      4\\u001b[0m     \\u001b[38;5;124mr\\u001b[39m\\u001b[38;5;124;03m\\\"\\\"\\\"\\u001b[39;00m\\n\\u001b[1;32m      5\\u001b[0m \\u001b[38;5;124;03m    Returns a string containing the C++ stack trace of the current thread.\\u001b[39;00m\\n\\u001b[1;32m      6\\u001b[0m \\u001b[38;5;124;03m    Args:\\u001b[39;00m\\n\\u001b[1;32m      7\\u001b[0m \\u001b[38;5;124;03m        frames_to_skip (int): the number of frames to skip from the top of the stack\\u001b[39;00m\\n\\u001b[1;32m      8\\u001b[0m \\u001b[38;5;124;03m        maximum_number_of_frames (int): the maximum number of frames to return\\u001b[39;00m\\n\\u001b[1;32m      9\\u001b[0m \\u001b[38;5;124;03m    \\\"\\\"\\\"\\u001b[39;00m\\n\",\n      \"\\u001b[0;31mImportError\\u001b[0m: cannot import name '_get_cpp_backtrace' from 'torch._C' (/home/endrit/anaconda3/lib/python3.10/site-packages/torch/_C.cpython-310-x86_64-linux-gnu.so)\"\n     ]\n    }\n   ],\n   \"source\": [\n    \"!pip install torchvision\\n\",\n    \"from train_segmentation import LitUnsupervisedSegmenter\\n\",\n    \"\\n\",\n    \"model = LitUnsupervisedSegmenter.load_from_checkpoint(join(saved_models_dir, saved_model_name)).cuda()\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {\n    \"id\": \"ATktWg_hBbuS\"\n   },\n   \"source\": [\n    \"# Load Image\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 6,\n   \"metadata\": {\n    \"colab\": {\n     \"base_uri\": \"https://localhost:8080/\"\n    },\n    \"id\": \"Ku-prYXZ8quf\",\n    \"outputId\": \"f3c132f1-f380-4431-ed6d-7d158d3af41b\"\n   },\n   \"outputs\": [\n    {\n     \"ename\": \"ModuleNotFoundError\",\n     \"evalue\": \"No module named 'torchvision'\",\n     \"output_type\": \"error\",\n     \"traceback\": [\n      \"\\u001b[0;31m---------------------------------------------------------------------------\\u001b[0m\",\n      \"\\u001b[0;31mModuleNotFoundError\\u001b[0m                       Traceback (most recent call last)\",\n      \"Cell \\u001b[0;32mIn[6], line 4\\u001b[0m\\n\\u001b[1;32m      2\\u001b[0m \\u001b[38;5;28;01mimport\\u001b[39;00m \\u001b[38;5;21;01mrequests\\u001b[39;00m\\n\\u001b[1;32m      3\\u001b[0m \\u001b[38;5;28;01mfrom\\u001b[39;00m \\u001b[38;5;21;01mio\\u001b[39;00m \\u001b[38;5;28;01mimport\\u001b[39;00m BytesIO\\n\\u001b[0;32m----> 4\\u001b[0m \\u001b[38;5;28;01mfrom\\u001b[39;00m \\u001b[38;5;21;01mtorchvision\\u001b[39;00m\\u001b[38;5;21;01m.\\u001b[39;00m\\u001b[38;5;21;01mtransforms\\u001b[39;00m\\u001b[38;5;21;01m.\\u001b[39;00m\\u001b[38;5;21;01mfunctional\\u001b[39;00m \\u001b[38;5;28;01mimport\\u001b[39;00m to_tensor\\n\\u001b[1;32m      5\\u001b[0m \\u001b[38;5;28;01mfrom\\u001b[39;00m \\u001b[38;5;21;01mutils\\u001b[39;00m \\u001b[38;5;28;01mimport\\u001b[39;00m get_transform\\n\\u001b[1;32m      7\\u001b[0m img_url \\u001b[38;5;241m=\\u001b[39m\\u001b[38;5;124m\\\"\\u001b[39m\\u001b[38;5;124mhttps://marhamilresearch4.blob.core.windows.net/stego-public/sample_images/moto1.jpg\\u001b[39m\\u001b[38;5;124m\\\"\\u001b[39m\\n\",\n      \"\\u001b[0;31mModuleNotFoundError\\u001b[0m: No module named 'torchvision'\"\n     ]\n    }\n   ],\n   \"source\": [\n    \"from PIL import Image\\n\",\n    \"import requests\\n\",\n    \"from io import BytesIO\\n\",\n    \"from torchvision.transforms.functional import to_tensor\\n\",\n    \"from utils import get_transform\\n\",\n    \"\\n\",\n    \"img_url =\\\"https://marhamilresearch4.blob.core.windows.net/stego-public/sample_images/moto1.jpg\\\"\\n\",\n    \"response = requests.get(img_url)\\n\",\n    \"img = Image.open(BytesIO(response.content))\\n\",\n    \"transform = get_transform(448, False, \\\"center\\\")\\n\",\n    \"img = transform(img).unsqueeze(0).cuda()\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {\n    \"id\": \"5xXhpW6BBeWz\"\n   },\n   \"source\": [\n    \"# Query model and pass result through CRF\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 9,\n   \"metadata\": {\n    \"id\": \"e0hvX1KX30SC\"\n   },\n   \"outputs\": [\n    {\n     \"ename\": \"ModuleNotFoundError\",\n     \"evalue\": \"No module named 'torchvision'\",\n     \"output_type\": \"error\",\n     \"traceback\": [\n      \"\\u001b[0;31m---------------------------------------------------------------------------\\u001b[0m\",\n      \"\\u001b[0;31mModuleNotFoundError\\u001b[0m                       Traceback (most recent call last)\",\n      \"Cell \\u001b[0;32mIn[9], line 2\\u001b[0m\\n\\u001b[1;32m      1\\u001b[0m \\u001b[38;5;28;01mimport\\u001b[39;00m \\u001b[38;5;21;01mtorch\\u001b[39;00m\\u001b[38;5;21;01m.\\u001b[39;00m\\u001b[38;5;21;01mnn\\u001b[39;00m\\u001b[38;5;21;01m.\\u001b[39;00m\\u001b[38;5;21;01mfunctional\\u001b[39;00m \\u001b[38;5;28;01mas\\u001b[39;00m \\u001b[38;5;21;01mF\\u001b[39;00m\\n\\u001b[0;32m----> 2\\u001b[0m \\u001b[38;5;28;01mfrom\\u001b[39;00m \\u001b[38;5;21;01mcrf\\u001b[39;00m \\u001b[38;5;28;01mimport\\u001b[39;00m dense_crf\\n\\u001b[1;32m      3\\u001b[0m \\u001b[38;5;28;01mimport\\u001b[39;00m \\u001b[38;5;21;01mtorch\\u001b[39;00m\\n\\u001b[1;32m      5\\u001b[0m \\u001b[38;5;28;01mwith\\u001b[39;00m torch\\u001b[38;5;241m.\\u001b[39mno_grad():\\n\",\n      \"File \\u001b[0;32m~/STEGO/src/crf.py:10\\u001b[0m\\n\\u001b[1;32m      8\\u001b[0m \\u001b[38;5;28;01mimport\\u001b[39;00m \\u001b[38;5;21;01mtorch\\u001b[39;00m\\n\\u001b[1;32m      9\\u001b[0m \\u001b[38;5;28;01mimport\\u001b[39;00m \\u001b[38;5;21;01mtorch\\u001b[39;00m\\u001b[38;5;21;01m.\\u001b[39;00m\\u001b[38;5;21;01mnn\\u001b[39;00m\\u001b[38;5;21;01m.\\u001b[39;00m\\u001b[38;5;21;01mfunctional\\u001b[39;00m \\u001b[38;5;28;01mas\\u001b[39;00m \\u001b[38;5;21;01mF\\u001b[39;00m\\n\\u001b[0;32m---> 10\\u001b[0m \\u001b[38;5;28;01mimport\\u001b[39;00m \\u001b[38;5;21;01mtorchvision\\u001b[39;00m\\u001b[38;5;21;01m.\\u001b[39;00m\\u001b[38;5;21;01mtransforms\\u001b[39;00m\\u001b[38;5;21;01m.\\u001b[39;00m\\u001b[38;5;21;01mfunctional\\u001b[39;00m \\u001b[38;5;28;01mas\\u001b[39;00m \\u001b[38;5;21;01mVF\\u001b[39;00m\\n\\u001b[1;32m     11\\u001b[0m \\u001b[38;5;28;01mfrom\\u001b[39;00m \\u001b[38;5;21;01mutils\\u001b[39;00m \\u001b[38;5;28;01mimport\\u001b[39;00m unnorm\\n\\u001b[1;32m     13\\u001b[0m MAX_ITER \\u001b[38;5;241m=\\u001b[39m \\u001b[38;5;241m10\\u001b[39m\\n\",\n      \"\\u001b[0;31mModuleNotFoundError\\u001b[0m: No module named 'torchvision'\"\n     ]\n    }\n   ],\n   \"source\": [\n    \"import torch.nn.functional as F\\n\",\n    \"from crf import dense_crf\\n\",\n    \"import torch\\n\",\n    \"\\n\",\n    \"with torch.no_grad():\\n\",\n    \"  code1 = model(img)\\n\",\n    \"  code2 = model(img.flip(dims=[3]))\\n\",\n    \"  code  = (code1 + code2.flip(dims=[3])) / 2\\n\",\n    \"  code = F.interpolate(code, img.shape[-2:], mode='bilinear', align_corners=False)\\n\",\n    \"  linear_probs = torch.log_softmax(model.linear_probe(code), dim=1).cpu()\\n\",\n    \"  cluster_probs = model.cluster_probe(code, 2, log_probs=True).cpu()\\n\",\n    \"\\n\",\n    \"  single_img = img[0].cpu()\\n\",\n    \"  linear_pred = dense_crf(single_img, linear_probs[0]).argmax(0)\\n\",\n    \"  cluster_pred = dense_crf(single_img, cluster_probs[0]).argmax(0)\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {\n    \"id\": \"BxPO9i4rBjpH\"\n   },\n   \"source\": [\n    \"# Visualize Result\\n\",\n    \"\\n\",\n    \"Note that cluster predictions will not be matched with ground truth classes in this example. For hungarian matching please use: `eval_segmentation.py`\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 12,\n   \"metadata\": {\n    \"colab\": {\n     \"base_uri\": \"https://localhost:8080/\",\n     \"height\": 314\n    },\n    \"id\": \"3G7CIyYG-hXj\",\n    \"outputId\": \"4731d8de-d772-4818-9d14-679de5af7060\"\n   },\n   \"outputs\": [\n    {\n     \"name\": \"stderr\",\n     \"output_type\": \"stream\",\n     \"text\": [\n      \"Clipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers).\\n\"\n     ]\n    },\n    {\n     \"data\": {\n      \"image/png\": \"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\\n\",\n      \"text/plain\": [\n       \"<Figure size 1080x360 with 3 Axes>\"\n      ]\n     },\n     \"metadata\": {},\n     \"output_type\": \"display_data\"\n    }\n   ],\n   \"source\": [\n    \"import matplotlib.pyplot as plt\\n\",\n    \"from utils import unnorm, remove_axes\\n\",\n    \"fig, ax = plt.subplots(1,3, figsize=(5*3,5))\\n\",\n    \"ax[0].imshow(unnorm(img)[0].permute(1,2,0).cpu())\\n\",\n    \"ax[0].set_title(\\\"Image\\\")\\n\",\n    \"ax[1].imshow(model.label_cmap[cluster_pred])\\n\",\n    \"ax[1].set_title(\\\"Cluster Predictions\\\")\\n\",\n    \"ax[2].imshow(model.label_cmap[linear_pred])\\n\",\n    \"ax[2].set_title(\\\"Linear Probe Predictions\\\")\\n\",\n    \"remove_axes(ax)\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {\n    \"id\": \"IZtla3AI-uTX\"\n   },\n   \"outputs\": [],\n   \"source\": []\n  }\n ],\n \"metadata\": {\n  \"accelerator\": \"GPU\",\n  \"colab\": {\n   \"name\": \"STEGO Colab Demo.ipynb\",\n   \"provenance\": []\n  },\n  \"kernelspec\": {\n   \"display_name\": \"Python 3 (ipykernel)\",\n   \"language\": \"python\",\n   \"name\": \"python3\"\n  },\n  \"language_info\": {\n   \"codemirror_mode\": {\n    \"name\": \"ipython\",\n    \"version\": 3\n   },\n   \"file_extension\": \".py\",\n   \"mimetype\": \"text/x-python\",\n   \"name\": \"python\",\n   \"nbconvert_exporter\": \"python\",\n   \"pygments_lexer\": \"ipython3\",\n   \"version\": \"3.10.9\"\n  },\n  \"widgets\": {\n   \"application/vnd.jupyter.widget-state+json\": {\n    \"2d1d907c0d04492097e35a9ceddea9a2\": {\n     \"model_module\": \"@jupyter-widgets/base\",\n     \"model_module_version\": \"1.2.0\",\n     \"model_name\": \"LayoutModel\",\n     \"state\": {\n      \"_model_module\": \"@jupyter-widgets/base\",\n      \"_model_module_version\": \"1.2.0\",\n      \"_model_name\": \"LayoutModel\",\n      \"_view_count\": null,\n      \"_view_module\": \"@jupyter-widgets/base\",\n      \"_view_module_version\": \"1.2.0\",\n      \"_view_name\": \"LayoutView\",\n      \"align_content\": null,\n      \"align_items\": null,\n      \"align_self\": null,\n      \"border\": null,\n      \"bottom\": null,\n      \"display\": null,\n      \"flex\": null,\n      \"flex_flow\": null,\n      \"grid_area\": null,\n      \"grid_auto_columns\": null,\n      \"grid_auto_flow\": null,\n      \"grid_auto_rows\": null,\n      \"grid_column\": null,\n      \"grid_gap\": null,\n      \"grid_row\": null,\n      \"grid_template_areas\": null,\n      \"grid_template_columns\": null,\n      \"grid_template_rows\": null,\n      \"height\": null,\n      \"justify_content\": null,\n      \"justify_items\": null,\n      \"left\": null,\n      \"margin\": null,\n      \"max_height\": null,\n      \"max_width\": null,\n      \"min_height\": null,\n      \"min_width\": null,\n      \"object_fit\": null,\n      \"object_position\": null,\n      \"order\": null,\n      \"overflow\": null,\n      \"overflow_x\": null,\n      \"overflow_y\": null,\n      \"padding\": null,\n      \"right\": null,\n      \"top\": null,\n      \"visibility\": null,\n      \"width\": null\n     }\n    },\n    \"41986d51df5b41d79187acaebafe3008\": {\n     \"model_module\": \"@jupyter-widgets/controls\",\n     \"model_module_version\": \"1.5.0\",\n     \"model_name\": \"DescriptionStyleModel\",\n     \"state\": {\n      \"_model_module\": \"@jupyter-widgets/controls\",\n      \"_model_module_version\": \"1.5.0\",\n      \"_model_name\": \"DescriptionStyleModel\",\n      \"_view_count\": null,\n      \"_view_module\": \"@jupyter-widgets/base\",\n      \"_view_module_version\": \"1.2.0\",\n      \"_view_name\": \"StyleView\",\n      \"description_width\": \"\"\n     }\n    },\n    \"41d2dacf744d4ecaa1f51174a6703334\": {\n     \"model_module\": \"@jupyter-widgets/controls\",\n     \"model_module_version\": \"1.5.0\",\n     \"model_name\": \"HTMLModel\",\n     \"state\": {\n      \"_dom_classes\": [],\n      \"_model_module\": \"@jupyter-widgets/controls\",\n      \"_model_module_version\": \"1.5.0\",\n      \"_model_name\": \"HTMLModel\",\n      \"_view_count\": null,\n      \"_view_module\": \"@jupyter-widgets/controls\",\n      \"_view_module_version\": \"1.5.0\",\n      \"_view_name\": \"HTMLView\",\n      \"description\": \"\",\n      \"description_tooltip\": null,\n      \"layout\": \"IPY_MODEL_2d1d907c0d04492097e35a9ceddea9a2\",\n      \"placeholder\": \"\u200B\",\n      \"style\": \"IPY_MODEL_6de033864a1b4397a93147091aedda65\",\n      \"value\": \" 327M/327M [00:15&lt;00:00, 25.4MB/s]\"\n     }\n    },\n    \"5fa05203c234442a8c863a51f83bac9d\": {\n     \"model_module\": \"@jupyter-widgets/controls\",\n     \"model_module_version\": \"1.5.0\",\n     \"model_name\": \"HBoxModel\",\n     \"state\": {\n      \"_dom_classes\": [],\n      \"_model_module\": \"@jupyter-widgets/controls\",\n      \"_model_module_version\": \"1.5.0\",\n      \"_model_name\": \"HBoxModel\",\n      \"_view_count\": null,\n      \"_view_module\": \"@jupyter-widgets/controls\",\n      \"_view_module_version\": \"1.5.0\",\n      \"_view_name\": \"HBoxView\",\n      \"box_style\": \"\",\n      \"children\": [\n       \"IPY_MODEL_7cf007c8f7a94bc292f8243391cea7ca\",\n       \"IPY_MODEL_5fa6b3215e01491d9534feadee79f706\",\n       \"IPY_MODEL_41d2dacf744d4ecaa1f51174a6703334\"\n      ],\n      \"layout\": \"IPY_MODEL_d5faaf8d200a4bbf9c1e9677af8fe257\"\n     }\n    },\n    \"5fa6b3215e01491d9534feadee79f706\": {\n     \"model_module\": \"@jupyter-widgets/controls\",\n     \"model_module_version\": \"1.5.0\",\n     \"model_name\": \"FloatProgressModel\",\n     \"state\": {\n      \"_dom_classes\": [],\n      \"_model_module\": \"@jupyter-widgets/controls\",\n      \"_model_module_version\": \"1.5.0\",\n      \"_model_name\": \"FloatProgressModel\",\n      \"_view_count\": null,\n      \"_view_module\": \"@jupyter-widgets/controls\",\n      \"_view_module_version\": \"1.5.0\",\n      \"_view_name\": \"ProgressView\",\n      \"bar_style\": \"success\",\n      \"description\": \"\",\n      \"description_tooltip\": null,\n      \"layout\": \"IPY_MODEL_e2ad8a86c24c419581c204fd2ae2ba18\",\n      \"max\": 343279349,\n      \"min\": 0,\n      \"orientation\": \"horizontal\",\n      \"style\": \"IPY_MODEL_811c526bd6154969b7028307dcafd550\",\n      \"value\": 343279349\n     }\n    },\n    \"6de033864a1b4397a93147091aedda65\": {\n     \"model_module\": \"@jupyter-widgets/controls\",\n     \"model_module_version\": \"1.5.0\",\n     \"model_name\": \"DescriptionStyleModel\",\n     \"state\": {\n      \"_model_module\": \"@jupyter-widgets/controls\",\n      \"_model_module_version\": \"1.5.0\",\n      \"_model_name\": \"DescriptionStyleModel\",\n      \"_view_count\": null,\n      \"_view_module\": \"@jupyter-widgets/base\",\n      \"_view_module_version\": \"1.2.0\",\n      \"_view_name\": \"StyleView\",\n      \"description_width\": \"\"\n     }\n    },\n    \"7cf007c8f7a94bc292f8243391cea7ca\": {\n     \"model_module\": \"@jupyter-widgets/controls\",\n     \"model_module_version\": \"1.5.0\",\n     \"model_name\": \"HTMLModel\",\n     \"state\": {\n      \"_dom_classes\": [],\n      \"_model_module\": \"@jupyter-widgets/controls\",\n      \"_model_module_version\": \"1.5.0\",\n      \"_model_name\": \"HTMLModel\",\n      \"_view_count\": null,\n      \"_view_module\": \"@jupyter-widgets/controls\",\n      \"_view_module_version\": \"1.5.0\",\n      \"_view_name\": \"HTMLView\",\n      \"description\": \"\",\n      \"description_tooltip\": null,\n      \"layout\": \"IPY_MODEL_aeb7614c4d7e41eeab603a70fc80ed6a\",\n      \"placeholder\": \"\u200B\",\n      \"style\": \"IPY_MODEL_41986d51df5b41d79187acaebafe3008\",\n      \"value\": \"100%\"\n     }\n    },\n    \"811c526bd6154969b7028307dcafd550\": {\n     \"model_module\": \"@jupyter-widgets/controls\",\n     \"model_module_version\": \"1.5.0\",\n     \"model_name\": \"ProgressStyleModel\",\n     \"state\": {\n      \"_model_module\": \"@jupyter-widgets/controls\",\n      \"_model_module_version\": \"1.5.0\",\n      \"_model_name\": \"ProgressStyleModel\",\n      \"_view_count\": null,\n      \"_view_module\": \"@jupyter-widgets/base\",\n      \"_view_module_version\": \"1.2.0\",\n      \"_view_name\": \"StyleView\",\n      \"bar_color\": null,\n      \"description_width\": \"\"\n     }\n    },\n    \"aeb7614c4d7e41eeab603a70fc80ed6a\": {\n     \"model_module\": \"@jupyter-widgets/base\",\n     \"model_module_version\": \"1.2.0\",\n     \"model_name\": \"LayoutModel\",\n     \"state\": {\n      \"_model_module\": \"@jupyter-widgets/base\",\n      \"_model_module_version\": \"1.2.0\",\n      \"_model_name\": \"LayoutModel\",\n      \"_view_count\": null,\n      \"_view_module\": \"@jupyter-widgets/base\",\n      \"_view_module_version\": \"1.2.0\",\n      \"_view_name\": \"LayoutView\",\n      \"align_content\": null,\n      \"align_items\": null,\n      \"align_self\": null,\n      \"border\": null,\n      \"bottom\": null,\n      \"display\": null,\n      \"flex\": null,\n      \"flex_flow\": null,\n      \"grid_area\": null,\n      \"grid_auto_columns\": null,\n      \"grid_auto_flow\": null,\n      \"grid_auto_rows\": null,\n      \"grid_column\": null,\n      \"grid_gap\": null,\n      \"grid_row\": null,\n      \"grid_template_areas\": null,\n      \"grid_template_columns\": null,\n      \"grid_template_rows\": null,\n      \"height\": null,\n      \"justify_content\": null,\n      \"justify_items\": null,\n      \"left\": null,\n      \"margin\": null,\n      \"max_height\": null,\n      \"max_width\": null,\n      \"min_height\": null,\n      \"min_width\": null,\n      \"object_fit\": null,\n      \"object_position\": null,\n      \"order\": null,\n      \"overflow\": null,\n      \"overflow_x\": null,\n      \"overflow_y\": null,\n      \"padding\": null,\n      \"right\": null,\n      \"top\": null,\n      \"visibility\": null,\n      \"width\": null\n     }\n    },\n    \"d5faaf8d200a4bbf9c1e9677af8fe257\": {\n     \"model_module\": \"@jupyter-widgets/base\",\n     \"model_module_version\": \"1.2.0\",\n     \"model_name\": \"LayoutModel\",\n     \"state\": {\n      \"_model_module\": \"@jupyter-widgets/base\",\n      \"_model_module_version\": \"1.2.0\",\n      \"_model_name\": \"LayoutModel\",\n      \"_view_count\": null,\n      \"_view_module\": \"@jupyter-widgets/base\",\n      \"_view_module_version\": \"1.2.0\",\n      \"_view_name\": \"LayoutView\",\n      \"align_content\": null,\n      \"align_items\": null,\n      \"align_self\": null,\n      \"border\": null,\n      \"bottom\": null,\n      \"display\": null,\n      \"flex\": null,\n      \"flex_flow\": null,\n      \"grid_area\": null,\n      \"grid_auto_columns\": null,\n      \"grid_auto_flow\": null,\n      \"grid_auto_rows\": null,\n      \"grid_column\": null,\n      \"grid_gap\": null,\n      \"grid_row\": null,\n      \"grid_template_areas\": null,\n      \"grid_template_columns\": null,\n      \"grid_template_rows\": null,\n      \"height\": null,\n      \"justify_content\": null,\n      \"justify_items\": null,\n      \"left\": null,\n      \"margin\": null,\n      \"max_height\": null,\n      \"max_width\": null,\n      \"min_height\": null,\n      \"min_width\": null,\n      \"object_fit\": null,\n      \"object_position\": null,\n      \"order\": null,\n      \"overflow\": null,\n      \"overflow_x\": null,\n      \"overflow_y\": null,\n      \"padding\": null,\n      \"right\": null,\n      \"top\": null,\n      \"visibility\": null,\n      \"width\": null\n     }\n    },\n    \"e2ad8a86c24c419581c204fd2ae2ba18\": {\n     \"model_module\": \"@jupyter-widgets/base\",\n     \"model_module_version\": \"1.2.0\",\n     \"model_name\": \"LayoutModel\",\n     \"state\": {\n      \"_model_module\": \"@jupyter-widgets/base\",\n      \"_model_module_version\": \"1.2.0\",\n      \"_model_name\": \"LayoutModel\",\n      \"_view_count\": null,\n      \"_view_module\": \"@jupyter-widgets/base\",\n      \"_view_module_version\": \"1.2.0\",\n      \"_view_name\": \"LayoutView\",\n      \"align_content\": null,\n      \"align_items\": null,\n      \"align_self\": null,\n      \"border\": null,\n      \"bottom\": null,\n      \"display\": null,\n      \"flex\": null,\n      \"flex_flow\": null,\n      \"grid_area\": null,\n      \"grid_auto_columns\": null,\n      \"grid_auto_flow\": null,\n      \"grid_auto_rows\": null,\n      \"grid_column\": null,\n      \"grid_gap\": null,\n      \"grid_row\": null,\n      \"grid_template_areas\": null,\n      \"grid_template_columns\": null,\n      \"grid_template_rows\": null,\n      \"height\": null,\n      \"justify_content\": null,\n      \"justify_items\": null,\n      \"left\": null,\n      \"margin\": null,\n      \"max_height\": null,\n      \"max_width\": null,\n      \"min_height\": null,\n      \"min_width\": null,\n      \"object_fit\": null,\n      \"object_position\": null,\n      \"order\": null,\n      \"overflow\": null,\n      \"overflow_x\": null,\n      \"overflow_y\": null,\n      \"padding\": null,\n      \"right\": null,\n      \"top\": null,\n      \"visibility\": null,\n      \"width\": null\n     }\n    }\n   }\n  }\n },\n \"nbformat\": 4,\n \"nbformat_minor\": 4\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/STEGO_Colab_Demo.ipynb b/src/STEGO_Colab_Demo.ipynb
--- a/src/STEGO_Colab_Demo.ipynb	(revision c6be305e586f39b07663cb9bdb535828fe4047df)
+++ b/src/STEGO_Colab_Demo.ipynb	(date 1717598322362)
@@ -1,831 +1,13 @@
 {
  "cells": [
   {
-   "cell_type": "markdown",
-   "metadata": {
-    "id": "JmPYsg-B49tM"
-   },
-   "source": [
-    "# Prepare Google Colab Environment"
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 1,
-   "metadata": {
-    "colab": {
-     "base_uri": "https://localhost:8080/"
-    },
-    "id": "GbkVr03HbnG4",
-    "outputId": "17fb7b43-ba13-4a58-d1b3-b2c538648651"
-   },
-   "outputs": [
-    {
-     "name": "stdout",
-     "output_type": "stream",
-     "text": [
-      "fatal: destination path 'STEGO' already exists and is not an empty directory.\n"
-     ]
-    }
-   ],
-   "source": [
-    "!git clone https://github.com/mhamilton723/STEGO.git"
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 2,
-   "metadata": {
-    "colab": {
-     "base_uri": "https://localhost:8080/",
-     "height": 1000
-    },
-    "id": "Q4z1D5fOda3F",
-    "outputId": "d3f974df-63a6-4717-ed6a-4d37a1abac05"
-   },
-   "outputs": [
-    {
-     "name": "stdout",
-     "output_type": "stream",
-     "text": [
-      "Requirement already satisfied: wget in /home/endrit/anaconda3/lib/python3.10/site-packages (3.2)\n",
-      "Requirement already satisfied: torchmetrics in /home/endrit/anaconda3/lib/python3.10/site-packages (0.11.4)\n",
-      "Requirement already satisfied: packaging in /home/endrit/anaconda3/lib/python3.10/site-packages (from torchmetrics) (22.0)\n",
-      "Requirement already satisfied: numpy>=1.17.2 in /home/endrit/anaconda3/lib/python3.10/site-packages (from torchmetrics) (1.23.5)\n",
-      "Requirement already satisfied: torch>=1.8.1 in /home/endrit/anaconda3/lib/python3.10/site-packages (from torchmetrics) (1.12.1)\n",
-      "Requirement already satisfied: typing_extensions in /home/endrit/anaconda3/lib/python3.10/site-packages (from torch>=1.8.1->torchmetrics) (4.4.0)\n",
-      "Requirement already satisfied: hydra-core in /home/endrit/anaconda3/lib/python3.10/site-packages (1.3.2)\n",
-      "Requirement already satisfied: antlr4-python3-runtime==4.9.* in /home/endrit/anaconda3/lib/python3.10/site-packages (from hydra-core) (4.9.3)\n",
-      "Requirement already satisfied: packaging in /home/endrit/anaconda3/lib/python3.10/site-packages (from hydra-core) (22.0)\n",
-      "Requirement already satisfied: omegaconf<2.4,>=2.2 in /home/endrit/anaconda3/lib/python3.10/site-packages (from hydra-core) (2.3.0)\n",
-      "Requirement already satisfied: PyYAML>=5.1.0 in /home/endrit/anaconda3/lib/python3.10/site-packages (from omegaconf<2.4,>=2.2->hydra-core) (6.0)\n",
-      "Collecting git+https://github.com/lucasb-eyer/pydensecrf.git\n",
-      "  Cloning https://github.com/lucasb-eyer/pydensecrf.git to /tmp/pip-req-build-_1nblw2f\n",
-      "  Running command git clone --filter=blob:none --quiet https://github.com/lucasb-eyer/pydensecrf.git /tmp/pip-req-build-_1nblw2f\n",
-      "  Resolved https://github.com/lucasb-eyer/pydensecrf.git to commit 0d53acbcf5123d4c88040fe68fbb9805fc5b2fb9\n",
-      "  Installing build dependencies ... \u001b[?25ldone\n",
-      "\u001b[?25h  Getting requirements to build wheel ... \u001b[?25ldone\n",
-      "\u001b[?25h  Preparing metadata (pyproject.toml) ... \u001b[?25ldone\n",
-      "\u001b[?25hRequirement already satisfied: omegaconf in /home/endrit/anaconda3/lib/python3.10/site-packages (2.3.0)\n",
-      "Requirement already satisfied: antlr4-python3-runtime==4.9.* in /home/endrit/anaconda3/lib/python3.10/site-packages (from omegaconf) (4.9.3)\n",
-      "Requirement already satisfied: PyYAML>=5.1.0 in /home/endrit/anaconda3/lib/python3.10/site-packages (from omegaconf) (6.0)\n",
-      "Requirement already satisfied: pytorch-lightning in /home/endrit/anaconda3/lib/python3.10/site-packages (2.0.2)\n",
-      "Requirement already satisfied: fsspec[http]>2021.06.0 in /home/endrit/anaconda3/lib/python3.10/site-packages (from pytorch-lightning) (2022.11.0)\n",
-      "Requirement already satisfied: lightning-utilities>=0.7.0 in /home/endrit/anaconda3/lib/python3.10/site-packages (from pytorch-lightning) (0.8.0)\n",
-      "Requirement already satisfied: numpy>=1.17.2 in /home/endrit/anaconda3/lib/python3.10/site-packages (from pytorch-lightning) (1.23.5)\n",
-      "Requirement already satisfied: torchmetrics>=0.7.0 in /home/endrit/anaconda3/lib/python3.10/site-packages (from pytorch-lightning) (0.11.4)\n",
-      "Requirement already satisfied: PyYAML>=5.4 in /home/endrit/anaconda3/lib/python3.10/site-packages (from pytorch-lightning) (6.0)\n",
-      "Requirement already satisfied: torch>=1.11.0 in /home/endrit/anaconda3/lib/python3.10/site-packages (from pytorch-lightning) (1.12.1)\n",
-      "Requirement already satisfied: typing-extensions>=4.0.0 in /home/endrit/anaconda3/lib/python3.10/site-packages (from pytorch-lightning) (4.4.0)\n",
-      "Requirement already satisfied: tqdm>=4.57.0 in /home/endrit/anaconda3/lib/python3.10/site-packages (from pytorch-lightning) (4.64.1)\n",
-      "Requirement already satisfied: packaging>=17.1 in /home/endrit/anaconda3/lib/python3.10/site-packages (from pytorch-lightning) (22.0)\n",
-      "Requirement already satisfied: requests in /home/endrit/anaconda3/lib/python3.10/site-packages (from fsspec[http]>2021.06.0->pytorch-lightning) (2.28.1)\n",
-      "Requirement already satisfied: aiohttp!=4.0.0a0,!=4.0.0a1 in /home/endrit/anaconda3/lib/python3.10/site-packages (from fsspec[http]>2021.06.0->pytorch-lightning) (3.8.4)\n",
-      "Requirement already satisfied: frozenlist>=1.1.1 in /home/endrit/anaconda3/lib/python3.10/site-packages (from aiohttp!=4.0.0a0,!=4.0.0a1->fsspec[http]>2021.06.0->pytorch-lightning) (1.3.3)\n",
-      "Requirement already satisfied: charset-normalizer<4.0,>=2.0 in /home/endrit/anaconda3/lib/python3.10/site-packages (from aiohttp!=4.0.0a0,!=4.0.0a1->fsspec[http]>2021.06.0->pytorch-lightning) (2.0.4)\n",
-      "Requirement already satisfied: yarl<2.0,>=1.0 in /home/endrit/anaconda3/lib/python3.10/site-packages (from aiohttp!=4.0.0a0,!=4.0.0a1->fsspec[http]>2021.06.0->pytorch-lightning) (1.9.2)\n",
-      "Requirement already satisfied: attrs>=17.3.0 in /home/endrit/anaconda3/lib/python3.10/site-packages (from aiohttp!=4.0.0a0,!=4.0.0a1->fsspec[http]>2021.06.0->pytorch-lightning) (22.1.0)\n",
-      "Requirement already satisfied: multidict<7.0,>=4.5 in /home/endrit/anaconda3/lib/python3.10/site-packages (from aiohttp!=4.0.0a0,!=4.0.0a1->fsspec[http]>2021.06.0->pytorch-lightning) (6.0.4)\n",
-      "Requirement already satisfied: aiosignal>=1.1.2 in /home/endrit/anaconda3/lib/python3.10/site-packages (from aiohttp!=4.0.0a0,!=4.0.0a1->fsspec[http]>2021.06.0->pytorch-lightning) (1.3.1)\n",
-      "Requirement already satisfied: async-timeout<5.0,>=4.0.0a3 in /home/endrit/anaconda3/lib/python3.10/site-packages (from aiohttp!=4.0.0a0,!=4.0.0a1->fsspec[http]>2021.06.0->pytorch-lightning) (4.0.2)\n",
-      "Requirement already satisfied: certifi>=2017.4.17 in /home/endrit/anaconda3/lib/python3.10/site-packages (from requests->fsspec[http]>2021.06.0->pytorch-lightning) (2023.5.7)\n",
-      "Requirement already satisfied: idna<4,>=2.5 in /home/endrit/anaconda3/lib/python3.10/site-packages (from requests->fsspec[http]>2021.06.0->pytorch-lightning) (3.4)\n",
-      "Requirement already satisfied: urllib3<1.27,>=1.21.1 in /home/endrit/anaconda3/lib/python3.10/site-packages (from requests->fsspec[http]>2021.06.0->pytorch-lightning) (1.26.14)\n"
-     ]
-    }
-   ],
-   "source": [
-    "!pip install wget\n",
-    "!pip install torchmetrics\n",
-    "!pip install hydra-core\n",
-    "!pip install git+https://github.com/lucasb-eyer/pydensecrf.git\n",
-    "!pip install omegaconf\n",
-    "!pip install pytorch-lightning"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "metadata": {
-    "id": "N-CjEZdF5DSH"
-   },
-   "source": [
-    "# Download Pretrained Model\n",
-    "\n"
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 3,
-   "metadata": {
-    "id": "hJ_XE2xHcImN"
-   },
-   "outputs": [],
-   "source": [
-    "import os\n",
-    "from os.path import join\n",
-    "os.chdir(\"STEGO/src\")\n",
-    "saved_models_dir = join(\"..\", \"saved_models\")\n",
-    "os.makedirs(saved_models_dir, exist_ok=True)"
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 4,
-   "metadata": {
-    "id": "knywSO7IcNc2"
-   },
-   "outputs": [],
-   "source": [
-    "import wget\n",
-    "saved_model_url_root = \"https://marhamilresearch4.blob.core.windows.net/stego-public/saved_models/\"\n",
-    "saved_model_name = \"cocostuff27_vit_base_5.ckpt\"\n",
-    "if not os.path.exists(join(saved_models_dir, saved_model_name)):\n",
-    "  wget.download(saved_model_url_root + saved_model_name, join(saved_models_dir, saved_model_name))"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "metadata": {
-    "id": "rtwTZEkA7twI"
-   },
-   "source": [
-    "# Load pretrained STEGO"
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 6,
-   "metadata": {
-    "colab": {
-     "base_uri": "https://localhost:8080/",
-     "height": 104,
-     "referenced_widgets": [
-      "5fa05203c234442a8c863a51f83bac9d",
-      "7cf007c8f7a94bc292f8243391cea7ca",
-      "5fa6b3215e01491d9534feadee79f706",
-      "41d2dacf744d4ecaa1f51174a6703334",
-      "d5faaf8d200a4bbf9c1e9677af8fe257",
-      "aeb7614c4d7e41eeab603a70fc80ed6a",
-      "41986d51df5b41d79187acaebafe3008",
-      "e2ad8a86c24c419581c204fd2ae2ba18",
-      "811c526bd6154969b7028307dcafd550",
-      "2d1d907c0d04492097e35a9ceddea9a2",
-      "6de033864a1b4397a93147091aedda65"
-     ]
-    },
-    "id": "RyBXeiGjdN8I",
-    "outputId": "33ae5c14-857a-48d5-cd4b-803daf82c326"
-   },
-   "outputs": [
-    {
-     "name": "stdout",
-     "output_type": "stream",
-     "text": [
-      "Collecting torchvision\n",
-      "  Downloading torchvision-0.15.2-cp310-cp310-manylinux1_x86_64.whl (6.0 MB)\n",
-      "\u001b[2K     \u001b[38;2;114;156;31m\u001b[0m \u001b[32m6.0/6.0 MB\u001b[0m \u001b[31m4.9 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0mm eta \u001b[36m0:00:01\u001b[0m[36m0:00:01\u001b[0m\n",
-      "\u001b[?25hRequirement already satisfied: requests in /home/endrit/anaconda3/lib/python3.10/site-packages (from torchvision) (2.28.1)\n",
-      "Requirement already satisfied: pillow!=8.3.*,>=5.3.0 in /home/endrit/anaconda3/lib/python3.10/site-packages (from torchvision) (9.4.0)\n",
-      "Collecting torch==2.0.1\n",
-      "  Downloading torch-2.0.1-cp310-cp310-manylinux1_x86_64.whl (619.9 MB)\n",
-      "\u001b[2K     \u001b[38;2;114;156;31m\u001b[0m \u001b[32m619.9/619.9 MB\u001b[0m \u001b[31m1.6 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0mm eta \u001b[36m0:00:01\u001b[0m[36m0:00:06\u001b[0m\n",
-      "\u001b[?25hRequirement already satisfied: numpy in /home/endrit/anaconda3/lib/python3.10/site-packages (from torchvision) (1.23.5)\n",
-      "Requirement already satisfied: sympy in /home/endrit/anaconda3/lib/python3.10/site-packages (from torch==2.0.1->torchvision) (1.11.1)\n",
-      "Collecting nvidia-nccl-cu11==2.14.3\n",
-      "  Downloading nvidia_nccl_cu11-2.14.3-py3-none-manylinux1_x86_64.whl (177.1 MB)\n",
-      "\u001b[2K     \u001b[38;2;114;156;31m\u001b[0m \u001b[32m177.1/177.1 MB\u001b[0m \u001b[31m3.5 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0mm eta \u001b[36m0:00:01\u001b[0m[36m0:00:01\u001b[0m\n",
-      "\u001b[?25hRequirement already satisfied: jinja2 in /home/endrit/anaconda3/lib/python3.10/site-packages (from torch==2.0.1->torchvision) (3.1.2)\n",
-      "Requirement already satisfied: filelock in /home/endrit/anaconda3/lib/python3.10/site-packages (from torch==2.0.1->torchvision) (3.9.0)\n",
-      "Collecting nvidia-cuda-runtime-cu11==11.7.99\n",
-      "  Downloading nvidia_cuda_runtime_cu11-11.7.99-py3-none-manylinux1_x86_64.whl (849 kB)\n",
-      "\u001b[2K     \u001b[38;2;114;156;31m\u001b[0m \u001b[32m849.3/849.3 kB\u001b[0m \u001b[31m6.5 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0m[31m8.8 MB/s\u001b[0m eta \u001b[36m0:00:01\u001b[0m\n",
-      "\u001b[?25hCollecting nvidia-cufft-cu11==10.9.0.58\n",
-      "  Downloading nvidia_cufft_cu11-10.9.0.58-py3-none-manylinux1_x86_64.whl (168.4 MB)\n",
-      "\u001b[2K     \u001b[38;2;114;156;31m\u001b[0m \u001b[32m168.4/168.4 MB\u001b[0m \u001b[31m3.6 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0mm eta \u001b[36m0:00:01\u001b[0m[36m0:00:01\u001b[0m\n",
-      "\u001b[?25hCollecting nvidia-cusolver-cu11==11.4.0.1\n",
-      "  Downloading nvidia_cusolver_cu11-11.4.0.1-2-py3-none-manylinux1_x86_64.whl (102.6 MB)\n",
-      "\u001b[2K     \u001b[38;2;114;156;31m\u001b[0m \u001b[32m102.6/102.6 MB\u001b[0m \u001b[31m3.9 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0mm eta \u001b[36m0:00:01\u001b[0m[36m0:00:01\u001b[0m\n",
-      "\u001b[?25hRequirement already satisfied: networkx in /home/endrit/anaconda3/lib/python3.10/site-packages (from torch==2.0.1->torchvision) (2.8.4)\n",
-      "Collecting nvidia-cusparse-cu11==11.7.4.91\n",
-      "  Downloading nvidia_cusparse_cu11-11.7.4.91-py3-none-manylinux1_x86_64.whl (173.2 MB)\n",
-      "\u001b[2K     \u001b[38;2;114;156;31m\u001b[0m \u001b[32m173.2/173.2 MB\u001b[0m \u001b[31m3.1 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0mm eta \u001b[36m0:00:01\u001b[0m[36m0:00:01\u001b[0m\n",
-      "\u001b[?25hCollecting nvidia-curand-cu11==10.2.10.91\n",
-      "  Downloading nvidia_curand_cu11-10.2.10.91-py3-none-manylinux1_x86_64.whl (54.6 MB)\n",
-      "\u001b[2K     \u001b[38;2;114;156;31m\u001b[0m \u001b[32m54.6/54.6 MB\u001b[0m \u001b[31m4.4 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0mm eta \u001b[36m0:00:01\u001b[0m[36m0:00:01\u001b[0m\n",
-      "\u001b[?25hCollecting nvidia-nvtx-cu11==11.7.91\n",
-      "  Downloading nvidia_nvtx_cu11-11.7.91-py3-none-manylinux1_x86_64.whl (98 kB)\n",
-      "\u001b[2K     \u001b[38;2;114;156;31m\u001b[0m \u001b[32m98.6/98.6 kB\u001b[0m \u001b[31m5.0 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0m\n",
-      "\u001b[?25hRequirement already satisfied: typing-extensions in /home/endrit/anaconda3/lib/python3.10/site-packages (from torch==2.0.1->torchvision) (4.4.0)\n",
-      "Collecting nvidia-cublas-cu11==11.10.3.66\n",
-      "  Downloading nvidia_cublas_cu11-11.10.3.66-py3-none-manylinux1_x86_64.whl (317.1 MB)\n",
-      "\u001b[2K     \u001b[38;2;114;156;31m\u001b[0m \u001b[32m317.1/317.1 MB\u001b[0m \u001b[31m1.4 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0mm eta \u001b[36m0:00:01\u001b[0m[36m0:00:05\u001b[0m\n",
-      "\u001b[?25hCollecting nvidia-cuda-cupti-cu11==11.7.101\n",
-      "  Downloading nvidia_cuda_cupti_cu11-11.7.101-py3-none-manylinux1_x86_64.whl (11.8 MB)\n",
-      "\u001b[2K     \u001b[38;2;114;156;31m\u001b[0m \u001b[32m11.8/11.8 MB\u001b[0m \u001b[31m1.7 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0mm eta \u001b[36m0:00:01\u001b[0m0:01\u001b[0m:01\u001b[0m\n",
-      "\u001b[?25hCollecting nvidia-cuda-nvrtc-cu11==11.7.99\n",
-      "  Downloading nvidia_cuda_nvrtc_cu11-11.7.99-2-py3-none-manylinux1_x86_64.whl (21.0 MB)\n",
-      "\u001b[2K     \u001b[38;2;114;156;31m\u001b[0m \u001b[32m21.0/21.0 MB\u001b[0m \u001b[31m1.8 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0mm eta \u001b[36m0:00:01\u001b[0m[36m0:00:01\u001b[0m\n",
-      "\u001b[?25hCollecting triton==2.0.0\n",
-      "  Downloading triton-2.0.0-1-cp310-cp310-manylinux2014_x86_64.manylinux_2_17_x86_64.whl (63.3 MB)\n",
-      "\u001b[2K     \u001b[38;2;114;156;31m\u001b[0m \u001b[32m63.3/63.3 MB\u001b[0m \u001b[31m4.7 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0mm eta \u001b[36m0:00:01\u001b[0m[36m0:00:01\u001b[0m\n",
-      "\u001b[?25hCollecting nvidia-cudnn-cu11==8.5.0.96\n",
-      "  Downloading nvidia_cudnn_cu11-8.5.0.96-2-py3-none-manylinux1_x86_64.whl (557.1 MB)\n",
-      "\u001b[2K     \u001b[38;2;114;156;31m\u001b[0m \u001b[32m557.1/557.1 MB\u001b[0m \u001b[31m1.9 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0mm eta \u001b[36m0:00:01\u001b[0m[36m0:00:03\u001b[0m\n",
-      "\u001b[?25hRequirement already satisfied: wheel in /home/endrit/anaconda3/lib/python3.10/site-packages (from nvidia-cublas-cu11==11.10.3.66->torch==2.0.1->torchvision) (0.38.4)\n",
-      "Requirement already satisfied: setuptools in /home/endrit/anaconda3/lib/python3.10/site-packages (from nvidia-cublas-cu11==11.10.3.66->torch==2.0.1->torchvision) (65.6.3)\n",
-      "Collecting cmake\n",
-      "  Downloading cmake-3.26.3-py2.py3-none-manylinux2014_x86_64.manylinux_2_17_x86_64.whl (24.0 MB)\n",
-      "\u001b[2K     \u001b[38;2;114;156;31m\u001b[0m \u001b[32m24.0/24.0 MB\u001b[0m \u001b[31m4.6 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0mm eta \u001b[36m0:00:01\u001b[0m[36m0:00:01\u001b[0m\n",
-      "\u001b[?25hCollecting lit\n",
-      "  Downloading lit-16.0.5.tar.gz (138 kB)\n",
-      "\u001b[2K     \u001b[38;2;114;156;31m\u001b[0m \u001b[32m138.0/138.0 kB\u001b[0m \u001b[31m2.4 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0m[31m5.8 MB/s\u001b[0m eta \u001b[36m0:00:01\u001b[0m\n",
-      "\u001b[?25h  Preparing metadata (setup.py) ... \u001b[?25ldone\n",
-      "\u001b[?25hRequirement already satisfied: certifi>=2017.4.17 in /home/endrit/anaconda3/lib/python3.10/site-packages (from requests->torchvision) (2023.5.7)\n",
-      "Requirement already satisfied: urllib3<1.27,>=1.21.1 in /home/endrit/anaconda3/lib/python3.10/site-packages (from requests->torchvision) (1.26.14)\n",
-      "Requirement already satisfied: idna<4,>=2.5 in /home/endrit/anaconda3/lib/python3.10/site-packages (from requests->torchvision) (3.4)\n",
-      "Requirement already satisfied: charset-normalizer<3,>=2 in /home/endrit/anaconda3/lib/python3.10/site-packages (from requests->torchvision) (2.0.4)\n",
-      "Requirement already satisfied: MarkupSafe>=2.0 in /home/endrit/anaconda3/lib/python3.10/site-packages (from jinja2->torch==2.0.1->torchvision) (2.1.1)\n",
-      "Requirement already satisfied: mpmath>=0.19 in /home/endrit/anaconda3/lib/python3.10/site-packages/mpmath-1.2.1-py3.10.egg (from sympy->torch==2.0.1->torchvision) (1.2.1)\n",
-      "Building wheels for collected packages: lit\n",
-      "  Building wheel for lit (setup.py) ... \u001b[?25ldone\n",
-      "\u001b[?25h  Created wheel for lit: filename=lit-16.0.5-py3-none-any.whl size=88174 sha256=0b4ccc2d83d9043a5b23e1ca8facc4c4a5de200861cac9f8edfdc256e75925ad\n",
-      "  Stored in directory: /home/endrit/.cache/pip/wheels/eb/02/84/d82f0b1a6098209edf7e3607be6cc592ebbc015a8a3127c68d\n",
-      "Successfully built lit\n",
-      "Installing collected packages: lit, cmake, nvidia-nvtx-cu11, nvidia-nccl-cu11, nvidia-cusparse-cu11, nvidia-curand-cu11, nvidia-cufft-cu11, nvidia-cuda-runtime-cu11, nvidia-cuda-nvrtc-cu11, nvidia-cuda-cupti-cu11, nvidia-cublas-cu11, nvidia-cusolver-cu11, nvidia-cudnn-cu11, triton, torch, torchvision\n",
-      "  Attempting uninstall: torch\n",
-      "    Found existing installation: torch 1.12.1\n",
-      "    Uninstalling torch-1.12.1:\n",
-      "      Successfully uninstalled torch-1.12.1\n",
-      "Successfully installed cmake-3.26.3 lit-16.0.5 nvidia-cublas-cu11-11.10.3.66 nvidia-cuda-cupti-cu11-11.7.101 nvidia-cuda-nvrtc-cu11-11.7.99 nvidia-cuda-runtime-cu11-11.7.99 nvidia-cudnn-cu11-8.5.0.96 nvidia-cufft-cu11-10.9.0.58 nvidia-curand-cu11-10.2.10.91 nvidia-cusolver-cu11-11.4.0.1 nvidia-cusparse-cu11-11.7.4.91 nvidia-nccl-cu11-2.14.3 nvidia-nvtx-cu11-11.7.91 torch-2.0.1 torchvision-0.15.2 triton-2.0.0\n"
-     ]
-    },
-    {
-     "name": "stderr",
-     "output_type": "stream",
-     "text": [
-      "/home/endrit/anaconda3/lib/python3.10/site-packages/torchvision/io/image.py:13: UserWarning: Failed to load image Python extension: 'libc10_cuda.so: cannot open shared object file: No such file or directory'If you don't plan on using image functionality from `torchvision.io`, you can ignore this warning. Otherwise, there might be something wrong with your environment. Did you have `libjpeg` or `libpng` installed before building `torchvision` from source?\n",
-      "  warn(\n"
-     ]
-    },
-    {
-     "ename": "ImportError",
-     "evalue": "cannot import name '_get_cpp_backtrace' from 'torch._C' (/home/endrit/anaconda3/lib/python3.10/site-packages/torch/_C.cpython-310-x86_64-linux-gnu.so)",
-     "output_type": "error",
-     "traceback": [
-      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
-      "\u001b[0;31mImportError\u001b[0m                               Traceback (most recent call last)",
-      "Cell \u001b[0;32mIn[6], line 2\u001b[0m\n\u001b[1;32m      1\u001b[0m get_ipython()\u001b[38;5;241m.\u001b[39msystem(\u001b[38;5;124m'\u001b[39m\u001b[38;5;124mpip install torchvision\u001b[39m\u001b[38;5;124m'\u001b[39m)\n\u001b[0;32m----> 2\u001b[0m \u001b[38;5;28;01mfrom\u001b[39;00m \u001b[38;5;21;01mtrain_segmentation\u001b[39;00m \u001b[38;5;28;01mimport\u001b[39;00m LitUnsupervisedSegmenter\n\u001b[1;32m      4\u001b[0m model \u001b[38;5;241m=\u001b[39m LitUnsupervisedSegmenter\u001b[38;5;241m.\u001b[39mload_from_checkpoint(join(saved_models_dir, saved_model_name))\u001b[38;5;241m.\u001b[39mcuda()\n",
-      "File \u001b[0;32m~/STEGO/src/train_segmentation.py:1\u001b[0m\n\u001b[0;32m----> 1\u001b[0m \u001b[38;5;28;01mfrom\u001b[39;00m \u001b[38;5;21;01mutils\u001b[39;00m \u001b[38;5;28;01mimport\u001b[39;00m \u001b[38;5;241m*\u001b[39m\n\u001b[1;32m      2\u001b[0m \u001b[38;5;28;01mfrom\u001b[39;00m \u001b[38;5;21;01mmodules\u001b[39;00m \u001b[38;5;28;01mimport\u001b[39;00m \u001b[38;5;241m*\u001b[39m\n\u001b[1;32m      3\u001b[0m \u001b[38;5;28;01mfrom\u001b[39;00m \u001b[38;5;21;01mdata\u001b[39;00m \u001b[38;5;28;01mimport\u001b[39;00m \u001b[38;5;241m*\u001b[39m\n",
-      "File \u001b[0;32m~/STEGO/src/utils.py:18\u001b[0m\n\u001b[1;32m     16\u001b[0m \u001b[38;5;28;01mfrom\u001b[39;00m \u001b[38;5;21;01mtorch\u001b[39;00m\u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01mutils\u001b[39;00m\u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01mdata\u001b[39;00m\u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01m_utils\u001b[39;00m\u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01mcollate\u001b[39;00m \u001b[38;5;28;01mimport\u001b[39;00m np_str_obj_array_pattern, default_collate_err_msg_format\n\u001b[1;32m     17\u001b[0m \u001b[38;5;28;01mfrom\u001b[39;00m \u001b[38;5;21;01mtorchmetrics\u001b[39;00m \u001b[38;5;28;01mimport\u001b[39;00m Metric\n\u001b[0;32m---> 18\u001b[0m \u001b[38;5;28;01mfrom\u001b[39;00m \u001b[38;5;21;01mtorchvision\u001b[39;00m \u001b[38;5;28;01mimport\u001b[39;00m models\n\u001b[1;32m     19\u001b[0m \u001b[38;5;28;01mfrom\u001b[39;00m \u001b[38;5;21;01mtorchvision\u001b[39;00m \u001b[38;5;28;01mimport\u001b[39;00m transforms \u001b[38;5;28;01mas\u001b[39;00m T\n\u001b[1;32m     20\u001b[0m \u001b[38;5;28;01mfrom\u001b[39;00m \u001b[38;5;21;01mtorch\u001b[39;00m\u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01mutils\u001b[39;00m\u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01mtensorboard\u001b[39;00m\u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01msummary\u001b[39;00m \u001b[38;5;28;01mimport\u001b[39;00m hparams\n",
-      "File \u001b[0;32m~/anaconda3/lib/python3.10/site-packages/torchvision/__init__.py:6\u001b[0m\n\u001b[1;32m      3\u001b[0m \u001b[38;5;28;01mfrom\u001b[39;00m \u001b[38;5;21;01mmodulefinder\u001b[39;00m \u001b[38;5;28;01mimport\u001b[39;00m Module\n\u001b[1;32m      5\u001b[0m \u001b[38;5;28;01mimport\u001b[39;00m \u001b[38;5;21;01mtorch\u001b[39;00m\n\u001b[0;32m----> 6\u001b[0m \u001b[38;5;28;01mfrom\u001b[39;00m \u001b[38;5;21;01mtorchvision\u001b[39;00m \u001b[38;5;28;01mimport\u001b[39;00m datasets, io, models, ops, transforms, utils\n\u001b[1;32m      8\u001b[0m \u001b[38;5;28;01mfrom\u001b[39;00m \u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01mextension\u001b[39;00m \u001b[38;5;28;01mimport\u001b[39;00m _HAS_OPS\n\u001b[1;32m     10\u001b[0m \u001b[38;5;28;01mtry\u001b[39;00m:\n",
-      "File \u001b[0;32m~/anaconda3/lib/python3.10/site-packages/torchvision/models/__init__.py:2\u001b[0m\n\u001b[1;32m      1\u001b[0m \u001b[38;5;28;01mfrom\u001b[39;00m \u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01malexnet\u001b[39;00m \u001b[38;5;28;01mimport\u001b[39;00m \u001b[38;5;241m*\u001b[39m\n\u001b[0;32m----> 2\u001b[0m \u001b[38;5;28;01mfrom\u001b[39;00m \u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01mconvnext\u001b[39;00m \u001b[38;5;28;01mimport\u001b[39;00m \u001b[38;5;241m*\u001b[39m\n\u001b[1;32m      3\u001b[0m \u001b[38;5;28;01mfrom\u001b[39;00m \u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01mdensenet\u001b[39;00m \u001b[38;5;28;01mimport\u001b[39;00m \u001b[38;5;241m*\u001b[39m\n\u001b[1;32m      4\u001b[0m \u001b[38;5;28;01mfrom\u001b[39;00m \u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01mefficientnet\u001b[39;00m \u001b[38;5;28;01mimport\u001b[39;00m \u001b[38;5;241m*\u001b[39m\n",
-      "File \u001b[0;32m~/anaconda3/lib/python3.10/site-packages/torchvision/models/convnext.py:8\u001b[0m\n\u001b[1;32m      5\u001b[0m \u001b[38;5;28;01mfrom\u001b[39;00m \u001b[38;5;21;01mtorch\u001b[39;00m \u001b[38;5;28;01mimport\u001b[39;00m nn, Tensor\n\u001b[1;32m      6\u001b[0m \u001b[38;5;28;01mfrom\u001b[39;00m \u001b[38;5;21;01mtorch\u001b[39;00m\u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01mnn\u001b[39;00m \u001b[38;5;28;01mimport\u001b[39;00m functional \u001b[38;5;28;01mas\u001b[39;00m F\n\u001b[0;32m----> 8\u001b[0m \u001b[38;5;28;01mfrom\u001b[39;00m \u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01mops\u001b[39;00m\u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01mmisc\u001b[39;00m \u001b[38;5;28;01mimport\u001b[39;00m Conv2dNormActivation, Permute\n\u001b[1;32m      9\u001b[0m \u001b[38;5;28;01mfrom\u001b[39;00m \u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01mops\u001b[39;00m\u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01mstochastic_depth\u001b[39;00m \u001b[38;5;28;01mimport\u001b[39;00m StochasticDepth\n\u001b[1;32m     10\u001b[0m \u001b[38;5;28;01mfrom\u001b[39;00m \u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01mtransforms\u001b[39;00m\u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01m_presets\u001b[39;00m \u001b[38;5;28;01mimport\u001b[39;00m ImageClassification\n",
-      "File \u001b[0;32m~/anaconda3/lib/python3.10/site-packages/torchvision/ops/__init__.py:1\u001b[0m\n\u001b[0;32m----> 1\u001b[0m \u001b[38;5;28;01mfrom\u001b[39;00m \u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01m_register_onnx_ops\u001b[39;00m \u001b[38;5;28;01mimport\u001b[39;00m _register_custom_op\n\u001b[1;32m      2\u001b[0m \u001b[38;5;28;01mfrom\u001b[39;00m \u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01mboxes\u001b[39;00m \u001b[38;5;28;01mimport\u001b[39;00m (\n\u001b[1;32m      3\u001b[0m     batched_nms,\n\u001b[1;32m      4\u001b[0m     box_area,\n\u001b[0;32m   (...)\u001b[0m\n\u001b[1;32m     13\u001b[0m     remove_small_boxes,\n\u001b[1;32m     14\u001b[0m )\n\u001b[1;32m     15\u001b[0m \u001b[38;5;28;01mfrom\u001b[39;00m \u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01mciou_loss\u001b[39;00m \u001b[38;5;28;01mimport\u001b[39;00m complete_box_iou_loss\n",
-      "File \u001b[0;32m~/anaconda3/lib/python3.10/site-packages/torchvision/ops/_register_onnx_ops.py:5\u001b[0m\n\u001b[1;32m      2\u001b[0m \u001b[38;5;28;01mimport\u001b[39;00m \u001b[38;5;21;01mwarnings\u001b[39;00m\n\u001b[1;32m      4\u001b[0m \u001b[38;5;28;01mimport\u001b[39;00m \u001b[38;5;21;01mtorch\u001b[39;00m\n\u001b[0;32m----> 5\u001b[0m \u001b[38;5;28;01mfrom\u001b[39;00m \u001b[38;5;21;01mtorch\u001b[39;00m\u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01monnx\u001b[39;00m \u001b[38;5;28;01mimport\u001b[39;00m symbolic_opset11 \u001b[38;5;28;01mas\u001b[39;00m opset11\n\u001b[1;32m      6\u001b[0m \u001b[38;5;28;01mfrom\u001b[39;00m \u001b[38;5;21;01mtorch\u001b[39;00m\u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01monnx\u001b[39;00m\u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01msymbolic_helper\u001b[39;00m \u001b[38;5;28;01mimport\u001b[39;00m parse_args\n\u001b[1;32m      8\u001b[0m _ONNX_OPSET_VERSION_11 \u001b[38;5;241m=\u001b[39m \u001b[38;5;241m11\u001b[39m\n",
-      "File \u001b[0;32m~/anaconda3/lib/python3.10/site-packages/torch/onnx/symbolic_opset11.py:12\u001b[0m\n\u001b[1;32m     10\u001b[0m \u001b[38;5;28;01mfrom\u001b[39;00m \u001b[38;5;21;01mtorch\u001b[39;00m \u001b[38;5;28;01mimport\u001b[39;00m _C\n\u001b[1;32m     11\u001b[0m \u001b[38;5;28;01mfrom\u001b[39;00m \u001b[38;5;21;01mtorch\u001b[39;00m\u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01m_C\u001b[39;00m \u001b[38;5;28;01mimport\u001b[39;00m _onnx \u001b[38;5;28;01mas\u001b[39;00m _C_onnx\n\u001b[0;32m---> 12\u001b[0m \u001b[38;5;28;01mfrom\u001b[39;00m \u001b[38;5;21;01mtorch\u001b[39;00m\u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01monnx\u001b[39;00m \u001b[38;5;28;01mimport\u001b[39;00m (\n\u001b[1;32m     13\u001b[0m     _type_utils,\n\u001b[1;32m     14\u001b[0m     errors,\n\u001b[1;32m     15\u001b[0m     symbolic_helper,\n\u001b[1;32m     16\u001b[0m     symbolic_opset10 \u001b[38;5;28;01mas\u001b[39;00m opset10,\n\u001b[1;32m     17\u001b[0m     symbolic_opset9 \u001b[38;5;28;01mas\u001b[39;00m opset9,\n\u001b[1;32m     18\u001b[0m     utils,\n\u001b[1;32m     19\u001b[0m )\n\u001b[1;32m     20\u001b[0m \u001b[38;5;28;01mfrom\u001b[39;00m \u001b[38;5;21;01mtorch\u001b[39;00m\u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01monnx\u001b[39;00m\u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01m_globals\u001b[39;00m \u001b[38;5;28;01mimport\u001b[39;00m GLOBALS\n\u001b[1;32m     21\u001b[0m \u001b[38;5;28;01mfrom\u001b[39;00m \u001b[38;5;21;01mtorch\u001b[39;00m\u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01monnx\u001b[39;00m\u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01m_internal\u001b[39;00m \u001b[38;5;28;01mimport\u001b[39;00m _beartype, jit_utils, registration\n",
-      "File \u001b[0;32m~/anaconda3/lib/python3.10/site-packages/torch/onnx/_type_utils.py:10\u001b[0m\n\u001b[1;32m      8\u001b[0m \u001b[38;5;28;01mimport\u001b[39;00m \u001b[38;5;21;01mtorch\u001b[39;00m\n\u001b[1;32m      9\u001b[0m \u001b[38;5;28;01mfrom\u001b[39;00m \u001b[38;5;21;01mtorch\u001b[39;00m\u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01m_C\u001b[39;00m \u001b[38;5;28;01mimport\u001b[39;00m _onnx \u001b[38;5;28;01mas\u001b[39;00m _C_onnx\n\u001b[0;32m---> 10\u001b[0m \u001b[38;5;28;01mfrom\u001b[39;00m \u001b[38;5;21;01mtorch\u001b[39;00m\u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01monnx\u001b[39;00m \u001b[38;5;28;01mimport\u001b[39;00m errors\n\u001b[1;32m     11\u001b[0m \u001b[38;5;28;01mfrom\u001b[39;00m \u001b[38;5;21;01mtorch\u001b[39;00m\u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01monnx\u001b[39;00m\u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01m_internal\u001b[39;00m \u001b[38;5;28;01mimport\u001b[39;00m _beartype\n\u001b[1;32m     14\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m typing\u001b[38;5;241m.\u001b[39mTYPE_CHECKING:\n\u001b[1;32m     15\u001b[0m     \u001b[38;5;66;03m# Hack to help mypy to recognize torch._C.Value\u001b[39;00m\n",
-      "File \u001b[0;32m~/anaconda3/lib/python3.10/site-packages/torch/onnx/errors.py:9\u001b[0m\n\u001b[1;32m      7\u001b[0m \u001b[38;5;28;01mfrom\u001b[39;00m \u001b[38;5;21;01mtorch\u001b[39;00m \u001b[38;5;28;01mimport\u001b[39;00m _C\n\u001b[1;32m      8\u001b[0m \u001b[38;5;28;01mfrom\u001b[39;00m \u001b[38;5;21;01mtorch\u001b[39;00m\u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01monnx\u001b[39;00m \u001b[38;5;28;01mimport\u001b[39;00m _constants\n\u001b[0;32m----> 9\u001b[0m \u001b[38;5;28;01mfrom\u001b[39;00m \u001b[38;5;21;01mtorch\u001b[39;00m\u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01monnx\u001b[39;00m\u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01m_internal\u001b[39;00m \u001b[38;5;28;01mimport\u001b[39;00m diagnostics\n\u001b[1;32m     11\u001b[0m __all__ \u001b[38;5;241m=\u001b[39m [\n\u001b[1;32m     12\u001b[0m     \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mOnnxExporterError\u001b[39m\u001b[38;5;124m\"\u001b[39m,\n\u001b[1;32m     13\u001b[0m     \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mOnnxExporterWarning\u001b[39m\u001b[38;5;124m\"\u001b[39m,\n\u001b[0;32m   (...)\u001b[0m\n\u001b[1;32m     17\u001b[0m     \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mSymbolicValueError\u001b[39m\u001b[38;5;124m\"\u001b[39m,\n\u001b[1;32m     18\u001b[0m ]\n\u001b[1;32m     21\u001b[0m \u001b[38;5;28;01mclass\u001b[39;00m \u001b[38;5;21;01mOnnxExporterWarning\u001b[39;00m(\u001b[38;5;167;01mUserWarning\u001b[39;00m):\n",
-      "File \u001b[0;32m~/anaconda3/lib/python3.10/site-packages/torch/onnx/_internal/diagnostics/__init__.py:1\u001b[0m\n\u001b[0;32m----> 1\u001b[0m \u001b[38;5;28;01mfrom\u001b[39;00m \u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01m_diagnostic\u001b[39;00m \u001b[38;5;28;01mimport\u001b[39;00m (\n\u001b[1;32m      2\u001b[0m     create_export_diagnostic_context,\n\u001b[1;32m      3\u001b[0m     diagnose,\n\u001b[1;32m      4\u001b[0m     engine,\n\u001b[1;32m      5\u001b[0m     export_context,\n\u001b[1;32m      6\u001b[0m     ExportDiagnostic,\n\u001b[1;32m      7\u001b[0m )\n\u001b[1;32m      8\u001b[0m \u001b[38;5;28;01mfrom\u001b[39;00m \u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01m_rules\u001b[39;00m \u001b[38;5;28;01mimport\u001b[39;00m rules\n\u001b[1;32m      9\u001b[0m \u001b[38;5;28;01mfrom\u001b[39;00m \u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01minfra\u001b[39;00m \u001b[38;5;28;01mimport\u001b[39;00m levels\n",
-      "File \u001b[0;32m~/anaconda3/lib/python3.10/site-packages/torch/onnx/_internal/diagnostics/_diagnostic.py:11\u001b[0m\n\u001b[1;32m      8\u001b[0m \u001b[38;5;28;01mimport\u001b[39;00m \u001b[38;5;21;01mtorch\u001b[39;00m\n\u001b[1;32m     10\u001b[0m \u001b[38;5;28;01mfrom\u001b[39;00m \u001b[38;5;21;01mtorch\u001b[39;00m\u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01monnx\u001b[39;00m\u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01m_internal\u001b[39;00m\u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01mdiagnostics\u001b[39;00m \u001b[38;5;28;01mimport\u001b[39;00m infra\n\u001b[0;32m---> 11\u001b[0m \u001b[38;5;28;01mfrom\u001b[39;00m \u001b[38;5;21;01mtorch\u001b[39;00m\u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01mutils\u001b[39;00m \u001b[38;5;28;01mimport\u001b[39;00m cpp_backtrace\n\u001b[1;32m     14\u001b[0m \u001b[38;5;28;01mdef\u001b[39;00m \u001b[38;5;21m_cpp_call_stack\u001b[39m(frames_to_skip: \u001b[38;5;28mint\u001b[39m \u001b[38;5;241m=\u001b[39m \u001b[38;5;241m0\u001b[39m, frames_to_log: \u001b[38;5;28mint\u001b[39m \u001b[38;5;241m=\u001b[39m \u001b[38;5;241m32\u001b[39m) \u001b[38;5;241m-\u001b[39m\u001b[38;5;241m>\u001b[39m infra\u001b[38;5;241m.\u001b[39mStack:\n\u001b[1;32m     15\u001b[0m     \u001b[38;5;124;03m\"\"\"Returns the current C++ call stack.\u001b[39;00m\n\u001b[1;32m     16\u001b[0m \n\u001b[1;32m     17\u001b[0m \u001b[38;5;124;03m    This function utilizes `torch.utils.cpp_backtrace` to get the current C++ call stack.\u001b[39;00m\n\u001b[0;32m   (...)\u001b[0m\n\u001b[1;32m     21\u001b[0m \n\u001b[1;32m     22\u001b[0m \u001b[38;5;124;03m    \"\"\"\u001b[39;00m\n",
-      "File \u001b[0;32m~/anaconda3/lib/python3.10/site-packages/torch/utils/cpp_backtrace.py:1\u001b[0m\n\u001b[0;32m----> 1\u001b[0m \u001b[38;5;28;01mfrom\u001b[39;00m \u001b[38;5;21;01mtorch\u001b[39;00m\u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01m_C\u001b[39;00m \u001b[38;5;28;01mimport\u001b[39;00m _get_cpp_backtrace\n\u001b[1;32m      3\u001b[0m \u001b[38;5;28;01mdef\u001b[39;00m \u001b[38;5;21mget_cpp_backtrace\u001b[39m(frames_to_skip\u001b[38;5;241m=\u001b[39m\u001b[38;5;241m0\u001b[39m, maximum_number_of_frames\u001b[38;5;241m=\u001b[39m\u001b[38;5;241m64\u001b[39m) \u001b[38;5;241m-\u001b[39m\u001b[38;5;241m>\u001b[39m \u001b[38;5;28mstr\u001b[39m:\n\u001b[1;32m      4\u001b[0m     \u001b[38;5;124mr\u001b[39m\u001b[38;5;124;03m\"\"\"\u001b[39;00m\n\u001b[1;32m      5\u001b[0m \u001b[38;5;124;03m    Returns a string containing the C++ stack trace of the current thread.\u001b[39;00m\n\u001b[1;32m      6\u001b[0m \u001b[38;5;124;03m    Args:\u001b[39;00m\n\u001b[1;32m      7\u001b[0m \u001b[38;5;124;03m        frames_to_skip (int): the number of frames to skip from the top of the stack\u001b[39;00m\n\u001b[1;32m      8\u001b[0m \u001b[38;5;124;03m        maximum_number_of_frames (int): the maximum number of frames to return\u001b[39;00m\n\u001b[1;32m      9\u001b[0m \u001b[38;5;124;03m    \"\"\"\u001b[39;00m\n",
-      "\u001b[0;31mImportError\u001b[0m: cannot import name '_get_cpp_backtrace' from 'torch._C' (/home/endrit/anaconda3/lib/python3.10/site-packages/torch/_C.cpython-310-x86_64-linux-gnu.so)"
-     ]
-    }
-   ],
-   "source": [
-    "!pip install torchvision\n",
-    "from train_segmentation import LitUnsupervisedSegmenter\n",
-    "\n",
-    "model = LitUnsupervisedSegmenter.load_from_checkpoint(join(saved_models_dir, saved_model_name)).cuda()"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "metadata": {
-    "id": "ATktWg_hBbuS"
-   },
-   "source": [
-    "# Load Image"
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 6,
-   "metadata": {
-    "colab": {
-     "base_uri": "https://localhost:8080/"
-    },
-    "id": "Ku-prYXZ8quf",
-    "outputId": "f3c132f1-f380-4431-ed6d-7d158d3af41b"
-   },
-   "outputs": [
-    {
-     "ename": "ModuleNotFoundError",
-     "evalue": "No module named 'torchvision'",
-     "output_type": "error",
-     "traceback": [
-      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
-      "\u001b[0;31mModuleNotFoundError\u001b[0m                       Traceback (most recent call last)",
-      "Cell \u001b[0;32mIn[6], line 4\u001b[0m\n\u001b[1;32m      2\u001b[0m \u001b[38;5;28;01mimport\u001b[39;00m \u001b[38;5;21;01mrequests\u001b[39;00m\n\u001b[1;32m      3\u001b[0m \u001b[38;5;28;01mfrom\u001b[39;00m \u001b[38;5;21;01mio\u001b[39;00m \u001b[38;5;28;01mimport\u001b[39;00m BytesIO\n\u001b[0;32m----> 4\u001b[0m \u001b[38;5;28;01mfrom\u001b[39;00m \u001b[38;5;21;01mtorchvision\u001b[39;00m\u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01mtransforms\u001b[39;00m\u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01mfunctional\u001b[39;00m \u001b[38;5;28;01mimport\u001b[39;00m to_tensor\n\u001b[1;32m      5\u001b[0m \u001b[38;5;28;01mfrom\u001b[39;00m \u001b[38;5;21;01mutils\u001b[39;00m \u001b[38;5;28;01mimport\u001b[39;00m get_transform\n\u001b[1;32m      7\u001b[0m img_url \u001b[38;5;241m=\u001b[39m\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mhttps://marhamilresearch4.blob.core.windows.net/stego-public/sample_images/moto1.jpg\u001b[39m\u001b[38;5;124m\"\u001b[39m\n",
-      "\u001b[0;31mModuleNotFoundError\u001b[0m: No module named 'torchvision'"
-     ]
-    }
-   ],
-   "source": [
-    "from PIL import Image\n",
-    "import requests\n",
-    "from io import BytesIO\n",
-    "from torchvision.transforms.functional import to_tensor\n",
-    "from utils import get_transform\n",
-    "\n",
-    "img_url =\"https://marhamilresearch4.blob.core.windows.net/stego-public/sample_images/moto1.jpg\"\n",
-    "response = requests.get(img_url)\n",
-    "img = Image.open(BytesIO(response.content))\n",
-    "transform = get_transform(448, False, \"center\")\n",
-    "img = transform(img).unsqueeze(0).cuda()"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "metadata": {
-    "id": "5xXhpW6BBeWz"
-   },
-   "source": [
-    "# Query model and pass result through CRF"
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 9,
-   "metadata": {
-    "id": "e0hvX1KX30SC"
-   },
-   "outputs": [
-    {
-     "ename": "ModuleNotFoundError",
-     "evalue": "No module named 'torchvision'",
-     "output_type": "error",
-     "traceback": [
-      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
-      "\u001b[0;31mModuleNotFoundError\u001b[0m                       Traceback (most recent call last)",
-      "Cell \u001b[0;32mIn[9], line 2\u001b[0m\n\u001b[1;32m      1\u001b[0m \u001b[38;5;28;01mimport\u001b[39;00m \u001b[38;5;21;01mtorch\u001b[39;00m\u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01mnn\u001b[39;00m\u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01mfunctional\u001b[39;00m \u001b[38;5;28;01mas\u001b[39;00m \u001b[38;5;21;01mF\u001b[39;00m\n\u001b[0;32m----> 2\u001b[0m \u001b[38;5;28;01mfrom\u001b[39;00m \u001b[38;5;21;01mcrf\u001b[39;00m \u001b[38;5;28;01mimport\u001b[39;00m dense_crf\n\u001b[1;32m      3\u001b[0m \u001b[38;5;28;01mimport\u001b[39;00m \u001b[38;5;21;01mtorch\u001b[39;00m\n\u001b[1;32m      5\u001b[0m \u001b[38;5;28;01mwith\u001b[39;00m torch\u001b[38;5;241m.\u001b[39mno_grad():\n",
-      "File \u001b[0;32m~/STEGO/src/crf.py:10\u001b[0m\n\u001b[1;32m      8\u001b[0m \u001b[38;5;28;01mimport\u001b[39;00m \u001b[38;5;21;01mtorch\u001b[39;00m\n\u001b[1;32m      9\u001b[0m \u001b[38;5;28;01mimport\u001b[39;00m \u001b[38;5;21;01mtorch\u001b[39;00m\u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01mnn\u001b[39;00m\u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01mfunctional\u001b[39;00m \u001b[38;5;28;01mas\u001b[39;00m \u001b[38;5;21;01mF\u001b[39;00m\n\u001b[0;32m---> 10\u001b[0m \u001b[38;5;28;01mimport\u001b[39;00m \u001b[38;5;21;01mtorchvision\u001b[39;00m\u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01mtransforms\u001b[39;00m\u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01mfunctional\u001b[39;00m \u001b[38;5;28;01mas\u001b[39;00m \u001b[38;5;21;01mVF\u001b[39;00m\n\u001b[1;32m     11\u001b[0m \u001b[38;5;28;01mfrom\u001b[39;00m \u001b[38;5;21;01mutils\u001b[39;00m \u001b[38;5;28;01mimport\u001b[39;00m unnorm\n\u001b[1;32m     13\u001b[0m MAX_ITER \u001b[38;5;241m=\u001b[39m \u001b[38;5;241m10\u001b[39m\n",
-      "\u001b[0;31mModuleNotFoundError\u001b[0m: No module named 'torchvision'"
-     ]
-    }
-   ],
-   "source": [
-    "import torch.nn.functional as F\n",
-    "from crf import dense_crf\n",
-    "import torch\n",
-    "\n",
-    "with torch.no_grad():\n",
-    "  code1 = model(img)\n",
-    "  code2 = model(img.flip(dims=[3]))\n",
-    "  code  = (code1 + code2.flip(dims=[3])) / 2\n",
-    "  code = F.interpolate(code, img.shape[-2:], mode='bilinear', align_corners=False)\n",
-    "  linear_probs = torch.log_softmax(model.linear_probe(code), dim=1).cpu()\n",
-    "  cluster_probs = model.cluster_probe(code, 2, log_probs=True).cpu()\n",
-    "\n",
-    "  single_img = img[0].cpu()\n",
-    "  linear_pred = dense_crf(single_img, linear_probs[0]).argmax(0)\n",
-    "  cluster_pred = dense_crf(single_img, cluster_probs[0]).argmax(0)"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "metadata": {
-    "id": "BxPO9i4rBjpH"
-   },
-   "source": [
-    "# Visualize Result\n",
-    "\n",
-    "Note that cluster predictions will not be matched with ground truth classes in this example. For hungarian matching please use: `eval_segmentation.py`"
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 12,
-   "metadata": {
-    "colab": {
-     "base_uri": "https://localhost:8080/",
-     "height": 314
-    },
-    "id": "3G7CIyYG-hXj",
-    "outputId": "4731d8de-d772-4818-9d14-679de5af7060"
-   },
-   "outputs": [
-    {
-     "name": "stderr",
-     "output_type": "stream",
-     "text": [
-      "Clipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers).\n"
-     ]
-    },
-    {
-     "data": {
-      "image/png": "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\n",
-      "text/plain": [
-       "<Figure size 1080x360 with 3 Axes>"
-      ]
-     },
-     "metadata": {},
-     "output_type": "display_data"
-    }
-   ],
-   "source": [
-    "import matplotlib.pyplot as plt\n",
-    "from utils import unnorm, remove_axes\n",
-    "fig, ax = plt.subplots(1,3, figsize=(5*3,5))\n",
-    "ax[0].imshow(unnorm(img)[0].permute(1,2,0).cpu())\n",
-    "ax[0].set_title(\"Image\")\n",
-    "ax[1].imshow(model.label_cmap[cluster_pred])\n",
-    "ax[1].set_title(\"Cluster Predictions\")\n",
-    "ax[2].imshow(model.label_cmap[linear_pred])\n",
-    "ax[2].set_title(\"Linear Probe Predictions\")\n",
-    "remove_axes(ax)"
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": null,
-   "metadata": {
-    "id": "IZtla3AI-uTX"
-   },
-   "outputs": [],
-   "source": []
+   "metadata": {},
+   "cell_type": "raw",
+   "source": "",
+   "id": "290685329325b002"
   }
  ],
- "metadata": {
-  "accelerator": "GPU",
-  "colab": {
-   "name": "STEGO Colab Demo.ipynb",
-   "provenance": []
-  },
-  "kernelspec": {
-   "display_name": "Python 3 (ipykernel)",
-   "language": "python",
-   "name": "python3"
-  },
-  "language_info": {
-   "codemirror_mode": {
-    "name": "ipython",
-    "version": 3
-   },
-   "file_extension": ".py",
-   "mimetype": "text/x-python",
-   "name": "python",
-   "nbconvert_exporter": "python",
-   "pygments_lexer": "ipython3",
-   "version": "3.10.9"
-  },
-  "widgets": {
-   "application/vnd.jupyter.widget-state+json": {
-    "2d1d907c0d04492097e35a9ceddea9a2": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": null,
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": null
-     }
-    },
-    "41986d51df5b41d79187acaebafe3008": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "DescriptionStyleModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "DescriptionStyleModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "StyleView",
-      "description_width": ""
-     }
-    },
-    "41d2dacf744d4ecaa1f51174a6703334": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "HTMLModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "HTMLModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "HTMLView",
-      "description": "",
-      "description_tooltip": null,
-      "layout": "IPY_MODEL_2d1d907c0d04492097e35a9ceddea9a2",
-      "placeholder": "",
-      "style": "IPY_MODEL_6de033864a1b4397a93147091aedda65",
-      "value": " 327M/327M [00:15&lt;00:00, 25.4MB/s]"
-     }
-    },
-    "5fa05203c234442a8c863a51f83bac9d": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "HBoxModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "HBoxModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "HBoxView",
-      "box_style": "",
-      "children": [
-       "IPY_MODEL_7cf007c8f7a94bc292f8243391cea7ca",
-       "IPY_MODEL_5fa6b3215e01491d9534feadee79f706",
-       "IPY_MODEL_41d2dacf744d4ecaa1f51174a6703334"
-      ],
-      "layout": "IPY_MODEL_d5faaf8d200a4bbf9c1e9677af8fe257"
-     }
-    },
-    "5fa6b3215e01491d9534feadee79f706": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "FloatProgressModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "FloatProgressModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "ProgressView",
-      "bar_style": "success",
-      "description": "",
-      "description_tooltip": null,
-      "layout": "IPY_MODEL_e2ad8a86c24c419581c204fd2ae2ba18",
-      "max": 343279349,
-      "min": 0,
-      "orientation": "horizontal",
-      "style": "IPY_MODEL_811c526bd6154969b7028307dcafd550",
-      "value": 343279349
-     }
-    },
-    "6de033864a1b4397a93147091aedda65": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "DescriptionStyleModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "DescriptionStyleModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "StyleView",
-      "description_width": ""
-     }
-    },
-    "7cf007c8f7a94bc292f8243391cea7ca": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "HTMLModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "HTMLModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "HTMLView",
-      "description": "",
-      "description_tooltip": null,
-      "layout": "IPY_MODEL_aeb7614c4d7e41eeab603a70fc80ed6a",
-      "placeholder": "",
-      "style": "IPY_MODEL_41986d51df5b41d79187acaebafe3008",
-      "value": "100%"
-     }
-    },
-    "811c526bd6154969b7028307dcafd550": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "ProgressStyleModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "ProgressStyleModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "StyleView",
-      "bar_color": null,
-      "description_width": ""
-     }
-    },
-    "aeb7614c4d7e41eeab603a70fc80ed6a": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": null,
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": null
-     }
-    },
-    "d5faaf8d200a4bbf9c1e9677af8fe257": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": null,
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": null
-     }
-    },
-    "e2ad8a86c24c419581c204fd2ae2ba18": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": null,
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": null
-     }
-    }
-   }
-  }
- },
- "nbformat": 4,
- "nbformat_minor": 4
+ "metadata": {},
+ "nbformat": 5,
+ "nbformat_minor": 9
 }
